 MODULE NEWTYPE

    IMPLICIT NONE
    
        TYPE FVALUE
        	REAL*8 :: D00,D10,D01
        END TYPE FVALUE

        ! 2D POINT
        TYPE POINT2D
        	REAL(8) :: X,Y
        END TYPE POINT2D

        ! 2D VECTOR
        TYPE VEC2D
        	TYPE(POINT2D) :: U,V
        END TYPE VEC2D

        ! 2D INTEGER VECTOR
        TYPE INT2D
        	INTEGER :: A, B
        END TYPE INT2D

        ! 3D INTEGER VECTOR
        TYPE INT3D
        	INTEGER :: A,B,C
        END TYPE INT3D

        ! RECTANGULAR PATCH 2D
        TYPE RECPATCH
        	TYPE(POINT2D) :: PT1,PT2,PT3,PT4
        END TYPE RECPATCH

        ! TRIANGULAR PATCH 2D
        TYPE TRIPATCH
            TYPE(POINT2D) :: PT1, PT2, PT3
        END TYPE TRIPATCH
        
        TYPE TRANSFORM2D
		TYPE(POINT2D) :: PT
		REAL(8) :: JACOBIAN, DXDX, DXDY, DYDX, DYDY
	END TYPE TRANSFORM2D
        
        TYPE DISPLACEMENT
        	REAL*8 :: W0, PIX, PIY
        END TYPE DISPLACEMENT

		TYPE MOMENT
			REAL*8 :: MXX, MYY, MXY
		END TYPE MOMENT
		
		TYPE STRESS
			REAL*8 :: SXX, SYY, SXY, SYZ, SXZ
		END TYPE STRESS
		
        ! NEW OPERATION ON THE NEW TYPE
        INTERFACE OPERATOR(+)
        MODULE PROCEDURE EXT_PATCH
        MODULE PROCEDURE ADD_POINT2D
        MODULE PROCEDURE EXT_VEC2D
        END INTERFACE

	INTERFACE OPERATOR(-)
		MODULE PROCEDURE SUBTRACT_PT2D
	END INTERFACE
				
		INTERFACE OPERATOR(.AND.)
		MODULE PROCEDURE RECPATCH_INTERSECTION
		END INTERFACE

	INTERFACE OPERATOR(.IN.)
		MODULE PROCEDURE BELONGTO_R
		MODULE PROCEDURE LIEON
		MODULE PROCEDURE PTLIEON
		MODULE PROCEDURE REC_BELONGTO_REC
	END INTERFACE

CONTAINS

!!!!! FUNCTIONS FOR THE NEW OPERATION + !!!!!
	TYPE(RECPATCH) FUNCTION EXT_PATCH(OLDPATCH,AMOUNT)
		TYPE(RECPATCH), INTENT(IN) :: OLDPATCH
		REAL*8, INTENT(IN) :: AMOUNT

		EXT_PATCH%PT1=POINT2D(OLDPATCH%PT1%X-AMOUNT,OLDPATCH%PT1%Y-AMOUNT)
		EXT_PATCH%PT2=POINT2D(OLDPATCH%PT2%X+AMOUNT,OLDPATCH%PT2%Y-AMOUNT)
		EXT_PATCH%PT3=POINT2D(OLDPATCH%PT3%X+AMOUNT,OLDPATCH%PT3%Y+AMOUNT)
		EXT_PATCH%PT4=POINT2D(OLDPATCH%PT4%X-AMOUNT,OLDPATCH%PT4%Y+AMOUNT)
		
	END FUNCTION EXT_PATCH

        TYPE(VEC2D) FUNCTION EXT_VEC2D(INVEC,AMOUNT)
            TYPE(VEC2D),INTENT(IN) :: INVEC
            REAL(8), INTENT(IN) :: AMOUNT
            EXT_VEC2D%U%X=INVEC%U%X-AMOUNT
            EXT_VEC2D%U%Y=INVEC%U%Y-AMOUNT
            EXT_VEC2D%V%X=INVEC%V%X+AMOUNT
            EXT_VEC2D%V%Y=INVEC%V%Y+AMOUNT
        END FUNCTION EXT_VEC2D

	TYPE(POINT2D) FUNCTION ADD_POINT2D(PT1,PT2)
	    TYPE(POINT2D),INTENT(IN) :: PT1,PT2
	    ADD_POINT2D%X=PT1%X+PT2%X
	    ADD_POINT2D%Y=PT1%Y+PT2%Y
	END FUNCTION ADD_POINT2D

	TYPE(POINT2D) FUNCTION SUBTRACT_PT2D(PT1,PT2)

		TYPE(POINT2D), INTENT(IN) :: PT1, PT2

		SUBTRACT_PT2D = POINT2D(PT1%X-PT2%X,PT1%Y-PT2%Y)

	END FUNCTION SUBTRACT_PT2D

!!!!! FUNCTIONS FOR THE NEW OPERATION .AND. !!!!!
	TYPE(RECPATCH) FUNCTION RECPATCH_INTERSECTION(PATCH1,PATCH2)
		TYPE(RECPATCH),INTENT(IN) :: PATCH1,PATCH2
		LOGICAL :: VALIDATION
		REAL(8) :: SX,BX,SY,BY
		
		VALIDATION=VALIDATE_INTERSECTION(PATCH1,PATCH2)
		
		IF (VALIDATION) THEN
			SX=MAX(PATCH1%PT1%X,PATCH2%PT1%X)
			BX=MIN(PATCH1%PT2%X,PATCH2%PT2%X)
			SY=MAX(PATCH1%PT1%Y,PATCH2%PT1%Y)
			BY=MIN(PATCH1%PT3%Y,PATCH2%PT3%Y)

			RECPATCH_INTERSECTION=RECPATCH(POINT2D(SX,SY),POINT2D(BX,SY),&
		                                POINT2D(BX,BY),POINT2D(SX,BY))
		ELSE
			RECPATCH_INTERSECTION=RECPATCH(POINT2D(0.0D0,0.0D0),POINT2D(0.0D0,0.0D0),&
										   POINT2D(0.0D0,0.0D0),POINT2D(0.0D0,0.0D0))
		ENDIF	

	END FUNCTION RECPATCH_INTERSECTION

LOGICAL FUNCTION REC_BELONGTO_REC(SMALL_BOX, BIG_BOX)

TYPE(RECPATCH), INTENT(IN) :: SMALL_BOX, BIG_BOX
	LOGICAL :: MASK(4)
	
	IF (((SMALL_BOX%PT1.IN.BIG_BOX).EQV..TRUE.) .AND. ((SMALL_BOX%PT2.IN.BIG_BOX).EQV..TRUE.) .AND. &
			((SMALL_BOX%PT3.IN.BIG_BOX).EQV..TRUE.) .AND. ((SMALL_BOX%PT4.IN.BIG_BOX).EQV..TRUE.)) THEN
		REC_BELONGTO_REC = .TRUE.
	ELSE
		REC_BELONGTO_REC = .FALSE.
	ENDIF
	
END FUNCTION REC_BELONGTO_REC

LOGICAL FUNCTION BELONGTO_R(PT, RCTNGLE)
	TYPE(POINT2D), INTENT(IN) :: PT
	TYPE(RECPATCH), INTENT(IN) :: RCTNGLE
	
	TYPE(POINT2D) :: R(4)
	LOGICAL :: MASK(4)
	REAL*8 :: TOL, M
	INTEGER :: I
	
	TOL = 5.0D-15
	
	R(1) = RCTNGLE%PT1; R(2) = RCTNGLE%PT2
	R(3) = RCTNGLE%PT3; R(4) = RCTNGLE%PT4
	
	!----- ON BOTTOM LINE OF RECTANGLE -----!
	IF (DABS(R(1)%Y - R(2)%Y).LE.TOL) THEN
		IF (PT%Y-R(1)%Y.GE.TOL) THEN
			MASK(1) = .TRUE.
		ELSEIF (DABS(PT%Y-R(1)%Y).LE.TOL) THEN
			MASK(1) = .TRUE.
		ELSE
			MASK(1) = .FALSE.
		ENDIF
	ELSE!IF ((DABS(R(1)%Y - R(2)%Y).GT.TOL) THEN
		M = (R(2)%Y - R(1)%Y) / (R(2)%X - R(1)%X)
		IF (PT%Y - (M*(PT%X - R(1)%X) + R(1)%Y).GE.TOL) THEN
			MASK(1) = .TRUE.
		ELSEIF (DABS(PT%Y - (M*(PT%X - R(1)%X) + R(1)%Y)).LE.TOL) THEN
			MASK(1) = .TRUE.
		ELSE
			MASK(1) = .FALSE.
		ENDIF
	ENDIF

	!----- ON TOP LINE OF RECTANGLE -----!
	IF (DABS(R(3)%Y - R(4)%Y).LE.TOL) THEN
		IF (PT%Y-R(3)%Y.LE.TOL) THEN
			MASK(3) = .TRUE.
		ELSEIF (DABS(PT%Y - R(3)%Y).LE.TOL) THEN
			MASK(3) = .TRUE.
		ELSE
			MASK(3) = .FALSE.
		ENDIF
	ELSE!IF ((DABS(R(3)%Y - R(4)%Y).GT.TOL) THEN
		M = (R(3)%Y - R(4)%Y) / (R(3)%X - R(4)%X)
		IF (PT%Y - (M*(PT%X - R(4)%X) + R(4)%Y).LE.TOL) THEN
			MASK(3) = .TRUE.
		ELSEIF (DABS(PT%Y - (M*(PT%X - R(4)%X) + R(4)%Y)).LE.TOL) THEN
			MASK(3) = .TRUE.
		ELSE
			MASK(3) = .FALSE.
		ENDIF
	ENDIF

	!----- ON RIGHT LINE OF RECTANGLE -----!
	IF (DABS(R(2)%X - R(3)%X).LE.TOL) THEN
		IF (PT%X-R(2)%X.LE.TOL) THEN
			MASK(2) = .TRUE.
		ELSEIF (DABS(PT%X-R(2)%X).LE.TOL) THEN
			MASK(2) = .TRUE.
		ELSE
			MASK(2) = .FALSE.
		ENDIF
	ELSE!IF ((DABS(R(2)%X - R(3)%X).GT.TOL) THEN
		M = (R(3)%X - R(2)%X) / (R(3)%Y - R(2)%Y)
		IF (PT%X - (M*(PT%Y - R(2)%Y) + R(2)%X).LE.TOL) THEN
			MASK(2) = .TRUE.
		ELSEIF (DABS(PT%X - (M*(PT%Y - R(2)%Y) + R(2)%X)).LE.TOL) THEN
			MASK(2) = .TRUE.
		ELSE
			MASK(2) = .FALSE.
		ENDIF
	ENDIF

	!----- ON LEFT LINE OF RECTANGLE -----!
	IF (DABS(R(4)%X - R(1)%X).LE.TOL) THEN
		IF (PT%X-R(1)%X.GE.TOL) THEN
			MASK(4) = .TRUE.
		ELSEIF (DABS(PT%X-R(1)%X).LE.TOL) THEN
			MASK(4) = .TRUE.
		ELSE
			MASK(4) = .FALSE.
		ENDIF
	ELSE!IF ((DABS(R(4)%X - R(1)%X).GT.TOL) THEN
		M = (R(4)%X - R(1)%X) / (R(4)%Y - R(1)%Y)
		IF (PT%X - (M*(PT%Y - R(1)%Y) + R(1)%X).GE.TOL) THEN
			MASK(4) = .TRUE.
		ELSEIF (DABS(PT%X - (M*(PT%Y - R(1)%Y) + R(1)%X)).LE.TOL) THEN
			MASK(4) = .TRUE.
		ELSE
			MASK(4) = .FALSE.
		ENDIF
	ENDIF
	
	BELONGTO_R = .TRUE.
	DO I=1, 4
		IF (MASK(I).EQV..FALSE.) THEN
			BELONGTO_R = .FALSE.
		ENDIF
	ENDDO

	DO I=1, 4
		IF ((DABS(PT%X - R(I)%X).LE.TOL) .AND. (DABS(PT%Y - R(I)%Y).LE.TOL)) THEN
			BELONGTO_R = .TRUE.
			GOTO 111
		ENDIF
	ENDDO
	111 CONTINUE
	
END FUNCTION BELONGTO_R

LOGICAL FUNCTION LIEON(LN1,LN2)	! LN1 = TEST LINE, LN2 = BOUNDARY
	TYPE(VEC2D), INTENT(IN) :: LN1, LN2
	
	TYPE(POINT2D) :: U(2), V(2)
	REAL*8 :: TOL, Y(2), TEMP, M
	
	LIEON = .FALSE.
	
	TOL = 5.0D-15
	U(1) = LN1%U; U(2) = LN2%U
	V(1) = LN1%V; V(2) = LN2%V
	
	IF (DABS(U(2)%X-V(2)%X).LE.TOL) THEN
		IF ((DABS(U(1)%X-V(1)%X).LE.TOL).AND.(DABS(U(1)%X-U(2)%X).LE.TOL)) THEN
			IF ((((MAX(U(1)%Y, V(1)%Y) - MAX(U(2)%Y, V(2)%Y)).LE.TOL).OR.&
					(DABS(MAX(U(1)%Y, V(1)%Y) - MAX(U(2)%Y, V(2)%Y)).LE.TOL)).AND.&
					(((MIN(U(1)%Y, V(1)%Y) - MIN(U(2)%Y, V(2)%Y)).GE.TOL).OR.&
					(DABS(MIN(U(1)%Y, V(1)%Y) - MIN(U(2)%Y, V(2)%Y)).LE.TOL))) THEN
					LIEON = .TRUE.
			ENDIF
		ENDIF
	ELSEIF (DABS(U(2)%Y-V(2)%Y).LE.TOL) THEN
		IF ((DABS(U(1)%Y-V(1)%Y).LE.TOL).AND.(DABS(U(1)%Y-U(2)%Y).LE.TOL)) THEN
			IF ((((MAX(U(1)%X, V(1)%X) - MAX(U(2)%X, V(2)%X)).LE.TOL).OR.&
					(DABS(MAX(U(1)%X, V(1)%X) - MAX(U(2)%X, V(2)%X)).LE.TOL)).AND.&
					(((MIN(U(1)%X, V(1)%X) - MIN(U(2)%X, V(2)%X)).GE.TOL).OR.&
					(DABS(MIN(U(1)%X, V(1)%X) - MIN(U(2)%X, V(2)%X)).LE.TOL))) THEN
				 LIEON = .TRUE.
			ENDIF
		ENDIF
	ELSE
		IF (V(2)%X.GE.U(2)%X) THEN
			TEMP = U(2)%X
			U(2)%X = V(2)%X
			V(2)%X = TEMP
			TEMP = U(2)%Y
			U(2)%Y = V(2)%Y
			V(2)%Y = TEMP
		ENDIF
		M = (U(2)%Y-V(2)%Y) / (U(2)%X-V(2)%X)
		Y(1) = M*(U(1)%X - V(2)%X) + V(2)%Y
		Y(2) = M*(V(1)%X - V(2)%X) + V(2)%Y
		IF (((MAX(U(1)%X,V(1)%X) - MAX(U(2)%X,V(2)%X)).LE.TOL).AND.((MIN(U(1)%X,V(1)%X) - MIN(U(2)%X,V(2)%X)).GE.TOL).AND.&
				(DABS(Y(1)-U(1)%Y).LE.TOL).AND.(DABS(Y(2)-V(1)%Y).LE.TOL)) THEN
!		IF ((U(1)%X - V(2)%X).GE.TOL.AND.(U(1)%X - U(2)%X).LE.TOL.AND.(DABS(Y(1)-U(1)%Y).LE.TOL).AND.(DABS(Y(2)-V(1)%Y).LE.TOL)) THEN
			LIEON = .TRUE.
		ENDIF
	ENDIF
END FUNCTION LIEON

LOGICAL FUNCTION PTLIEON(PT,LN)	! PT = TEST POINT, LN2 = BOUNDARY
	TYPE(POINT2D), INTENT(IN) :: PT
	TYPE(VEC2D), INTENT(IN) :: LN
	
	TYPE(POINT2D) :: U, V
	REAL*8 :: TOL, Y, TEMP, M

	PTLIEON=.FALSE.
	
	TOL = 5.0D-15
	U = LN%U
	V = LN%V
	
	IF (DABS(U%X-V%X).LE.TOL) THEN
		IF (V%Y.GE.U%Y) THEN
			TEMP = U%Y
			U%Y = V%Y
			V%Y = TEMP
		ENDIF
		IF ((DABS(U%X-PT%X).LE.TOL).AND.(PT%Y.GE.V%Y).AND.(PT%Y.LE.U%Y)) THEN
		    PTLIEON=.TRUE.
		ENDIF
	ELSE
		IF (V%X.GE.U%X) THEN
			TEMP = U%X
			U%X = V%X
			V%X = TEMP
			TEMP = U%Y
			U%Y = V%Y
			V%Y = TEMP
		ENDIF
		M = (U%Y-V%Y) / (U%X-V%X)
		Y = M*(PT%X-V%X)+V%Y
		IF ((PT%X.GE.V%X).AND.(PT%X.LE.U%X).AND.(DABS(Y-PT%Y).LE.TOL)) THEN
			PTLIEON=.TRUE.
		ENDIF
	ENDIF
END FUNCTION PTLIEON

	LOGICAL FUNCTION VALIDATE_INTERSECTION(PATCH1,PATCH2)
		TYPE(RECPATCH),INTENT(IN) :: PATCH1,PATCH2
		REAL(8) :: SX,BX,SY,BY

		SX=MAX(PATCH1%PT1%X,PATCH2%PT1%X)
		BX=MIN(PATCH1%PT2%X,PATCH2%PT2%X)
		SY=MAX(PATCH1%PT1%Y,PATCH2%PT1%Y)
		BY=MIN(PATCH1%PT3%Y,PATCH2%PT3%Y)

		IF (BX-SX.GT.5.0D-15 .AND. BY-SY.GT.5.0D-15) THEN
			VALIDATE_INTERSECTION=.TRUE.
		ELSE
			VALIDATE_INTERSECTION=.FALSE.
		END IF

	END FUNCTION VALIDATE_INTERSECTION

	LOGICAL FUNCTION IS_SAME(PATCH1,PATCH2)
		TYPE(RECPATCH),INTENT(IN) :: PATCH1,PATCH2
		REAL(8) :: DIFFX1,DIFFX2,DIFFY1,DIFFY2

		DIFFX1=(PATCH1%PT1%X-PATCH2%PT1%X)
		DIFFX2=(PATCH1%PT2%X-PATCH2%PT2%X)
		DIFFY1=(PATCH1%PT1%Y-PATCH2%PT1%Y)
		DIFFY2=(PATCH1%PT3%Y-PATCH2%PT3%Y)

		IS_SAME=.FALSE.

		IF ((DIFFX1).LT.5.0D-15.AND.(DIFFX2).LT.5.0D-15.AND.(DIFFY1).LT.5.0D-15.AND.&
		   &(DIFFY2).LT.5.0D-15) THEN
			IS_SAME=.TRUE.
		END IF
	END FUNCTION IS_SAME

	LOGICAL FUNCTION IS_BOUNDARY(PT2D,RECPATCH_TEST)
		TYPE(RECPATCH),INTENT(IN) :: RECPATCH_TEST
		TYPE(POINT2D),INTENT(IN):: PT2D
		REAL(8) :: SX,BX,SY,BY
		REAL(8) :: X,Y

		SX=RECPATCH_TEST%PT1%X
		BX=RECPATCH_TEST%PT2%X
		SY=RECPATCH_TEST%PT1%Y
		BY=RECPATCH_TEST%PT3%Y

		X=PT2D%X
		Y=PT2D%Y

		IS_BOUNDARY=.FALSE.

		IF (((BX-X).LT.5.0D-15 .OR. (X-SX).LT.5.0D-15).AND. &
               (Y.GE.SY.AND.Y.LE.BY)) THEN
			IS_BOUNDARY=.TRUE.
		END IF

		IF (((BY-Y).LT.5.0D-15 .OR. (Y-SY).LT.5.0D-15).AND. &
               (X.GE.SX.AND.X.LE.BX)) THEN
			IS_BOUNDARY=.TRUE.
		END IF

	END FUNCTION IS_BOUNDARY

	CHARACTER (LEN=2) FUNCTION WHICH_BOUNDARY(PT2D,RECPATCH_TEST)
		TYPE(RECPATCH),INTENT(IN) :: RECPATCH_TEST
		TYPE(POINT2D),INTENT(IN):: PT2D
		REAL(8) :: SX,BX,SY,BY
		REAL(8) :: X,Y

		SX=RECPATCH_TEST%PT1%X
		BX=RECPATCH_TEST%PT2%X
		SY=RECPATCH_TEST%PT1%Y
		BY=RECPATCH_TEST%PT3%Y
		
		X=PT2D%X
		Y=PT2D%Y

        ! 'NN' = NONE  'RR' = RIGHT 'LL' = LEFT  'FF' = FORWARD  'KK' = BACKWARD
        ! 'LF' = LEFT/RIGHT  'RF' = RIGHT/FORWARD  'LK' = LEFT/BACKWARD  'RK' = RIGHT/BACKWARD

		WHICH_BOUNDARY='NN'

		IF (((BX-X).LT.5.0D-15).AND. &
               (Y.GE.SY.AND.Y.LE.BY).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='RR'
        ENDIF
        IF (((X-SX).LT.5.0D-15).AND. &
               (Y.GE.SY.AND.Y.LE.BY).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='LL'
		END IF

		IF (((BY-Y).LT.5.0D-15).AND. &
               (X.GE.SX.AND.X.LE.BX).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='KK'
		END IF
		IF (((Y-SY).LT.5.0D-15).AND. &
               (X.GE.SX.AND.X.LE.BX).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='FF'
		END IF
		IF (((X-SX).LT.5.0D-15).AND.((Y-SY).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='LF'
		END IF
		IF (((BX-X).LT.5.0D-15).AND.((Y-SY).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='RF'
		END IF
		IF (((X-SX).LT.5.0D-15).AND.((BY-Y).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='LK'
		END IF
		IF (((BX-X).LT.5.0D-15).AND.((BY-Y).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='RK'
		END IF
	END FUNCTION WHICH_BOUNDARY

SUBROUTINE SPLITRECPATCH(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

    TYPE(RECPATCH), INTENT(OUT) :: SPLITTEDRECPATCHES(9)
    TYPE(RECPATCH), INTENT(IN) :: PATCHRECTANGLE, CENTERRECTANGLE
    INTEGER :: I

    DO I=1,9
        CALL INITIALIZE(SPLITTEDRECPATCHES(I))
    ENDDO

    CALL SPLITRECPATCHX(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)
    CALL SPLITRECPATCHY(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

END SUBROUTINE SPLITRECPATCH

SUBROUTINE SPLITRECPATCHX(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

    TYPE(RECPATCH), INTENT(INOUT) :: SPLITTEDRECPATCHES(9)
    TYPE(RECPATCH), INTENT(IN) :: PATCHRECTANGLE, CENTERRECTANGLE
    REAL*8 :: X(4)
    INTEGER :: I, J

    X(1)=PATCHRECTANGLE%PT1%X
    X(2)=CENTERRECTANGLE%PT1%X
    X(3)=CENTERRECTANGLE%PT2%X
    X(4)=PATCHRECTANGLE%PT2%X

    DO I=1,9
        J=MOD(I,3)
        IF (J.EQ.0) THEN
            J=3
        ENDIF
        SPLITTEDRECPATCHES(I)%PT1%X=X(J)
        SPLITTEDRECPATCHES(I)%PT2%X=X(J+1)
        SPLITTEDRECPATCHES(I)%PT3%X=X(J+1)
        SPLITTEDRECPATCHES(I)%PT4%X=X(J)
    ENDDO

END SUBROUTINE SPLITRECPATCHX

SUBROUTINE SPLITRECPATCHY(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

    TYPE(RECPATCH), INTENT(INOUT) :: SPLITTEDRECPATCHES(9)
    TYPE(RECPATCH), INTENT(IN) :: PATCHRECTANGLE, CENTERRECTANGLE
    REAL*8 :: Y(4)
    INTEGER :: I, J, K

    Y(1)=PATCHRECTANGLE%PT1%Y
    Y(2)=CENTERRECTANGLE%PT1%Y
    Y(3)=CENTERRECTANGLE%PT3%Y
    Y(4)=PATCHRECTANGLE%PT3%Y

    DO I=1,9
        J=1+INT(I/3)
        IF (MOD(I,3).EQ.0) THEN
            J=J-1
        ENDIF
        K=MOD(J,3)
        IF (MOD(J,3).EQ.0) THEN
            K=3
        ENDIF
        SPLITTEDRECPATCHES(I)%PT1%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT2%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT3%Y=Y(K+1)
        SPLITTEDRECPATCHES(I)%PT4%Y=Y(K+1)

        SPLITTEDRECPATCHES(I)%PT1%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT2%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT3%Y=Y(K+1)
        SPLITTEDRECPATCHES(I)%PT4%Y=Y(K+1)
    ENDDO

END SUBROUTINE SPLITRECPATCHY

SUBROUTINE CENTERPTS(PTS, SPLITTEDRECPATCHES)

    TYPE(POINT2D), INTENT(OUT) :: PTS(9)
    TYPE(RECPATCH), INTENT(IN) :: SPLITTEDRECPATCHES(9)
    INTEGER :: I

    DO I=1, 9
        PTS(I)%X=SPLITTEDRECPATCHES(I)%PT1%X + 0.5D0*(SPLITTEDRECPATCHES(I)%PT2%X-SPLITTEDRECPATCHES(I)%PT1%X)
        PTS(I)%Y=SPLITTEDRECPATCHES(I)%PT1%Y + 0.5D0*(SPLITTEDRECPATCHES(I)%PT4%Y-SPLITTEDRECPATCHES(I)%PT1%Y)
    ENDDO

END SUBROUTINE CENTERPTS

SUBROUTINE INITIALIZE(INITIALPATCH)

    TYPE(RECPATCH), INTENT(INOUT) :: INITIALPATCH

    INITIALPATCH%PT1=POINT2D(0.0D0, 0.0D0)
    INITIALPATCH%PT2=POINT2D(0.0D0, 0.0D0)
    INITIALPATCH%PT3=POINT2D(0.0D0, 0.0D0)
    INITIALPATCH%PT4=POINT2D(0.0D0, 0.0D0)


END SUBROUTINE INITIALIZE

TYPE(TRANSFORM2D) FUNCTION MSTREC_TO_PHYREC(PT, MSTREC, PHYREC) ! MAP FROM MSTREC TO PHYREC
	TYPE(RECPATCH), INTENT(IN) :: MSTREC, PHYREC
	TYPE(POINT2D), INTENT(IN) :: PT
	
	REAL*8 :: L(4), DLDX(4), DLDY(4), X(4), Y(4)
	INTEGER :: I, J
	
	L(1) = 0.250D0*(PT%X - 1.0D0)*(PT%Y - 1.0D0)
	L(2) = -0.250D0*(PT%X + 1.0D0)*(PT%Y - 1.0D0)
	L(3) = 0.250D0*(PT%X + 1.0D0)*(PT%Y + 1.0D0)
	L(4) = -0.250D0*(PT%X - 1.0D0)*(PT%Y + 1.0D0)
	
	DLDX(1) = 0.250D0*(PT%Y - 1.0D0)
	DLDX(2) = -0.250D0*(PT%Y - 1.0D0)
	DLDX(3) = 0.250D0*(PT%Y + 1.0D0)
	DLDX(4) = -0.250D0*(PT%Y + 1.0D0)
	
	DLDY(1) = 0.250D0*(PT%X - 1.0D0)
	DLDY(2) = -0.250D0*(PT%X + 1.0D0)
	DLDY(3) = 0.250D0*(PT%X + 1.0D0)
	DLDY(4) = -0.250D0*(PT%X - 1.0D0)
	
	X(1) = PHYREC%PT1%X
	X(2) = PHYREC%PT2%X
	X(3) = PHYREC%PT3%X
	X(4) = PHYREC%PT4%X

	Y(1) = PHYREC%PT1%Y
	Y(2) = PHYREC%PT2%Y
	Y(3) = PHYREC%PT3%Y
	Y(4) = PHYREC%PT4%Y
	
	MSTREC_TO_PHYREC%PT%X = DOT_PRODUCT(X(:),L(:))
	MSTREC_TO_PHYREC%PT%Y = DOT_PRODUCT(Y(:),L(:))
	
	MSTREC_TO_PHYREC%DXDX = DOT_PRODUCT(X(:),DLDX(:))
	MSTREC_TO_PHYREC%DXDY = DOT_PRODUCT(X(:),DLDY(:))
	MSTREC_TO_PHYREC%DYDX = DOT_PRODUCT(Y(:),DLDX(:))
	MSTREC_TO_PHYREC%DYDY = DOT_PRODUCT(Y(:),DLDY(:))
		
	MSTREC_TO_PHYREC%JACOBIAN = MSTREC_TO_PHYREC%DXDX*MSTREC_TO_PHYREC%DYDY - &
								 MSTREC_TO_PHYREC%DXDY*MSTREC_TO_PHYREC%DYDX

END FUNCTION MSTREC_TO_PHYREC

TYPE(TRANSFORM2D) FUNCTION PHYREC_TO_MSTREC(PT, PHYREC, MSTREC) ! MAP FROM PHYREC TO MSTREC BY USING NEWTON'S INTERATIVE METHOD
    TYPE(POINT2D), INTENT(IN) :: PT
    TYPE(RECPATCH), INTENT(IN) :: PHYREC, MSTREC
    INTEGER, PARAMETER :: MAX_ITR = 20
    TYPE(TRANSFORM2D) :: TMP_PT
    TYPE(POINT2D) :: ERR_PT, PREV_PT, NEXT_PT
    INTEGER :: IT
    REAL*8 :: TOL, JACOB(4,4), INV_JACOB(4,4)
    
    TOL = 5.0D-16
    
    PREV_PT = POINT2D(0.50D0,0.50D0)
    
    DO IT=1,MAX_ITR
      TMP_PT = MSTREC_TO_PHYREC(PREV_PT, MSTREC, PHYREC)
      ERR_PT = PT - TMP_PT%PT
      INV_JACOB(1,1) = (1.D0/TMP_PT%JACOBIAN)*TMP_PT%DYDY; INV_JACOB(1,2) = -(1.D0/TMP_PT%JACOBIAN)*TMP_PT%DXDY
      INV_JACOB(2,1) = -(1.D0/TMP_PT%JACOBIAN)*TMP_PT%DYDX; INV_JACOB(2,2) = (1.D0/TMP_PT%JACOBIAN)*TMP_PT%DXDX

      NEXT_PT%X = INV_JACOB(1,1)*ERR_PT%X + INV_JACOB(1,2)*ERR_PT%Y + PREV_PT%X
      NEXT_PT%Y = INV_JACOB(2,1)*ERR_PT%X + INV_JACOB(2,2)*ERR_PT%Y + PREV_PT%Y

      IF ((DABS(ERR_PT%X).LE.TOL).AND.(DABS(ERR_PT%Y).LE.TOL)) THEN

        PHYREC_TO_MSTREC%JACOBIAN = DABS(INV_JACOB(1,1)*INV_JACOB(2,2) - INV_JACOB(1,2)*INV_JACOB(2,1))

        PHYREC_TO_MSTREC%DXDX = INV_JACOB(1,1)
        PHYREC_TO_MSTREC%DXDY = INV_JACOB(1,2)
        PHYREC_TO_MSTREC%DYDX = INV_JACOB(2,1)
        PHYREC_TO_MSTREC%DYDY = INV_JACOB(2,2)
        
        PHYREC_TO_MSTREC%PT = PREV_PT
        
        GOTO 999
      ENDIF
      PREV_PT = NEXT_PT
    ENDDO
    PRINT *, '[###] ITERATION FAILED!'
    999 CONTINUE
	
END FUNCTION PHYREC_TO_MSTREC

END MODULE NEWTYPE

