! FILE WRITTEN BY HYUNJU KIM
!
! DATE : TUE 30 2008

MODULE BOUNDARY

    USE GLBVAR
    USE NEWTYPE
	USE PACKAGE
    USE LOADFUNCTION
    
    IMPLICIT NONE

CONTAINS

SUBROUTINE IMPOSEBD(FAT_K, K, F)
	
    REAL*8, INTENT(OUT) :: FAT_K(3*DOF,3*DOF)
	TYPE(SUBMAT), INTENT(IN) :: K
    REAL*8, INTENT(INOUT) :: F(3*DOF)
    TYPE(POINT2D) :: NODES(DOF)
    CHARACTER (LEN=2) :: EDGE(DOF)
    INTEGER :: I, J, II, JJ, KK, BD_FLAG
    INTEGER, ALLOCATABLE :: INDICE(:)
    LOGICAL, ALLOCATABLE :: BD_MASK(:)

     PRINT *,
     PRINT *, 'IMPOSING BOUNDARY CONDITION'

	ALLOCATE(BD_MASK(3*DOF))

    NODES=NODE_ALL(NUMPATCHES)

    FAT_K(:,:) = 0.0D0

	WHERE (DABS(F(:)) .LE. EPS) F(:) = 0.0D0
	
	DO I=1, DOF
		EDGE(I) = WHICH_BOUNDARY(NODES(I),OMEGA)
	ENDDO

!	OPEN(1, FILE='edge_node.dat')
!	DO I=1, DOF
!		WRITE(1,*) EDGE(I)
!	ENDDO
!	CLOSE(1)

	BD_MASK(:) = .FALSE.

    !-------------------!
    BD_FLAG = PROBLEM   !<---------- SWITCH TO CONTROL THE BOUNDARY CONDITION
    !-------------------!
    
    IF (BCTYPE.EQ.'SSSS') THEN
		!!!!!!!!!! HARD TYPE SIMPLE SUPPORT !!!!!!!!!!

		!---- W0 = 0 ON EVERY BOUNDARIES -----		
		WHERE (EDGE.NE.'NN')
			F(1:DOF) = 0.0D0
			BD_MASK(1:DOF) = .TRUE.
		END WHERE
		!---- PI_X = 0 ON GAMMA 1 AND 3 -----		
		WHERE (EDGE.EQ.'FF' .OR. EDGE.EQ.'KK' .OR. & 
			   EDGE.EQ.'LF' .OR. EDGE.EQ.'RF' .OR. EDGE.EQ.'LK' .OR. EDGE.EQ.'RK')
			F(DOF+1:2*DOF) = 0.0D0
			BD_MASK(DOF+1:2*DOF) = .TRUE.
		END WHERE
		!---- PI_Y = 0 ON GAMMA 2 AND 4 -----				
		WHERE (EDGE.EQ.'RR' .OR. EDGE.EQ.'LL' .OR. & 
			   EDGE.EQ.'LF' .OR. EDGE.EQ.'RF' .OR. EDGE.EQ.'LK' .OR. EDGE.EQ.'RK')
			F(2*DOF+1:3*DOF) = 0.0D0
			BD_MASK(2*DOF+1:3*DOF) = .TRUE.
		END WHERE
	ELSEIF (BCTYPE.EQ.'CCCC') THEN
		!!!!!!!!!! CLAMPED EDGE !!!!!!!!!!

		!---- W0 = 0, PIX = 0, PIY = 0 ON EVERY BOUNDARIES -----		
		WHERE (EDGE.NE.'NN')
			F(1:DOF) = 0.0D0
			F(DOF+1:2*DOF) = 0.0D0
			F(2*DOF+1:3*DOF) = 0.0D0
			BD_MASK(1:DOF) = .TRUE.
			BD_MASK(DOF+1:2*DOF) = .TRUE.
			BD_MASK(2*DOF+1:3*DOF) = .TRUE.
		END WHERE
	ELSEIF (BCTYPE.EQ.'SCSC') THEN
		!!!!!!!!!! HARD TYPE SIMPLY SUPPORTED AND CLAMPED EDGE ALONG OPPOSITE TWO SIDES FOR EACH !!!!!!!!!!
		!---- W0 = 0, PIX = 0 ON EVERY BOUNDARIES -----		
		WHERE (EDGE.NE.'NN')
			F(1:DOF) = 0.0D0
			F(DOF+1:2*DOF) = 0.0D0
			BD_MASK(1:DOF) = .TRUE.
			BD_MASK(DOF+1:2*DOF) = .TRUE.
		END WHERE
		!----- PIY = 0 ON ON GAMMA 2 AND 4 -----
		WHERE (EDGE.EQ.'RR' .OR. EDGE.EQ.'LL' .OR. & 
			   EDGE.EQ.'LF' .OR. EDGE.EQ.'RF' .OR. EDGE.EQ.'LK' .OR. EDGE.EQ.'RK')
			F(2*DOF+1:3*DOF) = 0.0D0
			BD_MASK(2*DOF+1:3*DOF) = .TRUE.
		END WHERE
	ENDIF

	!----- CONSTRUCT FULL MATRIX CALLED FAT_K [K] -----
	FORALL (I=1:K%NZ(1))
		FAT_K(K%R11(I), K%C11(I)) = K%K11(I)
		FAT_K(K%C11(I), K%R11(I)) = K%K11(I)
	END FORALL

	FORALL (I=1:K%NZ(2))
		FAT_K(DOF+K%R22(I), DOF+K%C22(I)) = K%K22(I)
		FAT_K(DOF+K%C22(I), DOF+K%R22(I)) = K%K22(I)
	END FORALL

	FORALL (I=1:K%NZ(3))
		FAT_K(2*DOF+K%R33(I), 2*DOF+K%C33(I)) = K%K33(I)
		FAT_K(2*DOF+K%C33(I), 2*DOF+K%R33(I)) = K%K33(I)
	END FORALL

	FORALL (I=1:K%NZ(4))
		FAT_K(K%R12(I), DOF+K%C12(I)) = K%K12(I)
		FAT_K(DOF+K%C12(I), K%R12(I)) = K%K12(I)
	END FORALL

	FORALL (I=1:K%NZ(5))
		FAT_K(K%R13(I), 2*DOF+K%C13(I)) = K%K13(I)
		FAT_K(2*DOF+K%C13(I), K%R13(I)) = K%K13(I)
	END FORALL

	FORALL (I=1:K%NZ(6))
		FAT_K(DOF+K%R23(I), 2*DOF+K%C23(I)) = K%K23(I)
		FAT_K(2*DOF+K%C23(I), DOF+K%R23(I)) = K%K23(I)
	END FORALL

	ALLOCATE(INDICE(COUNT(BD_MASK)))

	KK = 0

	DO I=1, 3*DOF
		WHERE (BD_MASK(:).EQV..TRUE.)
			FAT_K(I,:) = 0.0D0
			FAT_K(:,I) = 0.0D0
		END WHERE
		IF (BD_MASK(I).EQV..TRUE.) THEN
			KK = KK+1
			INDICE(KK) = I
		ENDIF
	ENDDO	
	
	FORALL (I=1:COUNT(BD_MASK)) FAT_K(INDICE(I), INDICE(I)) = 1.0D0
	
!	OPEN(1, FILE = 'fat_k.dat')
!	OPEN(2, FILE = 'load_vec.dat')
!	DO I=1, 3*DOF
!		WRITE(1,*) (FAT_K(I,J), J=1,3*DOF)
!		WRITE(2,*) F(I)
!	ENDDO
!	CLOSE(1)
!	CLOSE(2)
		
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	DEALLOCATE(BD_MASK, INDICE)
	
END SUBROUTINE IMPOSEBD

END MODULE BOUNDARY
