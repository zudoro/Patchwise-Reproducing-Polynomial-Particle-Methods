MODULE EISPACK

CONTAINS

SUBROUTINE BAKVEC ( N, T, E, M, Z, IERR )

!*****************************************************************************80
!
!! BAKVEC DETERMINES EIGENVECTORS BY REVERSING THE FIGI TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A NONSYMMETRIC TRIDIAGONAL
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING SYMMETRIC
!    MATRIX DETERMINED BY FIGI.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) T(N,3), CONTAINS THE NONSYMMETRIC MATRIX.  ITS
!    SUBDIAGONAL IS STORED IN THE POSITIONS 2:N OF THE FIRST COLUMN,
!    ITS DIAGONAL IN POSITIONS 1:N OF THE SECOND COLUMN,
!    AND ITS SUPERDIAGONAL IN POSITIONS 1:N-1 OF THE THIRD COLUMN.
!    T(1,1) AND T(N,3) ARE ARBITRARY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E(N).  ON INPUT, E(2:N) CONTAINS THE
!    SUBDIAGONAL ELEMENTS OF THE SYMMETRIC MATRIX.  E(1) IS ARBITRARY.
!    ON OUTPUT, THE CONTENTS OF E HAVE BEEN DESTROYED.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M), CONTAINS THE EIGENVECTORS.
!    ON OUTPUT, THEY HAVE BEEN TRANSFORMED AS REQUESTED.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, AN ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    2*N+I, IF E(I) IS ZERO WITH T(I,1) OR T(I-1,3) NON-ZERO.
!    IN THIS CASE, THE SYMMETRIC MATRIX IS NOT SIMILAR
!    TO THE ORIGINAL MATRIX, AND THE EIGENVECTORS
!    CANNOT BE FOUND BY THIS PROGRAM.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) E(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) J
  REAL    ( KIND = 8 ) T(N,3)
  REAL    ( KIND = 8 ) Z(N,M)

  IERR = 0

  IF ( M == 0 ) THEN
    RETURN
  END IF

  E(1) = 1.0D+00
  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    IF ( E(I) == 0.0D+00 ) THEN
      IF ( T(I,1) /= 0.0D+00 .OR. T(I-1,3) /= 0.0D+00 ) THEN
        IERR = 2 * N + I
        RETURN
      END IF
      E(I) = 1.0D+00
    ELSE
      E(I) = E(I-1) * E(I) / T(I-1,3)
    END IF
  END DO

  DO J = 1, M
    Z(2:N,J) = Z(2:N,J) * E(2:N)
  END DO

  RETURN
END
SUBROUTINE BALANC ( N, A, LOW, IGH, SCALE )

!*****************************************************************************80
!
!! BALANC BALANCES A REAL MATRIX BEFORE EIGENVALUE CALCULATIONS.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE BALANCES A REAL MATRIX AND ISOLATES EIGENVALUES
!    WHENEVER POSSIBLE.
!
!    SUPPOSE THAT THE PRINCIPAL SUBMATRIX IN ROWS LOW THROUGH IGH
!    HAS BEEN BALANCED, THAT P(J) DENOTES THE INDEX INTERCHANGED
!    WITH J DURING THE PERMUTATION STEP, AND THAT THE ELEMENTS
!    OF THE DIAGONAL MATRIX USED ARE DENOTED BY D(I,J).  THEN
!
!      SCALE(J) = P(J),    J = 1,...,LOW-1,
!               = D(J,J),  J = LOW,...,IGH,
!               = P(J)     J = IGH+1,...,N.
!
!    THE ORDER IN WHICH THE INTERCHANGES ARE MADE IS N TO IGH+1,
!    THEN 1 TO LOW-1.
!
!    NOTE THAT 1 IS RETURNED FOR LOW IF IGH IS ZERO FORMALLY.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N), THE N BY N MATRIX.  ON OUTPUT,
!    THE MATRIX HAS BEEN BALANCED.
!
!    OUTPUT, INTEGER ( KIND = 4 ) LOW, IGH, INDICATE THAT A(I,J) IS EQUAL TO
!    ZERO IF
!    (1) I IS GREATER THAN J AND
!    (2) J=1,...,LOW-1 OR I=IGH+1,...,N.
!
!    OUTPUT, REAL ( KIND = 8 ) SCALE(N), CONTAINS INFORMATION DETERMINING THE
!    PERMUTATIONS AND SCALING FACTORS USED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B2
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IEXC
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  LOGICAL              NOCONV
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RADIX
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE(N)

  RADIX = 16.0D+00

  IEXC = 0
  J = 0
  M = 0

  B2 = RADIX**2
  K = 1
  L = N
  GO TO 100

20 CONTINUE

  SCALE(M) = J

  IF ( J /= M ) THEN

    DO I = 1, L
      CALL R8_SWAP ( A(I,J), A(I,M) )
    END DO

    DO I = K, N
      CALL R8_SWAP ( A(J,I), A(M,I) )
    END DO

  END IF

50 CONTINUE

  IF ( IEXC == 2 ) THEN
    GO TO 130
  END IF
!
!  SEARCH FOR ROWS ISOLATING AN EIGENVALUE AND PUSH THEM DOWN.
!
80 CONTINUE

  IF ( L == 1 ) THEN
    LOW = K
    IGH = L
    RETURN
  END IF

  L = L - 1

100 CONTINUE

  DO J = L, 1, -1

     DO I = 1, L
       IF ( I /= J ) THEN
         IF ( A(J,I) /= 0.0D+00 ) THEN
           GO TO 120
         END IF
       END IF
     END DO

     M = L
     IEXC = 1
     GO TO 20

120  CONTINUE

  END DO

  GO TO 140
!
!  SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE AND PUSH THEM LEFT.
!
130 CONTINUE

  K = K + 1

140 CONTINUE

  DO J = K, L

    DO I = K, L
      IF ( I /= J ) THEN
        IF ( A(I,J) /= 0.0D+00 ) THEN
          GO TO 170
        END IF
      END IF
    END DO

    M = K
    IEXC = 2
    GO TO 20

170 CONTINUE

  END DO
!
!  BALANCE THE SUBMATRIX IN ROWS K TO L.
!
  SCALE(K:L) = 1.0D+00
!
!  ITERATIVE LOOP FOR NORM REDUCTION.
!
  NOCONV = .TRUE.

  DO WHILE ( NOCONV )

    NOCONV = .FALSE.

    DO I = K, L

      C = 0.0D+00
      R = 0.0D+00

      DO J = K, L
        IF ( J /= I ) THEN
          C = C + ABS ( A(J,I) )
          R = R + ABS ( A(I,J) )
        END IF
      END DO
!
!  GUARD AGAINST ZERO C OR R DUE TO UNDERFLOW.
!
      IF ( C /= 0.0D+00 .AND. R /= 0.0D+00 ) THEN

        G = R / RADIX
        F = 1.0D+00
        S = C + R

        DO WHILE ( C < G )
          F = F * RADIX
          C = C * B2
        END DO

        G = R * RADIX

        DO WHILE ( G <= C )
          F = F / RADIX
          C = C / B2
        END DO
!
!  BALANCE.
!
        IF ( ( C + R ) / F < 0.95D+00 * S ) THEN

          G = 1.0D+00 / F
          SCALE(I) = SCALE(I) * F
          NOCONV = .TRUE.

          A(I,K:N) = A(I,K:N) * G
          A(1:L,I) = A(1:L,I) * F

        END IF

      END IF

    END DO

  END DO

  LOW = K
  IGH = L

  RETURN
END
SUBROUTINE BALBAK ( N, LOW, IGH, SCALE, M, Z )

!*****************************************************************************80
!
!! BALBAK DETERMINES EIGENVECTORS BY UNDOING THE BALANC TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A REAL GENERAL MATRIX BY
!    BACK TRANSFORMING THOSE OF THE CORRESPONDING BALANCED MATRIX
!    DETERMINED BY BALANC.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    PARLETT AND REINSCH,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 13, PAGES 293-304, 1969.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, COLUMN INDICES DETERMINED BY BALANC.
!
!    INPUT, REAL ( KIND = 8 ) SCALE(N), CONTAINS INFORMATION DETERMINING
!    THE PERMUTATIONS AND SCALING FACTORS USED BY BALANC.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF COLUMNS OF Z TO BE
!    BACK-TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M), CONTAINS THE REAL AND IMAGINARY PARTS
!    OF THE EIGENVECTORS, WHICH, ON RETURN, HAVE BEEN BACK-TRANSFORMED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) LOW
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE(N)
  REAL    ( KIND = 8 ) Z(N,M)

  IF ( M <= 0 ) THEN
    RETURN
  END IF

  IF ( IGH /= LOW ) THEN
    DO I = LOW, IGH
      Z(I,1:M) = Z(I,1:M) * SCALE(I)
    END DO
  END IF

   DO II = 1, N

     I = II

     IF ( I < LOW .OR. IGH < I ) THEN

       IF ( I < LOW ) THEN
         I = LOW - II
       END IF

       K = INT ( SCALE(I) )

       IF ( K /= I ) THEN

         DO J = 1, M
           CALL R8_SWAP ( Z(I,J), Z(K,J) )
         END DO

        END IF

      END IF

  END DO

  RETURN
END
SUBROUTINE BANDR ( N, MB, A, D, E, E2, MATZ, Z )

!*****************************************************************************80
!
!! BANDR REDUCES A SYMMETRIC BAND MATRIX TO SYMMETRIC TRIDIAGONAL FORM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES A REAL SYMMETRIC BAND MATRIX
!    TO A SYMMETRIC TRIDIAGONAL MATRIX USING AND OPTIONALLY
!    ACCUMULATING ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MB, IS THE (HALF) BAND WIDTH OF THE MATRIX,
!    DEFINED AS THE NUMBER OF ADJACENT DIAGONALS, INCLUDING THE PRINCIPAL
!    DIAGONAL, REQUIRED TO SPECIFY THE NON-ZERO PORTION OF THE
!    LOWER TRIANGLE OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,MB).  ON INPUT, CONTAINS THE LOWER
!    TRIANGLE OF THE SYMMETRIC BAND INPUT MATRIX STORED AS AN N BY MB ARRAY.
!    ITS LOWEST SUBDIAGONAL IS STORED IN THE LAST N+1-MB POSITIONS OF THE FIRST
!    COLUMN, ITS NEXT SUBDIAGONAL IN THE LAST N+2-MB POSITIONS OF THE SECOND
!    COLUMN, FURTHER SUBDIAGONALS SIMILARLY, AND FINALLY ITS PRINCIPAL DIAGONAL
!    IN THE N POSITIONS OF THE LAST COLUMN.  CONTENTS OF STORAGES NOT PART OF
!    THE MATRIX ARE ARBITRARY.  ON OUTPUT, A HAS BEEN DESTROYED, EXCEPT FOR
!    ITS LAST TWO COLUMNS WHICH CONTAIN A COPY OF THE TRIDIAGONAL MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX IN E(2:N).  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N), CONTAINS THE SQUARES OF THE CORRESPONDING
!    ELEMENTS OF E.  E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
!    INPUT, LOGICAL MATZ, SHOULD BE SET TO TRUE IF THE TRANSFORMATION MATRIX IS
!    TO BE ACCUMULATED, AND TO FALSE OTHERWISE.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), THE ORTHOGONAL TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION IF MATZ HAS BEEN SET TO TRUE.  OTHERWISE, Z IS
!    NOT REFERENCED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MB
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,MB)
  REAL    ( KIND = 8 ) B1
  REAL    ( KIND = 8 ) B2
  REAL    ( KIND = 8 ) C2
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) DMIN
  REAL    ( KIND = 8 ) DMINRT
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F1
  REAL    ( KIND = 8 ) F2
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) I1
  INTEGER ( KIND = 4 ) I2
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) J1
  INTEGER ( KIND = 4 ) J2
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) KR
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) M1
  LOGICAL              MATZ
  INTEGER ( KIND = 4 ) MAXL
  INTEGER ( KIND = 4 ) MAXR
  INTEGER ( KIND = 4 ) MR
  INTEGER ( KIND = 4 ) R
  INTEGER ( KIND = 4 ) R1
  REAL    ( KIND = 8 ) S2
  REAL    ( KIND = 8 ) U
  INTEGER ( KIND = 4 ) UGL
  REAL    ( KIND = 8 ) Z(N,N)

  DMIN = EPSILON ( DMIN )
  DMINRT = SQRT ( DMIN )
!
!  INITIALIZE THE DIAGONAL SCALING MATRIX.
!
  D(1:N) = 1.0D+00

  IF ( MATZ ) THEN

    Z(1:N,1:N) = 0.0D+00

    DO I = 1, N
      Z(I,I) = 1.0D+00
    END DO

  END IF

  M1 = MB - 1

  IF ( M1 < 1 ) THEN
    D(1:N) = A(1:N,MB)
    E(1:N) = 0.0D+00
    E2(1:N) = 0.0D+00
    RETURN
  END IF

  IF ( M1 == 1 ) THEN
    GO TO 800
  END IF

  DO K = 1, N - 2

    MAXR = MIN ( M1, N-K )

    DO R1 = 2, MAXR

      R = MAXR + 2 - R1
      KR = K + R
      MR = MB - R
      G = A(KR,MR)
      A(KR-1,1) = A(KR-1,MR+1)
      UGL = K

      DO J = KR, N, M1

        J1 = J - 1
        J2 = J1 - 1

        IF ( G == 0.0D+00 ) THEN
          GO TO 600
        END IF

        B1 = A(J1,1) / G
        B2 = B1 * D(J1) / D(J)
        S2 = 1.0D+00 / ( 1.0D+00 + B1 * B2 )

        IF ( S2 < 0.5D+00 ) THEN

          B1 = G / A(J1,1)
          B2 = B1 * D(J) / D(J1)
          C2 = 1.0D+00 - S2
          D(J1) = C2 * D(J1)
          D(J) = C2 * D(J)
          F1 = 2.0D+00 * A(J,M1)
          F2 = B1 * A(J1,MB)
          A(J,M1) = -B2 * ( B1 * A(J,M1) - A(J,MB) ) - F2 + A(J,M1)
          A(J1,MB) = B2 * ( B2 * A(J,MB) + F1 ) + A(J1,MB)
          A(J,MB) = B1 * ( F2 - F1 ) + A(J,MB)

          DO L = UGL, J2
            I2 = MB - J + L
            U = A(J1,I2+1) + B2 * A(J,I2)
            A(J,I2) = -B1 * A(J1,I2+1) + A(J,I2)
            A(J1,I2+1) = U
          END DO

          UGL = J
          A(J1,1) = A(J1,1) + B2 * G

          IF ( J /= N ) THEN

            MAXL = MIN ( M1, N-J1 )

            DO L = 2, MAXL
              I1 = J1 + L
              I2 = MB - L
              U = A(I1,I2) + B2 * A(I1,I2+1)
              A(I1,I2+1) = -B1 * A(I1,I2) + A(I1,I2+1)
              A(I1,I2) = U
            END DO

            I1 = J + M1

            IF ( I1 <= N ) THEN
              G = B2 * A(I1,1)
            END IF

          END IF

          IF ( MATZ ) THEN

            DO L = 1, N
              U = Z(L,J1) + B2 * Z(L,J)
              Z(L,J) = -B1 * Z(L,J1) + Z(L,J)
              Z(L,J1) = U
            END DO

          END IF

        ELSE

          U = D(J1)
          D(J1) = S2 * D(J)
          D(J) = S2 * U
          F1 = 2.0D+00 * A(J,M1)
          F2 = B1 * A(J,MB)
          U = B1 * ( F2 - F1 ) + A(J1,MB)
          A(J,M1) = B2 * ( B1 * A(J,M1) - A(J1,MB) ) + F2 - A(J,M1)
          A(J1,MB) = B2 * ( B2 * A(J1,MB) + F1 ) + A(J,MB)
          A(J,MB) = U

          DO L = UGL, J2
            I2 = MB - J + L
            U = B2 * A(J1,I2+1) + A(J,I2)
            A(J,I2) = -A(J1,I2+1) + B1 * A(J,I2)
            A(J1,I2+1) = U
          END DO

          UGL = J
          A(J1,1) = B2 * A(J1,1) + G

          IF ( J /= N ) THEN

            MAXL = MIN ( M1, N-J1 )

            DO L = 2, MAXL
              I1 = J1 + L
              I2 = MB - L
              U = B2 * A(I1,I2) + A(I1,I2+1)
              A(I1,I2+1) = -A(I1,I2) + B1 * A(I1,I2+1)
              A(I1,I2) = U
            END DO

            I1 = J + M1

            IF ( I1 <= N ) THEN
              G = A(I1,1)
              A(I1,1) = B1 * A(I1,1)
            END IF

          END IF

          IF ( MATZ ) THEN

            DO L = 1, N
              U = B2 * Z(L,J1) + Z(L,J)
              Z(L,J) = -Z(L,J1) + B1 * Z(L,J)
              Z(L,J1) = U
            END DO

          END IF

        END IF

      END DO

600   CONTINUE

    END DO
!
!  RESCALE TO AVOID UNDERFLOW OR OVERFLOW.
!
    IF ( MOD ( K, 64 ) == 0 ) THEN

      DO J = K, N

        IF ( D(J) < DMIN ) THEN

          MAXL = MAX ( 1, MB+1-J )

          A(J,MAXL:M1) = DMINRT * A(J,MAXL:M1)

          IF ( J /= N ) THEN

            MAXL = MIN ( M1, N-J )

            DO L = 1, MAXL
              I1 = J + L
              I2 = MB - L
              A(I1,I2) = DMINRT * A(I1,I2)
            END DO

          END IF

          IF ( MATZ ) THEN
            Z(1:N,J) = DMINRT * Z(1:N,J)
          END IF

          A(J,MB) = DMIN * A(J,MB)
          D(J) = D(J) / DMIN

        END IF

      END DO

    END IF

  END DO
!
!   FORM SQUARE ROOT OF SCALING MATRIX.
!
800 CONTINUE

  E(2:N) = SQRT ( D(2:N) )

  IF ( MATZ ) THEN

    DO K = 2, N
      Z(1:N,K) = Z(1:N,K) * E(K)
    END DO

  END IF

  U = 1.0D+00

  DO J = 2, N
    A(J,M1) = U * E(J) * A(J,M1)
    U = E(J)
    E2(J) = A(J,M1)**2
    A(J,MB) = D(J) * A(J,MB)
    D(J) = A(J,MB)
    E(J) = A(J,M1)
  END DO

  D(1) = A(1,MB)
  E(1) = 0.0D+00
  E2(1) = 0.0D+00

  RETURN
END
SUBROUTINE BANDV ( N, MBW, A, E21, M, W, Z, IERR )

!*****************************************************************************80
!
!! BANDV FINDS EIGENVECTORS FROM EIGENVALUES, FOR A REAL SYMMETRIC BAND MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVECTORS OF A REAL SYMMETRIC
!    BAND MATRIX CORRESPONDING TO SPECIFIED EIGENVALUES, USING INVERSE
!    ITERATION.  THE SUBROUTINE MAY ALSO BE USED TO SOLVE SYSTEMS
!    OF LINEAR EQUATIONS WITH A SYMMETRIC OR NON-SYMMETRIC BAND
!    COEFFICIENT MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MBW, THE NUMBER OF COLUMNS OF THE ARRAY A USED
!    TO STORE THE BAND MATRIX.  IF THE MATRIX IS SYMMETRIC, MBW IS ITS (HALF)
!    BAND WIDTH, DENOTED MB AND DEFINED AS THE NUMBER OF ADJACENT
!    DIAGONALS, INCLUDING THE PRINCIPAL DIAGONAL, REQUIRED TO
!    SPECIFY THE NON-ZERO PORTION OF THE LOWER TRIANGLE OF THE
!    MATRIX.  IF THE SUBROUTINE IS BEING USED TO SOLVE SYSTEMS
!    OF LINEAR EQUATIONS AND THE COEFFICIENT MATRIX IS NOT
!    SYMMETRIC, IT MUST HOWEVER HAVE THE SAME NUMBER OF ADJACENT
!    DIAGONALS ABOVE THE MAIN DIAGONAL AS BELOW, AND IN THIS
!    CASE, MBW=2*MB-1.
!
!    INPUT, REAL ( KIND = 8 ) A(N,MBW), THE LOWER TRIANGLE OF THE SYMMETRIC
!    BAND INPUT MATRIX STORED AS AN N BY MB ARRAY.  ITS LOWEST SUBDIAGONAL IS
!    STORED IN THE LAST N+1-MB POSITIONS OF THE FIRST COLUMN, ITS NEXT
!    SUBDIAGONAL IN THE LAST N+2-MB POSITIONS OF THE SECOND COLUMN, FURTHER
!    SUBDIAGONALS SIMILARLY, AND FINALLY ITS PRINCIPAL DIAGONAL IN THE N
!    POSITIONS OF COLUMN MB.  IF THE SUBROUTINE IS BEING USED TO SOLVE SYSTEMS
!    OF LINEAR EQUATIONS, AND THE COEFFICIENT MATRIX IS NOT SYMMETRIC, A IS
!    N BY 2*MB-1 INSTEAD, WITH LOWER TRIANGLE AS ABOVE AND WITH ITS FIRST
!    SUPERDIAGONAL STORED IN THE FIRST N-1 POSITIONS OF COLUMN MB+1, ITS
!    SECOND SUPERDIAGONAL IN THE FIRST N-2 POSITIONS OF COLUMN MB+2, FURTHER
!    SUPERDIAGONALS SIMILARLY, AND FINALLY ITS HIGHEST SUPERDIAGONAL IN
!    THE FIRST N+1-MB POSITIONS OF THE LAST COLUMN.  CONTENTS OF STORAGES
!    NOT PART OF THE MATRIX ARE ARBITRARY.
!
!    INPUT, REAL ( KIND = 8 ) E21, SPECIFIES THE ORDERING OF THE EIGENVALUES
!    AND CONTAINS 0.0 IF THE EIGENVALUES ARE IN ASCENDING ORDER, OR 2.0 IF
!    THE EIGENVALUES ARE IN DESCENDING ORDER.  IF THE SUBROUTINE IS BEING USED
!    TO SOLVE SYSTEMS OF LINEAR EQUATIONS, E21 SHOULD BE SET TO 1.0
!    IF THE COEFFICIENT MATRIX IS SYMMETRIC AND TO -1.0 IF NOT.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF SPECIFIED EIGENVALUES OR THE
!    NUMBER OF SYSTEMS OF LINEAR EQUATIONS.
!
!    INPUT, REAL ( KIND = 8 ) W(M), CONTAINS THE M EIGENVALUES IN ASCENDING OR
!    DESCENDING ORDER.  IF THE SUBROUTINE IS BEING USED TO SOLVE SYSTEMS OF
!    LINEAR EQUATIONS (A-W(1:M)*I) * X(1:M) = B(1:M), WHERE I IS THE IDENTITY
!    MATRIX, W SHOULD BE SET ACCORDINGLY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE CONSTANT MATRIX
!    COLUMNS B(1:M), IF THE SUBROUTINE IS USED TO SOLVE SYSTEMS OF LINEAR
!    EQUATIONS.  ON OUTPUT, THE ASSOCIATED SET OF ORTHOGONAL EIGENVECTORS.
!    ANY VECTOR WHICH FAILS TO CONVERGE IS SET TO ZERO.  IF THE
!    ROUTINE IS USED TO SOLVE SYSTEMS OF LINEAR EQUATIONS,
!    Z CONTAINS THE SOLUTION MATRIX COLUMNS X(1:M).
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    -R, IF THE EIGENVECTOR CORRESPONDING TO THE R-TH EIGENVALUE FAILS TO
!    CONVERGE, OR IF THE R-TH SYSTEM OF LINEAR EQUATIONS IS NEARLY SINGULAR.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MBW
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,MBW)
  REAL    ( KIND = 8 ) E21
  REAL    ( KIND = 8 ) EPS2
  REAL    ( KIND = 8 ) EPS3
  REAL    ( KIND = 8 ) EPS4
  INTEGER ( KIND = 4 ) GROUP
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IJ
  INTEGER ( KIND = 4 ) IJ1
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) KJ
  INTEGER ( KIND = 4 ) KJ1
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) M1
  INTEGER ( KIND = 4 ) M21
  INTEGER ( KIND = 4 ) MAXJ
  INTEGER ( KIND = 4 ) MAXK
  INTEGER ( KIND = 4 ) MB
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) ORDER
  REAL    ( KIND = 8 ) PYTHAG
  INTEGER ( KIND = 4 ) R
  REAL    ( KIND = 8 ) RV(N*(2*MBW-1))
  REAL    ( KIND = 8 ) RV6(N)
  REAL    ( KIND = 8 ) U
  REAL    ( KIND = 8 ) UK
  REAL    ( KIND = 8 ) V
  REAL    ( KIND = 8 ) W(M)
  REAL    ( KIND = 8 ) X0
  REAL    ( KIND = 8 ) X1
  REAL    ( KIND = 8 ) XU
  REAL    ( KIND = 8 ) Z(N,M)

  IERR = 0

  IF ( M == 0 ) THEN
    RETURN
  END IF

  X0 = 0.0D+00

  IF ( E21 < 0.0D+00 ) THEN
    MB = ( MBW + 1 ) / 2
  ELSE
    MB = MBW
  END IF

  M1 = MB - 1
  M21 = M1 + MB
  ORDER = 1.0D+00 - ABS ( E21 )
!
!  FIND VECTORS BY INVERSE ITERATION.
!
  DO R = 1, M

     ITS = 1
     X1 = W(R)
     IF ( R /= 1 ) GO TO 100
!
!  COMPUTE NORM OF MATRIX.
!
     NORM = 0.0D+00

     DO J = 1, MB

        JJ = MB + 1 - J
        KJ = JJ + M1
        IJ = 1
        V = 0.0D+00

        DO I = JJ, N

          V = V + ABS ( A(I,J) )

          IF ( E21 < 0.0D+00 ) THEN
            V = V + ABS ( A(IJ,KJ) )
            IJ = IJ + 1
          END IF

        END DO

        NORM = MAX ( NORM, V )

     END DO

     IF ( E21 < 0.0D+00 ) THEN
       NORM = 0.5D+00 * NORM
     END IF
!
!  EPS2 IS THE CRITERION FOR GROUPING,
!  EPS3 REPLACES ZERO PIVOTS AND EQUAL ROOTS ARE MODIFIED BY EPS3,
!  EPS4 IS TAKEN VERY SMALL TO AVOID OVERFLOW.
!
     IF ( NORM == 0.0D+00 ) THEN
       NORM = 1.0D+00
     END IF

     EPS2 = 0.001D+00 * NORM * ABS ( ORDER)
     EPS3 = ABS ( NORM ) * EPSILON ( NORM )
     UK = N
     UK = SQRT ( UK )
     EPS4 = UK * EPS3

80   CONTINUE

     GROUP = 0
     GO TO 120
!
!  LOOK FOR CLOSE OR COINCIDENT ROOTS.
!
100  CONTINUE

     IF ( EPS2 <= ABS ( X1 - X0 ) ) THEN
       GO TO 80
     END IF

     GROUP = GROUP + 1

     IF ( ORDER * ( X1 - X0 ) <= 0.0D+00 ) THEN
       X1 = X0 + ORDER * EPS3
     END IF
!
!  EXPAND MATRIX, SUBTRACT EIGENVALUE, AND INITIALIZE VECTOR.
!
120  CONTINUE

     DO I = 1, N

        IJ = I + MIN ( 0, I-M1 ) * N
        KJ = IJ + MB * N
        IJ1 = KJ + M1 * N

        IF ( M1 == 0 ) GO TO 180

        DO J = 1, M1

          IF ( IJ <= M1 ) THEN
            IF ( IJ <= 0 ) THEN
              RV(IJ1) = 0.0D+00
              IJ1 = IJ1 + N
            END IF
          ELSE
            RV(IJ) = A(I,J)
          END IF

          IJ = IJ + N
          II = I + J

          IF ( II <= N ) THEN

            JJ = MB - J

            IF ( E21 < 0.0D+00 ) THEN
              II = I
              JJ = MB + J
            END IF

            RV(KJ) = A(II,JJ)
            KJ = KJ + N

          END IF

        END DO

  180   CONTINUE

        RV(IJ) = A(I,MB) - X1
        RV6(I) = EPS4
        IF ( ORDER == 0.0D+00 ) THEN
          RV6(I) = Z(I,R)
        END IF

     END DO

     IF ( M1 /= 0 ) THEN
!
!  ELIMINATION WITH INTERCHANGES.
!
     DO I = 1, N

        II = I + 1
        MAXK = MIN ( I+M1-1, N )
        MAXJ = MIN ( N-I, M21-2 ) * N

        DO K = I, MAXK

           KJ1 = K
           J = KJ1 + N
           JJ = J + MAXJ

           DO KJ = J, JJ, N
             RV(KJ1) = RV(KJ)
             KJ1 = KJ
           END DO

           RV(KJ1) = 0.0D+00

        END DO

        IF ( I /= N ) THEN

        U = 0.0D+00
        MAXK = MIN ( I+M1, N )
        MAXJ = MIN ( N-II, M21-2 ) * N

        DO J = I, MAXK
          IF ( ABS ( U ) <= ABS ( RV(J) ) ) THEN
            U = RV(J)
            K = J
          END IF
        END DO

        J = I + N
        JJ = J + MAXJ

        IF ( K /= I ) THEN

          KJ = K

          DO IJ = I, JJ, N
            CALL R8_SWAP ( RV(IJ), RV(KJ) )
            KJ = KJ + N
          END DO

          IF ( ORDER == 0.0D+00 ) THEN
            CALL R8_SWAP ( RV6(I), RV6(K) )
          END IF

        END IF

        IF ( U /= 0.0D+00 ) THEN

        DO K = II, MAXK

           V = RV(K) / U
           KJ = K

           DO IJ = J, JJ, N
             KJ = KJ + N
             RV(KJ) = RV(KJ) - V * RV(IJ)
           END DO

           IF ( ORDER == 0.0D+00 ) THEN
             RV6(K) = RV6(K) - V * RV6(I)
           END IF

        END DO

       END IF

      END IF

      END DO

     END IF
!
!  BACK SUBSTITUTION.
!
600  CONTINUE

     DO II = 1, N

        I = N + 1 - II
        MAXJ = MIN ( II, M21 )

        IF ( MAXJ /= 1 ) THEN

          IJ1 = I
          J = IJ1 + N
          JJ = J + (MAXJ - 2) * N

          DO IJ = J, JJ, N
            IJ1 = IJ1 + 1
            RV6(I) = RV6(I) - RV(IJ) * RV6(IJ1)
          END DO

        END IF

        V = RV(I)
!
!  ERROR: NEARLY SINGULAR LINEAR SYSTEM.
!
        IF ( ABS ( V ) < EPS3) THEN
          IF ( ORDER == 0.0D+00 ) THEN
            IERR = -R
          END IF
          V = SIGN ( EPS3, V )
        END IF

        RV6(I) = RV6(I) / V

     END DO

     XU = 1.0D+00

     IF ( ORDER == 0.0D+00 ) GO TO 870
!
!  ORTHOGONALIZE WITH RESPECT TO PREVIOUS MEMBERS OF GROUP.
!
     DO JJ = 1, GROUP

        J = R - GROUP - 1 + JJ

        XU = DOT_PRODUCT ( RV6(1:N), Z(1:N,J) )

        RV6(1:N) = RV6(1:N) - XU * Z(1:N,J)

     END DO

     NORM = SUM ( ABS ( RV6(1:N) ) )
!
!  CHOOSE A NEW STARTING VECTOR.
!
     IF ( NORM < 0.1D+00 ) THEN

       IF ( ITS < N ) THEN
         ITS = ITS + 1
         XU = EPS4 / ( UK + 1.0D+00 )
         RV6(1) = EPS4
         RV6(2:N) = XU
         RV6(ITS) = RV6(ITS) - EPS4 * UK
         GO TO 600
       ELSE
         IERR = -R
         XU = 0.0D+00
         GO TO 870
       END IF

     END IF
!
!   NORMALIZE SO THAT SUM OF SQUARES IS 1 AND EXPAND TO FULL ORDER.
!
     U = 0.0D+00
     DO I = 1, N
       U = PYTHAG ( U, RV6(I) )
     END DO

     XU = 1.0D+00 / U

 870 CONTINUE

     Z(1:N,R) = RV6(1:N) * XU

     X0 = X1

  END DO

  RETURN
END
SUBROUTINE BISECT ( N, EPS1, D, E, E2, LB, UB, MM, M, W, IND, IERR )

!*****************************************************************************80
!
!! BISECT COMPUTES SOME EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVALUES OF A REAL SYMMETRIC
!    TRIDIAGONAL MATRIX WHICH LIE IN A SPECIFIED INTERVAL, USING BISECTION.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) EPS1, IS AN ABSOLUTE ERROR TOLERANCE FOR
!    THE COMPUTED EIGENVALUES.  IF THE INPUT EPS1 IS NON-POSITIVE, IT IS RESET
!    FOR EACH SUBMATRIX TO A DEFAULT VALUE, NAMELY, MINUS THE PRODUCT OF THE
!    RELATIVE MACHINE PRECISION AND THE 1-NORM OF THE SUBMATRIX.
!
!    INPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) E(N), CONTAINS IN E(2:N) THE SUBDIAGONAL ELEMENTS
!    OF THE MATRIX.  E(1) IS ARBITRARY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N).  ON INPUT, THE SQUARES OF THE
!    CORRESPONDING ELEMENTS OF E.  E2(1) IS ARBITRARY.  ON OUTPUT, ELEMENTS OF E2,
!    CORRESPONDING TO ELEMENTS OF E REGARDED AS NEGLIGIBLE, HAVE BEEN
!    REPLACED BY ZERO, CAUSING THE MATRIX TO SPLIT INTO A DIRECT SUM OF
!    SUBMATRICES.  E2(1) IS ALSO SET TO ZERO.
!
!    INPUT, REAL ( KIND = 8 ) LB, UB, DEFINE THE INTERVAL TO BE SEARCHED FOR
!    EIGENVALUES.  IF LB IS NOT LESS THAN UB, NO EIGENVALUES WILL BE FOUND.
!
!    INPUT, INTEGER ( KIND = 4 ) MM, AN UPPER BOUND FOR THE NUMBER OF
!    EIGENVALUES IN THE INTERVAL.  WARNING: IF MORE THAN MM EIGENVALUES ARE
!    DETERMINED TO LIE IN THE INTERVAL, AN ERROR RETURN IS MADE WITH NO
!    EIGENVALUES FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVALUES DETERMINED TO LIE
!    IN (LB,UB).
!
!    OUTPUT, REAL ( KIND = 8 ) W(M), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IND(MM), CONTAINS IN ITS FIRST M POSITIONS
!    THE SUBMATRIX INDICES ASSOCIATED WITH THE CORRESPONDING EIGENVALUES IN W:
!    1 FOR EIGENVALUES BELONGING TO THE FIRST SUBMATRIX FROM THE TOP, 2 FOR
!    THOSE BELONGING TO THE SECOND SUBMATRIX, AND SO ON.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    3*N+1, IF M EXCEEDS MM.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) EPS1
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IND(MM)
  INTEGER ( KIND = 4 ) ISTURM
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) LB
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) M1
  INTEGER ( KIND = 4 ) M2
  INTEGER ( KIND = 4 ) P
  INTEGER ( KIND = 4 ) Q
  INTEGER ( KIND = 4 ) R
  REAL    ( KIND = 8 ) RV4(N)
  REAL    ( KIND = 8 ) RV5(N)
  INTEGER ( KIND = 4 ) S
  REAL    ( KIND = 8 ) T1
  REAL    ( KIND = 8 ) T2
  INTEGER ( KIND = 4 ) TAG
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) U
  REAL    ( KIND = 8 ) UB
  REAL    ( KIND = 8 ) V
  REAL    ( KIND = 8 ) W(MM)
  REAL    ( KIND = 8 ) X0
  REAL    ( KIND = 8 ) X1
  REAL    ( KIND = 8 ) XU

  IERR = 0
  S = 0
  TAG = 0
  T1 = LB
  T2 = UB
!
!  LOOK FOR SMALL SUB-DIAGONAL ENTRIES.
!
  E2(1) = 0.0D+00

  DO I = 2, N

    TST1 = ABS ( D(I) ) + ABS ( D(I-1) )
    TST2 = TST1 + ABS ( E(I) )

    IF ( TST2 <= TST1 ) THEN
      E2(I) = 0.0D+00
    END IF

  END DO
!
!  DETERMINE THE NUMBER OF EIGENVALUES IN THE INTERVAL.
!
  P = 1
  Q = N
  X1 = UB
  ISTURM = 1
  GO TO 320

60 CONTINUE

  M = S
  X1 = LB
  ISTURM = 2
  GO TO 320

80 CONTINUE

  M = M - S

  IF ( MM < M ) THEN
    GO TO 980
  END IF

  Q = 0
  R = 0
!
!  ESTABLISH AND PROCESS NEXT SUBMATRIX, REFINING
!  INTERVAL BY THE GERSCHGORIN BOUNDS.
!
100 CONTINUE

  IF ( R == M ) GO TO 1001

  TAG = TAG + 1
  P = Q + 1
  XU = D(P)
  X0 = D(P)
  U = 0.0D+00

  DO Q = P, N

    X1 = U
    U = 0.0D+00
    V = 0.0D+00

    IF ( Q /= N ) THEN
      U = ABS ( E(Q+1) )
      V = E2(Q+1)
    END IF

    XU = MIN ( D(Q) - ( X1 + U ), XU )
    X0 = MAX ( D(Q) + ( X1 + U ), X0 )

    IF ( V == 0.0D+00 ) THEN
      EXIT
    END IF

  END DO

  X1 = MAX ( ABS ( XU ), ABS ( X0 ) ) * EPSILON ( X1 )
  IF ( EPS1 <= 0.0D+00 ) THEN
    EPS1 = -X1
  END IF

  IF ( P /= Q ) GO TO 180
!
!  CHECK FOR AN ISOLATED ROOT WITHIN INTERVAL.
!
  IF ( D(P) < T1 .OR. T2 <= D(P) ) THEN
    GO TO 940
  END IF

  M1 = P
  M2 = P
  RV5(P) = D(P)
  GO TO 900

  180 CONTINUE

  X1 = X1 * ( Q - P + 1 )
  LB = MAX ( T1, XU - X1 )
  UB = MIN ( T2, X0 + X1 )
  X1 = LB
  ISTURM = 3
  GO TO 320

  200 CONTINUE

  M1 = S + 1
  X1 = UB
  ISTURM = 4
  GO TO 320

  220 CONTINUE

  M2 = S
  IF ( M2 < M1 ) THEN
    GO TO 940
  END IF
!
!  FIND ROOTS BY BISECTION.
!
  X0 = UB
  ISTURM = 5
  RV5(M1:M2) = UB
  RV4(M1:M2) = LB
!
!  LOOP FOR THE K-TH EIGENVALUE.
!
  K = M2

250 CONTINUE

     XU = LB

     DO II = M1, K
       I = M1 + K - II
       IF ( XU < RV4(I) ) THEN
         XU = RV4(I)
         GO TO 280
       END IF
     END DO

  280 CONTINUE

   X0 = MIN ( X0, RV5(K) )
!
!  NEXT BISECTION STEP.
!
  300    CONTINUE

     X1 = ( XU + X0 ) * 0.5D+00

     IF ( (X0 - XU) <= ABS ( EPS1 ) ) GO TO 420

     TST1 = 2.0D+00 * ( ABS ( XU ) + ABS ( X0 ) )
     TST2 = TST1 + ( X0 - XU )
     IF ( TST2 == TST1 ) GO TO 420
!
!  STURM SEQUENCE.
!
320  CONTINUE

     S = P - 1
     U = 1.0D+00

     DO I = P, Q

        IF ( U == 0.0D+00 ) THEN
          V = ABS ( E(I) ) / EPSILON ( V )
          IF ( E2(I) == 0.0D+00 ) V = 0.0D+00
        ELSE
          V = E2(I) / U
        END IF

        U = D(I) - X1 - V
        IF ( U < 0.0D+00 ) THEN
          S = S + 1
        END IF

     END DO

     GO TO (60,80,200,220,360), ISTURM
!
!  REFINE INTERVALS.
!
  360 CONTINUE

     IF ( K <= S ) THEN
       GO TO 400
     END IF

     XU = X1

     IF ( S < M1 ) THEN
       RV4(M1) = X1
       GO TO 300
     END IF

  380 CONTINUE

     RV4(S+1) = X1

     IF ( X1 < RV5(S) ) THEN
       RV5(S) = X1
     END IF

     GO TO 300
400  CONTINUE
     X0 = X1
     GO TO 300
!
!  K-TH EIGENVALUE FOUND.
!
420 CONTINUE

  RV5(K) = X1
  K = K - 1
  IF ( K >= M1 ) GO TO 250
!
!  ORDER EIGENVALUES TAGGED WITH THEIR SUBMATRIX ASSOCIATIONS.
!
900 CONTINUE

  S = R
  R = R + M2 - M1 + 1
  J = 1
  K = M1

  DO L = 1, R

    IF ( J <= S ) THEN

      IF ( K > M2 ) THEN
        EXIT
      END IF

      IF ( RV5(K) >= W(L) ) THEN
        J = J + 1
        CYCLE
      END IF

      DO II = J, S
        I = L + S - II
        W(I+1) = W(I)
        IND(I+1) = IND(I)
      END DO

    END IF

    W(L) = RV5(K)
    IND(L) = TAG
    K = K + 1

  END DO

940 CONTINUE

  IF ( Q < N ) THEN
    GO TO 100
  END IF

  GO TO 1001
!
!  SET ERROR: UNDERESTIMATE OF NUMBER OF EIGENVALUES IN INTERVAL.
!
980 CONTINUE

  IERR = 3 * N + 1

 1001 CONTINUE

  LB = T1
  UB = T2

  RETURN
END
SUBROUTINE BQR ( N, MB, A, T, R, IERR )

!*****************************************************************************80
!
!! BQR FINDS THE SMALLEST EIGENVALUE OF A REAL SYMMETRIC BAND MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUE OF SMALLEST MAGNITUDE OF A REAL
!    SYMMETRIC BAND MATRIX USING THE QR ALGORITHM WITH SHIFTS OF ORIGIN.
!    CONSECUTIVE CALLS CAN BE MADE TO FIND FURTHER EIGENVALUES.
!
!    NOTE THAT FOR A SUBSEQUENT CALL, N SHOULD BE REPLACED BY N-1, BUT
!    MB SHOULD NOT BE ALTERED EVEN WHEN IT EXCEEDS THE CURRENT N.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MB, THE (HALF) BAND WIDTH OF THE MATRIX,
!    DEFINED AS THE NUMBER OF ADJACENT DIAGONALS, INCLUDING THE PRINCIPAL
!    DIAGONAL, REQUIRED TO SPECIFY THE NON-ZERO PORTION OF THE
!    LOWER TRIANGLE OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,MB).  ON INPUT, A CONTAINS THE LOWER
!    TRIANGLE OF THE SYMMETRIC BAND INPUT MATRIX STORED AS AN N BY MB ARRAY.
!    ITS LOWEST SUBDIAGONAL IS STORED IN THE LAST N+1-MB POSITIONS OF THE FIRST
!    COLUMN, ITS NEXT SUBDIAGONAL IN THE LAST N+2-MB POSITIONS OF THE
!    SECOND COLUMN, FURTHER SUBDIAGONALS SIMILARLY, AND FINALLY ITS PRINCIPAL
!    DIAGONAL IN THE N POSITIONS OF THE LAST COLUMN.  CONTENTS OF STORAGES
!    NOT PART OF THE MATRIX ARE ARBITRARY.  ON A SUBSEQUENT CALL, ITS OUTPUT
!    CONTENTS FROM THE PREVIOUS CALL SHOULD BE PASSED.  ON OUTPUT, A CONTAINS
!    THE TRANSFORMED BAND MATRIX.  THE MATRIX A+T*I DERIVED FROM THE OUTPUT
!    PARAMETERS IS SIMILAR TO THE INPUT A+T*I TO WITHIN ROUNDING ERRORS.
!    ITS LAST ROW AND COLUMN ARE NULL AS LONG AS IERR IS ZERO.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) T.  ON INPUT, T SPECIFIES THE SHIFT (OF
!    EIGENVALUES) APPLIED TO THE DIAGONAL OF A IN FORMING THE INPUT MATRIX.
!    WHAT IS ACTUALLY DETERMINED IS THE EIGENVALUE NEAREST TO T OF A+T*I, WHERE
!    I IS THE IDENTITY MATRIX.  ON A SUBSEQUENT CALL, THE OUTPUT VALUE OF T
!    FROM THE PREVIOUS CALL SHOULD BE PASSED IF THE NEXT NEAREST EIGENVALUE
!    IS SOUGHT.  ON OUTPUT, T CONTAINS THE COMPUTED EIGENVALUE OF A+T*I,
!    AS LONG AS IERR IS ZERO.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) R.  ON INPUT FOR THE FIRST CALL, R SHOULD BE
!    SPECIFIED AS ZERO, AND AS ITS OUTPUT VALUE FROM THE PREVIOUS CALL
!    ON A SUBSEQUENT CALL.  IT IS USED TO DETERMINE WHEN THE LAST ROW AND
!    COLUMN OF THE TRANSFORMED BAND MATRIX CAN BE REGARDED AS NEGLIGIBLE.
!    ON OUTPUT, R CONTAINS THE MAXIMUM OF ITS INPUT VALUE AND THE NORM OF THE
!    LAST COLUMN OF THE INPUT MATRIX A.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NORMAL RETURN.
!    N, IF THE EIGENVALUE HAS NOT BEEN DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MB
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,MB)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IK
  INTEGER ( KIND = 4 ) IMULT
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JK
  INTEGER ( KIND = 4 ) JM
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) KJ
  INTEGER ( KIND = 4 ) KJ1
  INTEGER ( KIND = 4 ) KK
  INTEGER ( KIND = 4 ) KM
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) M1
  INTEGER ( KIND = 4 ) M2
  INTEGER ( KIND = 4 ) M21
  INTEGER ( KIND = 4 ) M3
  INTEGER ( KIND = 4 ) M31
  INTEGER ( KIND = 4 ) M4
  INTEGER ( KIND = 4 ) MK
  INTEGER ( KIND = 4 ) MN
  INTEGER ( KIND = 4 ) MZ
  INTEGER ( KIND = 4 ) NI
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) Q
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RV(2*MB*MB+4*MB-3)
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2

  IERR = 0
  M1 = MIN ( MB, N )
  M = M1 - 1
  M2 = M + M
  M21 = M2 + 1
  M3 = M21 + M
  M31 = M3 + 1
  M4 = M31 + M2
  MN = M + N
  MZ = MB - M1
  ITS = 0
!
!  TEST FOR CONVERGENCE.
!
40 CONTINUE

  G = A(N,MB)

  IF ( M == 0 ) GO TO 360

  F = 0.0D+00
  DO K = 1, M
    MK = K + MZ
    F = F + ABS ( A(N,MK) )
  END DO

  IF ( ITS == 0 .AND. R < F ) THEN
    R = F
  END IF

  TST1 = R
  TST2 = TST1 + F

  IF ( TST2 <= TST1 ) GO TO 360

  IF ( 30 <= ITS ) THEN
    IERR = N
    RETURN
  END IF

  ITS = ITS + 1
!
!  FORM SHIFT FROM BOTTOM 2 BY 2 MINOR.
!
  IF ( F <= 0.25D+00 * R .OR. ITS >= 5 ) THEN

    F = A(N,MB-1)

    IF ( F /= 0.0D+00 ) THEN
      Q = ( A(N-1,MB) - G ) / ( 2.0D+00 * F )
      S = PYTHAG ( Q, 1.0D+00 )
      G = G - F / ( Q + SIGN ( S, Q ) )
    END IF

    T = T + G

    A(1:N,MB) = A(1:N,MB) - G

  END IF

  RV(M31:M4) = 0.0D+00

  DO II = 1, MN

     I = II - M
     NI = N - II

     IF ( NI < 0 ) GO TO 230
!
!  FORM COLUMN OF SHIFTED MATRIX A-G*I.
!
     L = MAX ( 1, 2-I )

     RV(1:M3) = 0.0D+00

     DO K = L, M1
       KM = K + M
       MK = K + MZ
       RV(KM) = A(II,MK)
     END DO

     LL = MIN ( M, NI )

     DO K = 1, LL
       KM = K + M21
       IK = II + K
       MK = MB - K
       RV(KM) = A(IK,MK)
     END DO
!
!  PRE-MULTIPLY WITH HOUSEHOLDER REFLECTIONS.
!
     LL = M2
     IMULT = 0
!
!  MULTIPLICATION PROCEDURE.
!
140  CONTINUE

     KJ = M4 - M1

     DO J = 1, LL

        KJ = KJ + M1
        JM = J + M3

        IF ( RV(JM) /= 0.0D+00 ) THEN

          F = 0.0D+00

          DO K = 1, M1
            KJ = KJ + 1
            JK = J + K - 1
            F = F + RV(KJ) * RV(JK)
          END DO

          F = F / RV(JM)
          KJ = KJ - M1

          DO K = 1, M1
            KJ = KJ + 1
            JK = J + K - 1
            RV(JK) = RV(JK) - RV(KJ) * F
          END DO

          KJ = KJ - M1

        END IF

     END DO

     IF ( IMULT /= 0 ) GO TO 280
!
!  HOUSEHOLDER REFLECTION.
!
     F = RV(M21)
     S = 0.0D+00
     RV(M4) = 0.0D+00
     SCALE = SUM ( ABS ( RV(M21:M3) ) )

     IF ( SCALE == 0.0D+00 ) THEN
       GO TO 210
     END IF

     DO K = M21, M3
       S = S + ( RV(K) / SCALE )**2
     END DO

     S = SCALE * SCALE * S
     G = - SIGN ( SQRT ( S ), F )
     RV(M21) = G
     RV(M4) = S - F * G
     KJ = M4 + M2 * M1 + 1
     RV(KJ) = F - G

     DO K = 2, M1
       KJ = KJ + 1
       KM = K + M2
       RV(KJ) = RV(KM)
     END DO
!
!  SAVE COLUMN OF TRIANGULAR FACTOR R.
!
210  CONTINUE

     DO K = L, M1
       KM = K + M
       MK = K + MZ
       A(II,MK) = RV(KM)
     END DO

230  CONTINUE

     L = MAX ( 1, M1+1-I )
     IF ( I <= 0 ) GO TO 300
!
!  PERFORM ADDITIONAL STEPS.
!
     RV(1:M21) = 0.0D+00
     LL = MIN ( M1, NI+M1 )
!
!  GET ROW OF TRIANGULAR FACTOR R.
!
     DO KK = 1, LL
       K = KK - 1
       KM = K + M1
       IK = I + K
       MK = MB - K
       RV(KM) = A(IK,MK)
     END DO
!
!  POST-MULTIPLY WITH HOUSEHOLDER REFLECTIONS.
!
     LL = M1
     IMULT = 1
     GO TO 140
!
!  STORE COLUMN OF NEW A MATRIX.
!
280  CONTINUE

     DO K = L, M1
       MK = K + MZ
       A(I,MK) = RV(K)
     END DO
!
!  UPDATE HOUSEHOLDER REFLECTIONS.
!
300  CONTINUE

     IF ( 1 < L ) THEN
       L = L - 1
     END IF

     KJ1 = M4 + L * M1

     DO J = L, M2

       JM = J + M3
       RV(JM) = RV(JM+1)

       DO K = 1, M1
         KJ1 = KJ1 + 1
         KJ = KJ1 - M1
         RV(KJ) = RV(KJ1)
       END DO

     END DO

  END DO

  GO TO 40
!
!  CONVERGENCE.
!
360 CONTINUE

  T = T + G
  A(1:N,MB) = A(1:N,MB) - G

  DO K = 1, M1
    MK = K + MZ
    A(N,MK) = 0.0D+00
  END DO

  RETURN
END
SUBROUTINE CBABK2 ( N, LOW, IGH, SCALE, M, ZR, ZI )

!*****************************************************************************80
!
!! CBABK2 FINDS EIGENVECTORS BY UNDOING THE CBAL TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX GENERAL
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    BALANCED MATRIX DETERMINED BY CBAL.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, VALUES DETERMINED BY CBAL.
!
!    INPUT, REAL ( KIND = 8 ) SCALE(N), INFORMATION DETERMINING THE PERMUTATIONS
!    AND SCALING FACTORS USED BY CBAL.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ZR(N,M), ZI(N,M).  ON INPUT, THE REAL
!    AND IMAGINARY PARTS, RESPECTIVELY, OF THE EIGENVECTORS TO BE BACK
!    TRANSFORMED IN THEIR FIRST M COLUMNS.  ON OUTPUT, THE TRANSFORMED
!    EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) LOW
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE(N)
  REAL    ( KIND = 8 ) ZI(N,M)
  REAL    ( KIND = 8 ) ZR(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF

  IF ( IGH /= LOW ) THEN

    DO I = LOW, IGH

      S = SCALE(I)

      ZR(I,1:M) = ZR(I,1:M) * S
      ZI(I,1:M) = ZI(I,1:M) * S

    END DO

  END IF

  DO II = 1, N

    I = II

    IF ( I < LOW .OR. I > IGH ) THEN

      IF ( I < LOW ) THEN
        I = LOW - II
      END IF

      K = SCALE(I)

      IF ( K /= I ) THEN

        DO J = 1, M
          CALL R8_SWAP ( ZR(I,J), ZR(K,J) )
          CALL R8_SWAP ( ZI(I,J), ZI(K,J) )
        END DO

      END IF

    END IF

  END DO

  RETURN
END
SUBROUTINE CBAL ( N, AR, AI, LOW, IGH, SCALE )

!*****************************************************************************80
!
!! CBAL BALANCES A COMPLEX MATRIX BEFORE EIGENVALUE CALCULATIONS.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE BALANCES A COMPLEX MATRIX AND ISOLATES
!    EIGENVALUES WHENEVER POSSIBLE.
!
!    SUPPOSE THAT THE PRINCIPAL SUBMATRIX IN ROWS LOW THROUGH IGH
!    HAS BEEN BALANCED, THAT P(J) DENOTES THE INDEX INTERCHANGED
!    WITH J DURING THE PERMUTATION STEP, AND THAT THE ELEMENTS
!    OF THE DIAGONAL MATRIX USED ARE DENOTED BY D(I,J).  THEN
!      SCALE(J) = P(J),    FOR J = 1,...,LOW-1
!               = D(J,J)       J = LOW,...,IGH
!               = P(J)         J = IGH+1,...,N.
!    THE ORDER IN WHICH THE INTERCHANGES ARE MADE IS N TO IGH+1,
!    THEN 1 TO LOW-1.
!
!    NOTE THAT 1 IS RETURNED FOR IGH IF IGH IS ZERO FORMALLY.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N).  ON INPUT, THE REAL AND
!    IMAGINARY PARTS OF THE COMPLEX MATRIX TO BE BALANCED.  ON OUTPUT,
!    THE REAL AND IMAGINARY PARTS OF THE BALANCED MATRIX.
!
!    OUTPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE VALUES SUCH THAT AR(I,J)
!    AND AI(I,J) ARE ZERO IF I IS GREATER THAN J AND EITHER J=1,...,LOW-1 OR
!    I=IGH+1,...,N.
!
!    OUTPUT, REAL ( KIND = 8 ) SCALE(N), INFORMATION DETERMINING THE
!    PERMUTATIONS AND SCALING FACTORS USED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) B2
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IEXC
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  LOGICAL              NOCONV
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RADIX
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE(N)

  RADIX = 16.0D+00

  IEXC = 0
  J = 0
  M = 0

  B2 = RADIX * RADIX
  K = 1
  L = N
  GO TO 100

20 CONTINUE

  SCALE(M) = J

  IF ( J /= M ) THEN

    DO I = 1, L
      CALL R8_SWAP ( AR(I,J), AR(I,M) )
      CALL R8_SWAP ( AI(I,J), AI(I,M) )
    END DO

    DO I = K, N
      CALL R8_SWAP ( AR(J,I), AR(M,I) )
      CALL R8_SWAP ( AI(J,I), AI(M,I) )
    END DO

  END IF

  IF ( IEXC == 2 ) THEN
    GO TO 130
  END IF
!
!  SEARCH FOR ROWS ISOLATING AN EIGENVALUE AND PUSH THEM DOWN.
!
80 CONTINUE

  IF ( L == 1 ) THEN
    GO TO 280
  END IF

  L = L - 1

100 CONTINUE

  DO JJ = 1, L

     J = L + 1 - JJ

     DO I = 1, L
       IF ( I /= J ) THEN
         IF ( AR(J,I) /= 0.0D+00 .OR. AI(J,I) /= 0.0D+00 ) GO TO 120
       END IF
     END DO

     M = L
     IEXC = 1
     GO TO 20

120  CONTINUE

  END DO

  GO TO 140
!
!  SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE AND PUSH THEM LEFT.
!
130 CONTINUE

  K = K + 1

140 CONTINUE

   DO J = K, L

     DO I = K, L
       IF ( I /= J ) THEN
         IF ( AR(I,J) /= 0.0D+00 .OR. AI(I,J) /= 0.0D+00 ) GO TO 170
       END IF
     END DO

     M = K
     IEXC = 2
     GO TO 20
170  CONTINUE

  END DO
!
!  NOW BALANCE THE SUBMATRIX IN ROWS K TO L.
!
  SCALE(K:L) = 1.0D+00
!
!  ITERATIVE LOOP FOR NORM REDUCTION.
!
190 CONTINUE

  NOCONV = .FALSE.

  DO I = K, L

    C = 0.0D+00
    R = 0.0D+00

    DO J = K, L
      IF ( J /= I ) THEN
        C = C + ABS ( AR(J,I) ) + ABS ( AI(J,I) )
        R = R + ABS ( AR(I,J) ) + ABS ( AI(I,J) )
      END IF
    END DO
!
!  GUARD AGAINST ZERO C OR R DUE TO UNDERFLOW.
!
     IF ( C == 0.0D+00 .OR. R == 0.0D+00 ) GO TO 270

     G = R / RADIX
     F = 1.0D+00
     S = C + R

     DO WHILE ( C < G )
       F = F * RADIX
       C = C * B2
     END DO

     G = R * RADIX

     DO WHILE  ( C >= G )
       F = F / RADIX
       C = C / B2
     END DO
!
!  NOW BALANCE.
!
     IF ( ( C + R ) / F < 0.95D+00 * S ) THEN

       G = 1.0D+00 / F
       SCALE(I) = SCALE(I) * F
       NOCONV = .TRUE.

       AR(I,K:N) = AR(I,K:N) * G
       AI(I,K:N) = AI(I,K:N) * G

       AR(1:L,I) = AR(1:L,I) * F
       AI(1:L,I) = AI(1:L,I) * F

     END IF

270  CONTINUE

  END DO

  IF ( NOCONV ) GO TO 190

  280 CONTINUE

  LOW = K
  IGH = L

  RETURN
END
SUBROUTINE CDIV ( AR, AI, BR, BI, CR, CI )

!*****************************************************************************80
!
!! CDIV EMULATES COMPLEX DIVISION, USING REAL ARITHMETIC.
!
!  DISCUSSION:
!
!    THIS ROUTINE PERFORMS COMPLEX DIVISION:
!
!      (CR,CI) = (AR,AI) / (BR,BI)
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, REAL ( KIND = 8 ) AR, AI, THE REAL AND IMAGINARY PARTS OF
!    THE NUMERATOR.
!
!    INPUT, REAL ( KIND = 8 ) BR, BI, THE REAL AND IMAGINARY PARTS OF
!    THE DENOMINATOR.
!
!    OUTPUT, REAL ( KIND = 8 ) CR, CI, THE REAL AND IMAGINARY PARTS OF
!    THE RESULT.
!
  IMPLICIT NONE

  REAL    ( KIND = 8 ) AI
  REAL    ( KIND = 8 ) AIS
  REAL    ( KIND = 8 ) AR
  REAL    ( KIND = 8 ) ARS
  REAL    ( KIND = 8 ) BI
  REAL    ( KIND = 8 ) BIS
  REAL    ( KIND = 8 ) BR
  REAL    ( KIND = 8 ) BRS
  REAL    ( KIND = 8 ) CI
  REAL    ( KIND = 8 ) CR
  REAL    ( KIND = 8 ) S

  S = ABS ( BR ) + ABS ( BI )

  ARS = AR / S
  AIS = AI / S
  BRS = BR / S
  BIS = BI / S

  S = BRS**2 + BIS**2
  CR = ( ARS * BRS + AIS * BIS ) / S
  CI = ( AIS * BRS - ARS * BIS ) / S

  RETURN
END
SUBROUTINE CG ( N, AR, AI, WR, WI, MATZ, ZR, ZI, IERR )

!*****************************************************************************80
!
!! CG GETS EIGENVALUES AND EIGENVECTORS OF A COMPLEX GENERAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF EISPACK SUBROUTINES
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A COMPLEX GENERAL MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N).  ON INPUT, THE REAL AND
!    IMAGINARY PARTS OF THE COMPLEX MATRIX.  ON OUTPUT, AR AND AI
!    HAVE BEEN OVERWRITTEN BY OTHER INFORMATION.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS
!    OF THE EIGENVALUES.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS 0 IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE TO BE COMPUTED.
!
!    OUTPUT, REAL ( KIND = 8 ) ZR(N,N), ZI(N,N), THE REAL AND IMAGINARY PARTS,
!    RESPECTIVELY, OF THE EIGENVECTORS, IF MATZ IS NOT ZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, AN ERROR COMPLETION CODE DESCRIBED IN THE
!    DOCUMENTATION FOR COMQR AND COMQR2.  THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  REAL    ( KIND = 8 ) FV3(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IS1
  INTEGER ( KIND = 4 ) IS2
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) ZI(N,N)
  REAL    ( KIND = 8 ) ZR(N,N)

  CALL CBAL ( N, AR, AI, IS1, IS2, FV1 )

  CALL CORTH ( N, IS1, IS2, AR, AI, FV2, FV3 )

  IF ( MATZ == 0 ) THEN

    CALL COMQR ( N, IS1, IS2, AR, AI, WR, WI, IERR )

    IF ( IERR /= 0 ) THEN
      RETURN
    END IF

  ELSE

    CALL COMQR2 ( N, IS1, IS2, FV2, FV3, AR, AI, WR, WI, ZR, ZI, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'CG - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  NONZERO ERROR RETURN FROM COMQR2.'
      RETURN
    END IF

    CALL CBABK2 ( N, IS1, IS2, FV1, N, ZR, ZI )

  END IF

  RETURN
END
SUBROUTINE CH ( N, AR, AI, W, MATZ, ZR, ZI, IERR )

!*****************************************************************************80
!
!! CH GETS EIGENVALUES AND EIGENVECTORS OF A COMPLEX HERMITIAN MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF SUBROUTINES FROM THE
!    EISPACK EIGENSYSTEM PACKAGE TO FIND THE EIGENVALUES AND EIGENVECTORS
!    OF A COMPLEX HERMITIAN MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N).  ON INPUT, THE REAL AND
!    IMAGINARY PARTS OF THE COMPLEX MATRIX.  ON OUTPUT, AR AND AI
!    HAVE BEEN OVERWRITTEN BY OTHER INFORMATION.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS 0 IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE TO BE COMPUTED.
!
!    OUTPUT, REAL ( KIND = 8 ) ZR(N,N), ZI(N,N), THE REAL AND IMAGINARY PARTS,
!    RESPECTIVELY, OF THE EIGENVECTORS, IF MATZ IS NOT ZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, AN ERROR COMPLETION CODE DESCRIBED IN THE
!    DOCUMENTATION FOR TQLRAT AND TQL2.  THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) FM1(2,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) ZI(N,N)
  REAL    ( KIND = 8 ) ZR(N,N)

  CALL HTRIDI ( N, AR, AI, W, FV1, FV2, FM1 )

  IF ( MATZ == 0 ) THEN

    CALL TQLRAT ( N, W, FV2, IERR )

  ELSE

    ZR(1:N,1:N) = 0.0D+00

    DO I = 1, N
      ZR(I,I) = 1.0D+00
    END DO

    CALL TQL2 ( N, W, FV1, ZR, IERR )

    IF ( IERR /= 0 ) THEN
      RETURN
    END IF

    CALL HTRIBK ( N, AR, AI, FM1, N, ZR, ZI )

  END IF

  RETURN
END
SUBROUTINE CINVIT ( N, AR, AI, WR, WI, SELECT, MM, M, ZR, ZI, IERR )

!*****************************************************************************80
!
!! CINVIT GETS EIGENVECTORS FROM EIGENVALUES, FOR A COMPLEX HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVECTORS OF A COMPLEX UPPER
!    HESSENBERG MATRIX CORRESPONDING TO SPECIFIED EIGENVALUES,
!    USING INVERSE ITERATION.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N), THE REAL AND IMAGINARY PARTS OF
!    THE COMPLEX HESSENBERG MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N).  ON INPUT, THE REAL AND
!    IMAGINARY PARTS OF THE EIGENVALUES OF THE MATRIX.  THE EIGENVALUES MUST
!    BE STORED IN A MANNER IDENTICAL TO THAT OF SUBROUTINE COMLR, WHICH
!    RECOGNIZES POSSIBLE SPLITTING OF THE MATRIX.  ON OUTPUT, WR MAY HAVE BEEN
!    ALTERED SINCE CLOSE EIGENVALUES ARE PERTURBED SLIGHTLY IN SEARCHING FOR
!    INDEPENDENT EIGENVECTORS.
!
!    INPUT, LOGICAL SELECT(N), SPECIFIES THE EIGENVECTORS TO BE FOUND.  THE
!    EIGENVECTOR CORRESPONDING TO THE J-TH EIGENVALUE IS SPECIFIED BY
!    SETTING SELECT(J) TO TRUE.
!
!    INPUT, INTEGER ( KIND = 4 ) MM, AN UPPER BOUND FOR THE NUMBER OF EIGENVECTORS
!    TO BE FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS ACTUALLY FOUND.
!
!    OUTPUT, REAL ( KIND = 8 ) ZR(N,MM), ZI(N,MM), THE REAL AND IMAGINARY PARTS
!    OF THE EIGENVECTORS.  THE EIGENVECTORS ARE NORMALIZED SO THAT THE
!    COMPONENT OF LARGEST MAGNITUDE IS 1.
!    ANY VECTOR WHICH FAILS THE ACCEPTANCE TEST IS SET TO ZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    -(2*N+1), IF MORE THAN MM EIGENVECTORS HAVE BEEN SPECIFIED,
!    -K, IF THE ITERATION CORRESPONDING TO THE K-TH VALUE FAILS,
!    -(N+K), IF BOTH ERROR SITUATIONS OCCUR.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) EPS3
  REAL    ( KIND = 8 ) GROWTO
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  REAL    ( KIND = 8 ) ILAMBD
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) KM1
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) NORMV
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) RLAMBD
  REAL    ( KIND = 8 ) RM1(N,N)
  REAL    ( KIND = 8 ) RM2(N,N)
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) RV2(N)
  INTEGER ( KIND = 4 ) S
  LOGICAL              SELECT(N)
  INTEGER ( KIND = 4 ) UK
  REAL    ( KIND = 8 ) UKROOT
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) ZI(N,MM)
  REAL    ( KIND = 8 ) ZR(N,MM)

  IERR = 0
  UK = 0
  S = 1

  DO K = 1, N

    IF ( .NOT. SELECT(K) ) THEN
      CYCLE
    END IF

    IF ( S > MM ) GO TO 1000

    IF ( UK >= K ) GO TO 200
!
!  CHECK FOR POSSIBLE SPLITTING.
!
     DO UK = K, N - 1

       IF ( AR(UK+1,UK) == 0.0D+00 .AND. AI(UK+1,UK) == 0.0D+00 ) THEN
         EXIT
       END IF

     END DO
!
!  COMPUTE INFINITY NORM OF LEADING UK BY UK (HESSENBERG) MATRIX.
!
     NORM = 0.0D+00
     MP = 1

     DO I = 1, UK

       X = 0.0D+00
       DO J = MP, UK
         X = X + PYTHAG ( AR(I,J), AI(I,J) )
       END DO

       NORM = MAX ( NORM, X )
       MP = I

     END DO
!
!  EPS3 REPLACES ZERO PIVOT IN DECOMPOSITION
!  AND CLOSE ROOTS ARE MODIFIED BY EPS3.
!
     IF ( NORM == 0.0D+00 ) NORM = 1.0D+00
     EPS3 = ABS ( NORM ) * EPSILON ( EPS3 )
!
!  GROWTO IS THE CRITERION FOR GROWTH.
!
     UKROOT = UK
     UKROOT = SQRT ( UKROOT )
     GROWTO = 0.1D+00 / UKROOT

200  CONTINUE

     RLAMBD = WR(K)
     ILAMBD = WI(K)
     IF ( K == 1 ) GO TO 280
     KM1 = K - 1
     GO TO 240
!
!  PERTURB EIGENVALUE IF IT IS CLOSE TO ANY PREVIOUS EIGENVALUE.
!
220  CONTINUE

     RLAMBD = RLAMBD + EPS3

240  CONTINUE

     DO II = 1, KM1
        I = K - II
        IF ( SELECT(I) .AND. ABS ( WR(I)-RLAMBD) < EPS3 .AND. &
            ABS ( WI(I)-ILAMBD) < EPS3 ) THEN
          GO TO 220
        END IF
     END DO

     WR(K) = RLAMBD
!
!  FORM UPPER HESSENBERG (AR,AI)-(RLAMBD,ILAMBD) * I
!  AND INITIAL COMPLEX VECTOR.
!
280  CONTINUE

     MP = 1

     DO I = 1, UK

        DO J = MP, UK
          RM1(I,J) = AR(I,J)
          RM2(I,J) = AI(I,J)
        END DO

        RM1(I,I) = RM1(I,I) - RLAMBD
        RM2(I,I) = RM2(I,I) - ILAMBD
        MP = I
        RV1(I) = EPS3

     END DO
!
!  TRIANGULAR DECOMPOSITION WITH INTERCHANGES, REPLACING ZERO PIVOTS BY EPS3.
!
     DO I = 2, UK

        MP = I - 1

        IF ( PYTHAG ( RM1(I,MP), RM2(I,MP) ) > &
             PYTHAG ( RM1(MP,MP),RM2(MP,MP) ) ) THEN

          DO J = MP, UK
            CALL R8_SWAP ( RM1(I,J), RM1(MP,J) )
            CALL R8_SWAP ( RM2(I,J), RM2(MP,J) )
          END DO

        END IF

        IF ( RM1(MP,MP) == 0.0D+00 .AND. RM2(MP,MP) == 0.0D+00 ) THEN
          RM1(MP,MP) = EPS3
        END IF

        CALL CDIV ( RM1(I,MP), RM2(I,MP), RM1(MP,MP), RM2(MP,MP), X, Y )

        IF ( X /= 0.0D+00 .OR. Y /= 0.0D+00 ) THEN

          DO J = I, UK
            RM1(I,J) = RM1(I,J) - X * RM1(MP,J) + Y * RM2(MP,J)
            RM2(I,J) = RM2(I,J) - X * RM2(MP,J) - Y * RM1(MP,J)
          END DO

        END IF

     END DO

     IF ( RM1(UK,UK) == 0.0D+00 .AND. RM2(UK,UK) == 0.0D+00 ) THEN
       RM1(UK,UK) = EPS3
     END IF

     ITS = 0
!
!  BACK SUBSTITUTION.
!
  660   CONTINUE

    DO II = 1, UK

        I = UK + 1 - II
        X = RV1(I)
        Y = 0.0D+00

        DO J = I+1, UK
          X = X - RM1(I,J) * RV1(J) + RM2(I,J) * RV2(J)
          Y = Y - RM1(I,J) * RV2(J) - RM2(I,J) * RV1(J)
        END DO

        CALL CDIV ( X, Y, RM1(I,I), RM2(I,I), RV1(I), RV2(I) )

     END DO
!
!  ACCEPTANCE TEST FOR EIGENVECTOR AND NORMALIZATION.
!
     ITS = ITS + 1
     NORM = 0.0D+00
     NORMV = 0.0D+00

     DO I = 1, UK
        X = PYTHAG ( RV1(I), RV2(I) )
        IF ( NORMV < X ) THEN
          NORMV = X
          J = I
        END IF
        NORM = NORM + X
     END DO

     IF ( NORM < GROWTO ) GO TO 840
!
!  ACCEPT VECTOR.
!
     X = RV1(J)
     Y = RV2(J)

     DO I = 1, UK
       CALL CDIV ( RV1(I), RV2(I), X, Y, ZR(I,S), ZI(I,S) )
     END DO

     IF ( UK == N ) THEN
       GO TO 940
     END IF

     J = UK + 1
     GO TO 900
!
!  CHOOSE A NEW STARTING VECTOR.
!
  840    CONTINUE

     IF ( ITS < UK ) THEN

       X = UKROOT
       Y = EPS3 / ( X + 1.0D+00 )

       RV1(1) = EPS3
       RV1(2:UK) = Y

       J = UK - ITS + 1
       RV1(J) = RV1(J) - EPS3 * X
       GO TO 660

     END IF
!
!  ERROR: UNACCEPTED EIGENVECTOR.
!
  880    CONTINUE

     J = 1
     IERR = -K
!
!  SET REMAINING VECTOR COMPONENTS TO ZERO.
!
900    CONTINUE

       ZR(J:N,S) = 0.0D+00
       ZI(J:N,S) = 0.0D+00

940    CONTINUE

       S = S + 1

  END DO

  GO TO 1001
!
!  SET ERROR: UNDERESTIMATE OF EIGENVECTOR SPACE REQUIRED.
!
 1000 CONTINUE
  IF ( IERR /= 0 ) IERR = IERR - N
  IF ( IERR == 0 ) IERR = -(2 * N + 1)
 1001 CONTINUE
  M = S - 1
  RETURN
END
SUBROUTINE COMBAK ( N, LOW, IGH, AR, AI, INT, M, ZR, ZI )

!*****************************************************************************80
!
!! COMBAK DETERMINES EIGENVECTORS BY UNDOING THE COMHES TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX GENERAL
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    UPPER HESSENBERG MATRIX DETERMINED BY COMHES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = TO THE ORDER
!    OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) AR(N,IGH), AI(N,IGH), THE MULTIPLIERS WHICH
!    WERE USED IN THE REDUCTION BY COMHES IN THEIR LOWER TRIANGLES BELOW
!    THE SUBDIAGONAL.
!
!    INPUT, INTEGER ( KIND = 4 ) INT(IGH), INFORMATION ON THE ROWS AND
!    COLUMNS INTERCHANGED IN THE REDUCTION BY COMHES.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ZR(N,M), ZI(N,M).  ON INPUT, THE REAL
!    AND IMAGINARY PARTS OF THE EIGENVECTORS TO BE BACK TRANSFORMED.  ON
!    OUTPUT, THE REAL AND IMAGINARY PARTS OF THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,IGH)
  REAL    ( KIND = 8 ) AR(N,IGH)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) INT(IGH)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) ZI(N,M)
  REAL    ( KIND = 8 ) ZR(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF

  LA = IGH - 1

  IF ( IGH - 1 < LOW + 1 ) THEN
    RETURN
  END IF

  DO MM = LOW + 1, LA

     MP = LOW + IGH - MM

     DO I = MP+1, IGH

        XR = AR(I,MP-1)
        XI = AI(I,MP-1)

        IF ( XR /= 0.0D+00 .OR. XI /= 0.0D+00 ) THEN
          ZR(I,1:M) = ZR(I,1:M) + XR * ZR(MP,1:M) - XI * ZI(MP,1:M)
          ZI(I,1:M) = ZI(I,1:M) + XR * ZI(MP,1:M) + XI * ZR(MP,1:M)
       END IF

     END DO

     I = INT(MP)

     IF ( I /= MP ) THEN

       DO J = 1, M
         CALL R8_SWAP ( ZR(I,J), ZR(MP,J) )
         CALL R8_SWAP ( ZI(I,J), ZI(MP,J) )
       END DO

     END IF

  END DO

  RETURN
END
SUBROUTINE COMHES ( N, LOW, IGH, AR, AI, INT )

!*****************************************************************************80
!
!! COMHES TRANSFORMS A COMPLEX GENERAL MATRIX TO UPPER HESSENBERG FORM.
!
!  DISCUSSION:
!
!    GIVEN A COMPLEX GENERAL MATRIX, THIS SUBROUTINE
!    REDUCES A SUBMATRIX SITUATED IN ROWS AND COLUMNS
!    LOW THROUGH IGH TO UPPER HESSENBERG FORM BY
!    STABILIZED ELEMENTARY SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N).  ON INPUT, THE REAL AND
!    IMAGINARY PARTS OF THE COMPLEX INPUT MATRIX.  ON OUTPUT, THE REAL AND
!    IMAGINARY PARTS OF THE HESSENBERG MATRIX.  THE MULTIPLIERS WHICH WERE
!    USED IN THE REDUCTION ARE STORED IN THE REMAINING TRIANGLES UNDER THE
!    HESSENBERG MATRIX.
!
!    OUTPUT, INTEGER ( KIND = 4 ) INT(IGH), INFORMATION ON THE ROWS AND COLUMNS
!    INTERCHANGED IN THE REDUCTION.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) INT(IGH)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) YI
  REAL    ( KIND = 8 ) YR

  LA = IGH - 1

  DO M = LOW + 1, LA

     XR = 0.0D+00
     XI = 0.0D+00
     I = M

     DO J = M, IGH

       IF ( ABS ( AR(J,M-1) ) + ABS ( AI(J,M-1) ) > &
         ABS ( XR ) + ABS ( XI ) ) THEN
         XR = AR(J,M-1)
         XI = AI(J,M-1)
         I = J
       END IF

     END DO

     INT(M) = I
!
!  INTERCHANGE ROWS AND COLUMNS OF AR AND AI.
!
     IF ( I /= M ) THEN

       DO J = M-1, N
         CALL R8_SWAP ( AR(I,J), AR(M,J) )
         CALL R8_SWAP ( AI(I,J), AI(M,J) )
       END DO

       DO J = 1, IGH
         CALL R8_SWAP ( AR(J,I), AR(J,M) )
         CALL R8_SWAP ( AI(J,I), AI(J,M) )
       END DO

     END IF

    IF ( XR /= 0.0D+00 .OR. XI /= 0.0D+00 ) THEN

      DO I = M+1, IGH

        YR = AR(I,M-1)
        YI = AI(I,M-1)

        IF ( YR /= 0.0D+00 .OR. YI /= 0.0D+00 ) THEN

          CALL CDIV ( YR, YI, XR, XI, YR, YI )
          AR(I,M-1) = YR
          AI(I,M-1) = YI

          DO J = M, N
            AR(I,J) = AR(I,J) - YR * AR(M,J) + YI * AI(M,J)
            AI(I,J) = AI(I,J) - YR * AI(M,J) - YI * AR(M,J)
          END DO

          AR(1:IGH,M) = AR(1:IGH,M) + YR * AR(1:IGH,I) - YI * AI(1:IGH,I)
          AI(1:IGH,M) = AI(1:IGH,M) + YR * AI(1:IGH,I) + YI * AR(1:IGH,I)

        END IF

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE COMLR ( N, LOW, IGH, HR, HI, WR, WI, IERR )

!*****************************************************************************80
!
!! COMLR GETS ALL EIGENVALUES OF A COMPLEX UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A COMPLEX UPPER HESSENBERG
!    MATRIX BY THE MODIFIED LR METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) HR(N,N), HI(N,N).  ON INPUT, THE REAL AND
!    IMAGINARY PARTS OF THE COMPLEX UPPER HESSENBERG MATRIX.  THEIR LOWER
!    TRIANGLES BELOW THE SUBDIAGONAL CONTAIN THE MULTIPLIERS WHICH WERE USED
!    IN THE REDUCTION BY COMHES IF PERFORMED.  ON OUTPUT, THE UPPER HESSENBERG
!    PORTIONS OF HR AND HI HAVE BEEN DESTROYED.  THEREFORE, THEY MUST BE
!    SAVED BEFORE CALLING COMLR IF SUBSEQUENT CALCULATION OF EIGENVECTORS
!    IS TO BE PERFORMED.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVALUES.  IF AN ERROR EXIT IS MADE, THE EIGENVALUES SHOULD BE CORRECT
!    FOR INDICES IERR+1,...,N.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE LIMIT OF 30*N ITERATIONS IS EXHAUSTED WHILE THE J-TH
!      EIGENVALUE IS BEING SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM1
  REAL    ( KIND = 8 ) HI(N,N)
  REAL    ( KIND = 8 ) HR(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MM
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) SR
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) YI
  REAL    ( KIND = 8 ) YR
  REAL    ( KIND = 8 ) ZZI
  REAL    ( KIND = 8 ) ZZR

  IERR = 0
!
!  STORE ROOTS ISOLATED BY CBAL.
!
  DO I = 1, N
    IF ( I < LOW .OR. I > IGH ) THEN
      WR(I) = HR(I,I)
      WI(I) = HI(I,I)
    END IF
  END DO

  EN = IGH
  TR = 0.0D+00
  TI = 0.0D+00
  ITN = 30 * N
!
!  SEARCH FOR NEXT EIGENVALUE.
!
  220 CONTINUE

  IF ( EN < LOW ) THEN
    RETURN
  END IF

  ITS = 0
  ENM1 = EN - 1
!
!  LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT.
!
  240 CONTINUE

  DO LL = LOW, EN
     L = EN + LOW - LL
     IF ( L == LOW ) GO TO 300
     TST1 = ABS ( HR(L-1,L-1) ) + ABS ( HI(L-1,L-1) ) + ABS ( HR(L,L) ) &
       + ABS ( HI(L,L) )
     TST2 = TST1 + ABS ( HR(L,L-1) ) + ABS ( HI(L,L-1) )
     IF ( TST2 == TST1) GO TO 300
  END DO
!
!  FORM SHIFT.
!
300 CONTINUE

  IF ( L == EN ) THEN
    GO TO 660
  END IF

  IF ( ITN == 0 ) THEN
    IERR = EN
    RETURN
  END IF

  IF ( ITS == 10 .OR. ITS == 20 ) GO TO 320
  SR = HR(EN,EN)
  SI = HI(EN,EN)
  XR = HR(ENM1,EN) * HR(EN,ENM1) - HI(ENM1,EN) * HI(EN,ENM1)
  XI = HR(ENM1,EN) * HI(EN,ENM1) + HI(ENM1,EN) * HR(EN,ENM1)
  IF ( XR == 0.0D+00 .AND. XI == 0.0D+00 ) GO TO 340
  YR = ( HR(ENM1,ENM1) - SR) / 2.0D+00
  YI = ( HI(ENM1,ENM1) - SI) / 2.0D+00
  CALL CSROOT ( YR**2-YI**2+XR, 2.0D+00*YR*YI+XI, ZZR, ZZI )

  IF ( YR * ZZR + YI * ZZI < 0.0D+00 ) THEN
    ZZR = -ZZR
    ZZI = -ZZI
  END IF

  CALL CDIV ( XR, XI, YR+ZZR, YI+ZZI, XR, XI )
  SR = SR - XR
  SI = SI - XI
  GO TO 340
!
!  FORM EXCEPTIONAL SHIFT.
!
  320 CONTINUE

  SR = ABS ( HR(EN,ENM1) ) + ABS ( HR(ENM1,EN-2) )
  SI = ABS ( HI(EN,ENM1) ) + ABS ( HI(ENM1,EN-2) )

  340 CONTINUE

  DO I = LOW, EN
    HR(I,I) = HR(I,I) - SR
    HI(I,I) = HI(I,I) - SI
  END DO

  TR = TR + SR
  TI = TI + SI
  ITS = ITS + 1
  ITN = ITN - 1
!
!  LOOK FOR TWO CONSECUTIVE SMALL SUB-DIAGONAL ELEMENTS.
!
  XR = ABS ( HR(ENM1,ENM1) ) + ABS ( HI(ENM1,ENM1) )
  YR = ABS ( HR(EN,ENM1) ) + ABS ( HI(EN,ENM1) )
  ZZR = ABS ( HR(EN,EN) ) + ABS ( HI(EN,EN) )

  DO MM = L, ENM1
    M = ENM1 + L - MM
    IF ( M == L ) THEN
      EXIT
    END IF
    YI = YR
    YR = ABS ( HR(M,M-1) ) + ABS ( HI(M,M-1) )
    XI = ZZR
    ZZR = XR
    XR = ABS ( HR(M-1,M-1) ) + ABS ( HI(M-1,M-1) )
    TST1 = ZZR / YI * (ZZR + XR + XI)
    TST2 = TST1 + YR
    IF ( TST2 == TST1 ) THEN
      EXIT
    END IF
  END DO
!
!  TRIANGULAR DECOMPOSITION H=L*R.
!
  DO I = M+1, EN

     XR = HR(I-1,I-1)
     XI = HI(I-1,I-1)
     YR = HR(I,I-1)
     YI = HI(I,I-1)

     IF ( ABS ( XR ) + ABS ( XI ) >= ABS ( YR ) + ABS ( YI ) ) THEN
       GO TO 460
     END IF
!
!  INTERCHANGE ROWS OF HR AND HI.
!
     DO J = I-1, EN
       CALL R8_SWAP ( HR(I-1,J), HR(I,J) )
       CALL R8_SWAP ( HI(I-1,J), HI(I,J) )
     END DO

     CALL CDIV ( XR, XI, YR, YI, ZZR, ZZI )
     WR(I) = 1.0D+00
     GO TO 480

460 CONTINUE

     CALL CDIV ( YR, YI, XR, XI, ZZR, ZZI )
     WR(I) = -1.0D+00

480  CONTINUE

     HR(I,I-1) = ZZR
     HI(I,I-1) = ZZI

     DO J = I, EN
        HR(I,J) = HR(I,J) - ZZR * HR(I-1,J) + ZZI * HI(I-1,J)
        HI(I,J) = HI(I,J) - ZZR * HI(I-1,J) - ZZI * HR(I-1,J)
     END DO

  END DO
!
!  COMPOSITION R*L=H.
!
  DO J = M+1, EN

    XR = HR(J,J-1)
    XI = HI(J,J-1)
    HR(J,J-1) = 0.0D+00
    HI(J,J-1) = 0.0D+00
!
!  INTERCHANGE COLUMNS OF HR AND HI, IF NECESSARY.
!
    IF ( WR(J) > 0.0D+00 ) THEN

      DO I = L, J
        CALL R8_SWAP ( HR(I,J-1), HR(I,J) )
        CALL R8_SWAP ( HI(I,J-1), HI(I,J) )
      END DO

    END IF

    DO I = L, J
      HR(I,J-1) = HR(I,J-1) + XR * HR(I,J) - XI * HI(I,J)
      HI(I,J-1) = HI(I,J-1) + XR * HI(I,J) + XI * HR(I,J)
    END DO

  END DO

  GO TO 240
!
!  A ROOT FOUND.
!
  660 CONTINUE

  WR(EN) = HR(EN,EN) + TR
  WI(EN) = HI(EN,EN) + TI
  EN = ENM1
  GO TO 220
END
SUBROUTINE COMLR2 ( N, LOW, IGH, INT, HR, HI, WR, WI, ZR, ZI, IERR )

!*****************************************************************************80
!
!! COMLR2 GETS EIGENVALUES/VECTORS OF A COMPLEX UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS OF A COMPLEX
!    UPPER HESSENBERG MATRIX BY THE MODIFIED LR METHOD.  THE EIGENVECTORS
!    OF A COMPLEX GENERAL MATRIX CAN ALSO BE FOUND IF COMHES HAS BEEN USED
!    TO REDUCE THIS GENERAL MATRIX TO HESSENBERG FORM.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = N.
!
!    INPUT, INTEGER ( KIND = 4 ) INT(IGH), INFORMATION ON THE ROWS AND COLUMNS
!    INTERCHANGED IN THE REDUCTION BY COMHES, IF PERFORMED.  IF THE
!    EIGENVECTORS OF THE HESSENBERG MATRIX ARE DESIRED, SET INT(J)=J FOR THESE
!    ELEMENTS.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) HR(N,N), HI(N,N).  ON INPUT, THE REAL
!    AND IMAGINARY PARTS OF THE COMPLEX UPPER HESSENBERG MATRIX.  THEIR LOWER
!    TRIANGLES BELOW THE SUBDIAGONAL CONTAIN THE MULTIPLIERS WHICH WERE USED IN
!    THE REDUCTION BY COMHES, IF PERFORMED.  IF THE EIGENVECTORS OF THE
!    HESSENBERG MATRIX ARE DESIRED, THESE ELEMENTS MUST BE SET TO ZERO.  ON
!    OUTPUT, THE UPPER HESSENBERG PORTIONS OF HR AND HI HAVE BEEN DESTROYED,
!    BUT THE LOCATION HR(1,1) CONTAINS THE NORM OF THE TRIANGULARIZED MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVALUES.  IF AN ERROR EXIT IS MADE, THE EIGENVALUES SHOULD BE
!    CORRECT FOR INDICES IERR+1,...,N.
!
!    OUTPUT, REAL ( KIND = 8 ) ZR(N,N), ZI(N,N), THE REAL AND IMAGINARY PARTS
!    OF THE EIGENVECTORS.  THE EIGENVECTORS ARE UNNORMALIZED.  IF AN ERROR EXIT
!    IS MADE, NONE OF THE EIGENVECTORS HAS BEEN FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE LIMIT OF 30*N ITERATIONS IS EXHAUSTED WHILE THE J-TH
!      EIGENVALUE IS BEING SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM1
  REAL    ( KIND = 8 ) HI(N,N)
  REAL    ( KIND = 8 ) HR(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IEND
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) INT(IGH)
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) SR
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) YI
  REAL    ( KIND = 8 ) YR
  REAL    ( KIND = 8 ) ZI(N,N)
  REAL    ( KIND = 8 ) ZR(N,N)
  REAL    ( KIND = 8 ) ZZI
  REAL    ( KIND = 8 ) ZZR

  IERR = 0
!
!  INITIALIZE THE EIGENVECTOR MATRIX.
!
  ZR(1:N,1:N) = 0.0D+00

  DO I = 1, N
    ZR(I,I) = 1.0D+00
  END DO

  ZI(1:N,1:N) = 0.0D+00
!
!  FORM THE MATRIX OF ACCUMULATED TRANSFORMATIONS FROM THE INFORMATION LEFT
!  BY COMHES.
!
  IEND = IGH - LOW - 1

  DO II = 1, IEND

    I = IGH - II

    DO K = I+1, IGH
      ZR(K,I) = HR(K,I-1)
      ZI(K,I) = HI(K,I-1)
    END DO

    J = INT(I)

    IF ( I /= J ) THEN

      DO K = I, IGH
        ZR(I,K) = ZR(J,K)
        ZI(I,K) = ZI(J,K)
        ZR(J,K) = 0.0D+00
        ZI(J,K) = 0.0D+00
      END DO

      ZR(J,I) = 1.0D+00

    END IF

  END DO
!
!  STORE ROOTS ISOLATED BY CBAL.
!
  DO I = 1, N
    IF ( I < LOW .OR. I > IGH ) THEN
      WR(I) = HR(I,I)
      WI(I) = HI(I,I)
    END IF
  END DO

  EN = IGH
  TR = 0.0D+00
  TI = 0.0D+00
  ITN = 30 * N
!
!  SEARCH FOR NEXT EIGENVALUE.
!
220 CONTINUE

  IF ( EN < LOW ) THEN
    GO TO 680
  END IF

  ITS = 0
  ENM1 = EN - 1
!
!  LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT.
!
  240 CONTINUE

  DO LL = LOW, EN

     L = EN + LOW - LL

     IF ( L == LOW ) THEN
       EXIT
     END IF

     TST1 = ABS ( HR(L-1,L-1) ) + ABS ( HI(L-1,L-1) ) + ABS ( HR(L,L) ) &
       + ABS ( HI(L,L) )
     TST2 = TST1 + ABS ( HR(L,L-1) ) + ABS ( HI(L,L-1) )

     IF ( TST2 == TST1 ) THEN
       EXIT
     END IF

  END DO
!
!  FORM SHIFT.
!
  IF ( L == EN ) GO TO 660
  IF ( ITN == 0 ) GO TO 1000
  IF ( ITS == 10 .OR. ITS == 20 ) GO TO 320
  SR = HR(EN,EN)
  SI = HI(EN,EN)
  XR = HR(ENM1,EN) * HR(EN,ENM1) - HI(ENM1,EN) * HI(EN,ENM1)
  XI = HR(ENM1,EN) * HI(EN,ENM1) + HI(ENM1,EN) * HR(EN,ENM1)
  IF ( XR == 0.0D+00 .AND. XI == 0.0D+00 ) GO TO 340
  YR = (HR(ENM1,ENM1) - SR) / 2.0D+00
  YI = (HI(ENM1,ENM1) - SI) / 2.0D+00
  CALL CSROOT ( YR**2-YI**2+XR, 2.0D+00*YR*YI+XI, ZZR, ZZI )

  IF ( YR * ZZR + YI * ZZI < 0.0D+00 ) THEN
    ZZR = -ZZR
    ZZI = -ZZI
  END IF

  CALL CDIV ( XR, XI, YR+ZZR, YI+ZZI, XR, XI )
  SR = SR - XR
  SI = SI - XI
  GO TO 340
!
!  FORM EXCEPTIONAL SHIFT.
!
  320 CONTINUE

  SR = ABS ( HR(EN,ENM1) ) + ABS ( HR(ENM1,EN-2) )
  SI = ABS ( HI(EN,ENM1) ) + ABS ( HI(ENM1,EN-2) )

  340 CONTINUE

  DO I = LOW, EN
    HR(I,I) = HR(I,I) - SR
    HI(I,I) = HI(I,I) - SI
  END DO

  TR = TR + SR
  TI = TI + SI
  ITS = ITS + 1
  ITN = ITN - 1
!
!  LOOK FOR TWO CONSECUTIVE SMALL SUB-DIAGONAL ELEMENTS.
!
  XR = ABS ( HR(ENM1,ENM1) ) + ABS ( HI(ENM1,ENM1) )
  YR = ABS ( HR(EN,ENM1) ) + ABS ( HI(EN,ENM1) )
  ZZR = ABS ( HR(EN,EN) ) + ABS ( HI(EN,EN) )

  DO MM = L, ENM1
     M = ENM1 + L - MM
     IF ( M == L ) THEN
       EXIT
     END IF
     YI = YR
     YR = ABS ( HR(M,M-1) ) + ABS ( HI(M,M-1) )
     XI = ZZR
     ZZR = XR
     XR = ABS ( HR(M-1,M-1) ) + ABS ( HI(M-1,M-1) )
     TST1 = ZZR / YI * (ZZR + XR + XI)
     TST2 = TST1 + YR
     IF ( TST2 == TST1 ) THEN
       EXIT
     END IF
  END DO
!
!  TRIANGULAR DECOMPOSITION H=L*R.
!
  DO I = M+1, EN

     XR = HR(I-1,I-1)
     XI = HI(I-1,I-1)
     YR = HR(I,I-1)
     YI = HI(I,I-1)
     IF ( ABS ( XR ) + ABS ( XI) >= ABS ( YR ) + ABS ( YI ) ) GO TO 460
!
!  INTERCHANGE ROWS OF HR AND HI.
!
     DO J = I-1, N
       CALL R8_SWAP ( HR(I-1,J), HR(I,J) )
       CALL R8_SWAP ( HI(I-1,J), HI(I,J) )
    END DO

     CALL CDIV ( XR, XI, YR, YI, ZZR, ZZI )
     WR(I) = 1.0D+00
     GO TO 480
460  CONTINUE

     CALL CDIV ( YR, YI, XR, XI, ZZR, ZZI )
     WR(I) = -1.0D+00

480  CONTINUE

     HR(I,I-1) = ZZR
     HI(I,I-1) = ZZI

     DO J = I, N
       HR(I,J) = HR(I,J) - ZZR * HR(I-1,J) + ZZI * HI(I-1,J)
       HI(I,J) = HI(I,J) - ZZR * HI(I-1,J) - ZZI * HR(I-1,J)
     END DO

  END DO
!
!  COMPOSITION R*L=H.
!
  DO J = M+1, EN

     XR = HR(J,J-1)
     XI = HI(J,J-1)
     HR(J,J-1) = 0.0D+00
     HI(J,J-1) = 0.0D+00
!
!  INTERCHANGE COLUMNS OF HR, HI, ZR, AND ZI.
!
     IF ( WR(J) > 0.0D+00 ) THEN

       DO I = 1, J
         CALL R8_SWAP ( HR(I,J-1), HR(I,J) )
         CALL R8_SWAP ( HI(I,J-1), HI(I,J) )
       END DO

       DO I = LOW, IGH
         CALL R8_SWAP ( ZR(I,J-1), ZR(I,J) )
         CALL R8_SWAP ( ZI(I,J-1), ZI(I,J) )
       END DO

    END IF

    DO I = 1, J
      HR(I,J-1) = HR(I,J-1) + XR * HR(I,J) - XI * HI(I,J)
      HI(I,J-1) = HI(I,J-1) + XR * HI(I,J) + XI * HR(I,J)
    END DO
!
!  ACCUMULATE TRANSFORMATIONS.
!
    DO I = LOW, IGH
      ZR(I,J-1) = ZR(I,J-1) + XR * ZR(I,J) - XI * ZI(I,J)
      ZI(I,J-1) = ZI(I,J-1) + XR * ZI(I,J) + XI * ZR(I,J)
    END DO

  END DO

  GO TO 240
!
!  A ROOT FOUND.
!
  660 CONTINUE

  HR(EN,EN) = HR(EN,EN) + TR
  WR(EN) = HR(EN,EN)
  HI(EN,EN) = HI(EN,EN) + TI
  WI(EN) = HI(EN,EN)
  EN = ENM1
  GO TO 220
!
!  ALL ROOTS FOUND.
!  BACKSUBSTITUTE TO FIND VECTORS OF UPPER TRIANGULAR FORM.
!
  680 CONTINUE

  NORM = 0.0D+00

  DO I = 1, N
    DO J = I, N
      TR = ABS ( HR(I,J) ) + ABS ( HI(I,J) )
      IF ( TR > NORM ) NORM = TR
    END DO
  END DO

  HR(1,1) = NORM
  IF ( N == 1 ) THEN
    RETURN
  END IF

  IF ( NORM == 0.0D+00 ) THEN
    RETURN
  END IF

  DO NN = 2, N

     EN = N + 2 - NN
     XR = WR(EN)
     XI = WI(EN)
     HR(EN,EN) = 1.0D+00
     HI(EN,EN) = 0.0D+00
     ENM1 = EN - 1

     DO II = 1, ENM1

        I = EN - II
        ZZR = 0.0D+00
        ZZI = 0.0D+00

        DO J = I+1, EN
          ZZR = ZZR + HR(I,J) * HR(J,EN) - HI(I,J) * HI(J,EN)
          ZZI = ZZI + HR(I,J) * HI(J,EN) + HI(I,J) * HR(J,EN)
        END DO

        YR = XR - WR(I)
        YI = XI - WI(I)

        IF ( YR == 0.0D+00 .AND. YI == 0.0D+00 ) THEN

          TST1 = NORM
          YR = TST1

          DO
            YR = 0.01D+00 * YR
            TST2 = NORM + YR
            IF ( TST2 <=  TST1 ) THEN
              EXIT
            END IF
          END DO

        END IF

        CALL CDIV ( ZZR, ZZI, YR, YI, HR(I,EN), HI(I,EN) )
!
!  OVERFLOW CONTROL.
!
        TR = ABS ( HR(I,EN) ) + ABS ( HI(I,EN) )

        IF ( TR /= 0.0D+00 ) THEN

          TST1 = TR
          TST2 = TST1 + 1.0D+00 / TST1

          IF ( TST2 <= TST1 ) THEN

            HR(I:EN,EN) = HR(I:EN,EN) / TR
            HI(I:EN,EN) = HI(I:EN,EN) / TR

          END IF

        END IF

      END DO

  END DO
!
!  END BACKSUBSTITUTION.
!
  ENM1 = N - 1
!
!  VECTORS OF ISOLATED ROOTS.
!
  DO I = 1, N - 1

    IF ( I < LOW .OR. I > IGH ) THEN

      ZR(I,I+1:N) = HR(I,I+1:N)
      ZI(I,I+1:N) = HI(I,I+1:N)

    END IF

  END DO
!
!  MULTIPLY BY TRANSFORMATION MATRIX TO GIVE VECTORS OF ORIGINAL FULL MATRIX.
!
  DO JJ = LOW, N - 1

    J = N + LOW - JJ
    M = MIN ( J, IGH )

    DO I = LOW, IGH
      ZZR = 0.0D+00
      ZZI = 0.0D+00
      DO K = LOW, M
        ZZR = ZZR + ZR(I,K) * HR(K,J) - ZI(I,K) * HI(K,J)
        ZZI = ZZI + ZR(I,K) * HI(K,J) + ZI(I,K) * HR(K,J)
      END DO
      ZR(I,J) = ZZR
      ZI(I,J) = ZZI
    END DO

  END DO

  RETURN
!
!  SET ERROR: ALL EIGENVALUES HAVE NOT CONVERGED AFTER 30*N ITERATIONS.
!
 1000 CONTINUE

  IERR = EN
  RETURN
END
SUBROUTINE COMQR ( N, LOW, IGH, HR, HI, WR, WI, IERR )

!*****************************************************************************80
!
!! COMQR GETS EIGENVALUES OF A COMPLEX UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A COMPLEX
!    UPPER HESSENBERG MATRIX BY THE QR METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) HR(N,N), HI(N,N).  ON INPUT, THE REAL
!    AND IMAGINARY PARTS OF THE COMPLEX UPPER HESSENBERG MATRIX.  THEIR LOWER
!    TRIANGLES BELOW THE SUBDIAGONAL CONTAIN INFORMATION ABOUT THE UNITARY
!    TRANSFORMATIONS USED IN THE REDUCTION BY CORTH, IF PERFORMED.  ON OUTPUT,
!    THE UPPER HESSENBERG PORTIONS OF HR AND HI HAVE BEEN DESTROYED.
!    THEREFORE, THEY MUST BE SAVED BEFORE CALLING COMQR IF SUBSEQUENT
!    CALCULATION OF EIGENVECTORS IS TO BE PERFORMED.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVALUES.  IF AN ERROR EXIT IS MADE, THE EIGENVALUES SHOULD BE
!    CORRECT FOR INDICES IERR+1,...,N.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE LIMIT OF 30*N ITERATIONS IS EXHAUSTED WHILE THE J-TH
!       EIGENVALUE IS BEING SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM1
  REAL    ( KIND = 8 ) HI(N,N)
  REAL    ( KIND = 8 ) HR(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LOW
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) SR
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) YI
  REAL    ( KIND = 8 ) YR
  REAL    ( KIND = 8 ) ZZI
  REAL    ( KIND = 8 ) ZZR

  IERR = 0
!
!  CREATE REAL SUBDIAGONAL ELEMENTS.
!
  L = LOW + 1

  DO I = L, IGH

     LL = MIN ( I+1, IGH )

     IF ( HI(I,I-1) /= 0.0D+00 ) THEN

     NORM = PYTHAG ( HR(I,I-1), HI(I,I-1) )
     YR = HR(I,I-1) / NORM
     YI = HI(I,I-1) / NORM
     HR(I,I-1) = NORM
     HI(I,I-1) = 0.0D+00

     DO J = I, IGH
       SI = YR * HI(I,J) - YI * HR(I,J)
       HR(I,J) = YR * HR(I,J) + YI * HI(I,J)
       HI(I,J) = SI
     END DO

     DO J = LOW, LL
       SI = YR * HI(J,I) + YI * HR(J,I)
       HR(J,I) = YR * HR(J,I) - YI * HI(J,I)
       HI(J,I) = SI
     END DO

    END IF

  END DO
!
!  STORE ROOTS ISOLATED BY CBAL.
!
  DO I = 1, N
    IF ( I < LOW .OR. I > IGH ) THEN
      WR(I) = HR(I,I)
      WI(I) = HI(I,I)
    END IF
  END DO

  EN = IGH
  TR = 0.0D+00
  TI = 0.0D+00
  ITN = 30 * N
!
!  SEARCH FOR NEXT EIGENVALUE.
!
  220 CONTINUE

  IF ( EN < LOW ) THEN
    RETURN
  END IF

  ITS = 0
  ENM1 = EN - 1
!
!  LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT.
!
  240 CONTINUE

  DO LL = LOW, EN
    L = EN + LOW - LL
    IF ( L == LOW ) THEN
      EXIT
    END IF
    TST1 = ABS ( HR(L-1,L-1) ) + ABS ( HI(L-1,L-1) ) + ABS ( HR(L,L) ) &
      + ABS ( HI(L,L) )
    TST2 = TST1 + ABS ( HR(L,L-1) )
    IF ( TST2 == TST1 ) THEN
      EXIT
    END IF
  END DO
!
!  FORM SHIFT.
!
  IF ( L == EN ) THEN
    GO TO 660
  END IF

  IF ( ITN == 0 ) GO TO 1000

  IF ( ITS == 10 .OR. ITS == 20 ) GO TO 320
  SR = HR(EN,EN)
  SI = HI(EN,EN)
  XR = HR(ENM1,EN) * HR(EN,ENM1)
  XI = HI(ENM1,EN) * HR(EN,ENM1)
  IF ( XR == 0.0D+00 .AND. XI == 0.0D+00 ) GO TO 340
  YR = (HR(ENM1,ENM1) - SR) / 2.0D+00
  YI = (HI(ENM1,ENM1) - SI) / 2.0D+00

  CALL CSROOT ( YR**2-YI**2+XR, 2.0D+00*YR*YI+XI, ZZR, ZZI )

  IF ( YR * ZZR + YI * ZZI < 0.0D+00 ) THEN
    ZZR = -ZZR
    ZZI = -ZZI
  END IF

  CALL CDIV ( XR, XI, YR+ZZR, YI+ZZI, XR, XI )
  SR = SR - XR
  SI = SI - XI
  GO TO 340
!
!  FORM EXCEPTIONAL SHIFT.
!
320 CONTINUE

  SR = ABS ( HR(EN,ENM1) ) + ABS ( HR(ENM1,EN-2) )
  SI = 0.0D+00

340 CONTINUE

  DO I = LOW, EN
    HR(I,I) = HR(I,I) - SR
    HI(I,I) = HI(I,I) - SI
  END DO

  TR = TR + SR
  TI = TI + SI
  ITS = ITS + 1
  ITN = ITN - 1
!
!  REDUCE TO TRIANGLE (ROWS).
!
  DO I = L+1, EN

     SR = HR(I,I-1)
     HR(I,I-1) = 0.0D+00
     NORM = PYTHAG ( PYTHAG ( HR(I-1,I-1), HI(I-1,I-1) ), SR )
     XR = HR(I-1,I-1) / NORM
     WR(I-1) = XR
     XI = HI(I-1,I-1) / NORM
     WI(I-1) = XI
     HR(I-1,I-1) = NORM
     HI(I-1,I-1) = 0.0D+00
     HI(I,I-1) = SR / NORM

     DO J = I, EN
        YR = HR(I-1,J)
        YI = HI(I-1,J)
        ZZR = HR(I,J)
        ZZI = HI(I,J)
        HR(I-1,J) = XR * YR + XI * YI + HI(I,I-1) * ZZR
        HI(I-1,J) = XR * YI - XI * YR + HI(I,I-1) * ZZI
        HR(I,J) = XR * ZZR - XI * ZZI - HI(I,I-1) * YR
        HI(I,J) = XR * ZZI + XI * ZZR - HI(I,I-1) * YI
    END DO

  END DO

  SI = HI(EN,EN)

  IF ( SI /= 0.0D+00 ) THEN
    NORM = PYTHAG ( HR(EN,EN), SI )
    SR = HR(EN,EN) / NORM
    SI = SI / NORM
    HR(EN,EN) = NORM
    HI(EN,EN) = 0.0D+00
  END IF
!
!  INVERSE OPERATION (COLUMNS).
!
  DO J = L+1, EN

     XR = WR(J-1)
     XI = WI(J-1)

     DO I = L, J

        YR = HR(I,J-1)
        YI = 0.0D+00
        ZZR = HR(I,J)
        ZZI = HI(I,J)
        IF ( I /= J ) THEN
          YI = HI(I,J-1)
          HI(I,J-1) = XR * YI + XI * YR + HI(J,J-1) * ZZI
        END IF
        HR(I,J-1) = XR * YR - XI * YI + HI(J,J-1) * ZZR
        HR(I,J) = XR * ZZR + XI * ZZI - HI(J,J-1) * YR
        HI(I,J) = XR * ZZI - XI * ZZR - HI(J,J-1) * YI

     END DO

  END DO

  IF ( SI /= 0.0D+00 ) THEN

    DO I = L, EN
      YR = HR(I,EN)
      YI = HI(I,EN)
      HR(I,EN) = SR * YR - SI * YI
      HI(I,EN) = SR * YI + SI * YR
    END DO

  END IF

  GO TO 240
!
!  A ROOT FOUND.
!
660 CONTINUE

  WR(EN) = HR(EN,EN) + TR
  WI(EN) = HI(EN,EN) + TI
  EN = ENM1
  GO TO 220
!
!  SET ERROR: ALL EIGENVALUES HAVE NOT CONVERGED AFTER 30*N ITERATIONS.
!
1000 CONTINUE

  IERR = EN
  RETURN
END
SUBROUTINE COMQR2 ( N, LOW, IGH, ORTR, ORTI, HR, HI, WR, WI, ZR, ZI, IERR )

!*****************************************************************************80
!
!! COMQR2 GETS EIGENVALUES/VECTORS OF A COMPLEX UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
!    OF A COMPLEX UPPER HESSENBERG MATRIX BY THE QR
!    METHOD.  THE EIGENVECTORS OF A COMPLEX GENERAL MATRIX
!    CAN ALSO BE FOUND IF CORTH HAS BEEN USED TO REDUCE
!    THIS GENERAL MATRIX TO HESSENBERG FORM.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ORTR(N), ORTI(N).  ON INPUT, INFORMATION ABOUT THE
!    UNITARY TRANSFORMATIONS USED IN THE REDUCTION BY CORTH, IF PERFORMED.
!    IF THE EIGENVECTORS OF THE HESSENBERG MATRIX ARE DESIRED, SET ORTR(J) AND
!    ORTI(J) TO 0.0D+00 FOR THESE ELEMENTS.  ON OUTPUT, THESE ARRAYS
!    HAVE BEEN OVERWRITTEN.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) HR(N,N), HI(N,N).  ON INPUT, THE REAL AND IMAGINARY
!    PARTS OF THE COMPLEX UPPER HESSENBERG MATRIX.  THEIR LOWER TRIANGLES
!    BELOW THE SUBDIAGONAL CONTAIN FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS WHICH WERE USED IN THE REDUCTION BY CORTH, IF PERFORMED.
!    IF THE EIGENVECTORS OF THE HESSENBERG MATRIX ARE DESIRED, THESE ELEMENTS
!    MAY BE ARBITRARY.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVALUES.  IF AN ERROR EXIT IS MADE, THE EIGENVALUES SHOULD BE
!    CORRECT FOR INDICES IERR+1,...,N.
!
!    OUTPUT, REAL ( KIND = 8 ) ZR(N,N), ZI(N,N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVECTORS.  THE EIGENVECTORS ARE UNNORMALIZED.  IF AN ERROR EXIT
!    IS MADE, NONE OF THE EIGENVECTORS HAS BEEN FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE LIMIT OF 30*N ITERATIONS IS EXHAUSTED WHILE THE J-TH
!      EIGENVALUE IS BEING SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM1
  REAL    ( KIND = 8 ) HI(N,N)
  REAL    ( KIND = 8 ) HR(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IEND
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) ORTI(IGH)
  REAL    ( KIND = 8 ) ORTR(IGH)
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) SR
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) YI
  REAL    ( KIND = 8 ) YR
  REAL    ( KIND = 8 ) ZI(N,N)
  REAL    ( KIND = 8 ) ZR(N,N)
  REAL    ( KIND = 8 ) ZZI
  REAL    ( KIND = 8 ) ZZR

  IERR = 0
!
!  INITIALIZE EIGENVECTOR MATRIX.
!
  ZR(1:N,1:N) = 0.0D+00

  DO I = 1, N
    ZR(I,I) = 1.0D+00
  END DO

  ZI(1:N,1:N) = 0.0D+00
!
!  FORM THE MATRIX OF ACCUMULATED TRANSFORMATIONS FROM THE INFORMATION
!  LEFT BY CORTH.
!
  IEND = IGH - LOW - 1
  IF ( IEND ) 180, 150, 105

105 CONTINUE

  DO II = 1, IEND

     I = IGH - II
     IF ( ORTR(I) == 0.0D+00 .AND. ORTI(I) == 0.0D+00 ) GO TO 140
     IF ( HR(I,I-1) == 0.0D+00 .AND. HI(I,I-1) == 0.0D+00 ) GO TO 140
!
!  NORM BELOW IS NEGATIVE OF H FORMED IN CORTH.
!
     NORM = HR(I,I-1) * ORTR(I) + HI(I,I-1) * ORTI(I)

     DO K = I+1, IGH
       ORTR(K) = HR(K,I-1)
       ORTI(K) = HI(K,I-1)
     END DO

     DO J = I, IGH

        SR = 0.0D+00
        SI = 0.0D+00

        DO K = I, IGH
          SR = SR + ORTR(K) * ZR(K,J) + ORTI(K) * ZI(K,J)
          SI = SI + ORTR(K) * ZI(K,J) - ORTI(K) * ZR(K,J)
        END DO

        SR = SR / NORM
        SI = SI / NORM

        DO K = I, IGH
          ZR(K,J) = ZR(K,J) + SR * ORTR(K) - SI * ORTI(K)
          ZI(K,J) = ZI(K,J) + SR * ORTI(K) + SI * ORTR(K)
        END DO

      END DO

140 CONTINUE

  END DO
!
!  CREATE REAL SUBDIAGONAL ELEMENTS.
!
150 CONTINUE

  L = LOW + 1

  DO I = L, IGH

     LL = MIN ( I+1, IGH )

     IF ( HI(I,I-1) == 0.0D+00 ) THEN
       GO TO 170
     END IF

     NORM = PYTHAG ( HR(I,I-1), HI(I,I-1) )
     YR = HR(I,I-1) / NORM
     YI = HI(I,I-1) / NORM
     HR(I,I-1) = NORM
     HI(I,I-1) = 0.0D+00

     DO J = I, N
       SI = YR * HI(I,J) - YI * HR(I,J)
       HR(I,J) = YR * HR(I,J) + YI * HI(I,J)
       HI(I,J) = SI
     END DO

     DO J = 1, LL
       SI = YR * HI(J,I) + YI * HR(J,I)
       HR(J,I) = YR * HR(J,I) - YI * HI(J,I)
       HI(J,I) = SI
     END DO

     DO J = LOW, IGH
       SI = YR * ZI(J,I) + YI * ZR(J,I)
       ZR(J,I) = YR * ZR(J,I) - YI * ZI(J,I)
       ZI(J,I) = SI
     END DO

170 CONTINUE

  END DO
!
!  STORE ROOTS ISOLATED BY CBAL.
!
180 CONTINUE

  DO I = 1, N
    IF ( I < LOW .OR. I > IGH) THEN
      WR(I) = HR(I,I)
      WI(I) = HI(I,I)
    END IF
  END DO

  EN = IGH
  TR = 0.0D+00
  TI = 0.0D+00
  ITN = 30 * N
!
!  SEARCH FOR NEXT EIGENVALUE.
!
220 CONTINUE

  IF ( EN < LOW ) GO TO 680
  ITS = 0
  ENM1 = EN - 1
!
!  LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT.
!
240 CONTINUE

  DO LL = LOW, EN
    L = EN + LOW - LL
    IF ( L == LOW ) THEN
      EXIT
    END IF
    TST1 = ABS ( HR(L-1,L-1) ) + ABS ( HI(L-1,L-1) ) + ABS ( HR(L,L) ) &
      + ABS ( HI(L,L) )
    TST2 = TST1 + ABS ( HR(L,L-1) )
    IF ( TST2 == TST1 ) THEN
      EXIT
    END IF
  END DO
!
!  FORM SHIFT.
!
  IF ( L == EN ) GO TO 660
  IF ( ITN == 0 ) GO TO 1000
  IF ( ITS == 10 .OR. ITS == 20 ) GO TO 320
  SR = HR(EN,EN)
  SI = HI(EN,EN)
  XR = HR(ENM1,EN) * HR(EN,ENM1)
  XI = HI(ENM1,EN) * HR(EN,ENM1)
  IF ( XR == 0.0D+00 .AND. XI == 0.0D+00 ) GO TO 340
  YR = ( HR(ENM1,ENM1) - SR ) / 2.0D+00
  YI = ( HI(ENM1,ENM1) - SI ) / 2.0D+00

  CALL CSROOT ( YR**2-YI**2+XR, 2.0D+00*YR*YI+XI, ZZR, ZZI )

  IF ( YR * ZZR + YI * ZZI < 0.0D+00 ) THEN
    ZZR = -ZZR
    ZZI = -ZZI
  END IF

  CALL CDIV ( XR, XI, YR+ZZR, YI+ZZI, XR, XI )
  SR = SR - XR
  SI = SI - XI
  GO TO 340
!
!  FORM EXCEPTIONAL SHIFT.
!
320 CONTINUE

  SR = ABS ( HR(EN,ENM1) ) + ABS ( HR(ENM1,EN-2) )
  SI = 0.0D+00

340 CONTINUE

  DO I = LOW, EN
    HR(I,I) = HR(I,I) - SR
    HI(I,I) = HI(I,I) - SI
  END DO

  TR = TR + SR
  TI = TI + SI
  ITS = ITS + 1
  ITN = ITN - 1
!
!  REDUCE TO TRIANGLE (ROWS).
!
  DO I = L+1, EN

     SR = HR(I,I-1)
     HR(I,I-1) = 0.0D+00
     NORM = PYTHAG ( PYTHAG ( HR(I-1,I-1), HI(I-1,I-1) ), SR )
     XR = HR(I-1,I-1) / NORM
     WR(I-1) = XR
     XI = HI(I-1,I-1) / NORM
     WI(I-1) = XI
     HR(I-1,I-1) = NORM
     HI(I-1,I-1) = 0.0D+00
     HI(I,I-1) = SR / NORM

     DO J = I, N
        YR = HR(I-1,J)
        YI = HI(I-1,J)
        ZZR = HR(I,J)
        ZZI = HI(I,J)
        HR(I-1,J) = XR * YR + XI * YI + HI(I,I-1) * ZZR
        HI(I-1,J) = XR * YI - XI * YR + HI(I,I-1) * ZZI
        HR(I,J) = XR * ZZR - XI * ZZI - HI(I,I-1) * YR
        HI(I,J) = XR * ZZI + XI * ZZR - HI(I,I-1) * YI
     END DO

  END DO

  SI = HI(EN,EN)

  IF ( SI /= 0.0D+00 ) THEN

    NORM = PYTHAG ( HR(EN,EN), SI )
    SR = HR(EN,EN) / NORM
    SI = SI / NORM
    HR(EN,EN) = NORM
    HI(EN,EN) = 0.0D+00

    DO J = EN+1, N
      YR = HR(EN,J)
      YI = HI(EN,J)
      HR(EN,J) = SR * YR + SI * YI
      HI(EN,J) = SR * YI - SI * YR
    END DO

  END IF
!
!  INVERSE OPERATION (COLUMNS).
!
  DO J = L+1, EN

     XR = WR(J-1)
     XI = WI(J-1)

     DO I = 1, J

       YR = HR(I,J-1)
       YI = 0.0D+00
       ZZR = HR(I,J)
       ZZI = HI(I,J)

       IF ( I /= J ) THEN
         YI = HI(I,J-1)
         HI(I,J-1) = XR * YI + XI * YR + HI(J,J-1) * ZZI
       END IF

       HR(I,J-1) = XR * YR - XI * YI + HI(J,J-1) * ZZR
       HR(I,J) = XR * ZZR + XI * ZZI - HI(J,J-1) * YR
       HI(I,J) = XR * ZZI - XI * ZZR - HI(J,J-1) * YI

     END DO

     DO I = LOW, IGH
       YR = ZR(I,J-1)
       YI = ZI(I,J-1)
       ZZR = ZR(I,J)
       ZZI = ZI(I,J)
       ZR(I,J-1) = XR * YR - XI * YI + HI(J,J-1) * ZZR
       ZI(I,J-1) = XR * YI + XI * YR + HI(J,J-1) * ZZI
       ZR(I,J) = XR * ZZR + XI * ZZI - HI(J,J-1) * YR
       ZI(I,J) = XR * ZZI - XI * ZZR - HI(J,J-1) * YI
     END DO

  END DO

  IF ( SI /= 0.0D+00 ) THEN

    DO I = 1, EN
      YR = HR(I,EN)
      YI = HI(I,EN)
      HR(I,EN) = SR * YR - SI * YI
      HI(I,EN) = SR * YI + SI * YR
    END DO

    DO I = LOW, IGH
      YR = ZR(I,EN)
      YI = ZI(I,EN)
      ZR(I,EN) = SR * YR - SI * YI
      ZI(I,EN) = SR * YI + SI * YR
    END DO

  END IF

  GO TO 240
!
!  A ROOT FOUND.
!
660 CONTINUE

  HR(EN,EN) = HR(EN,EN) + TR
  WR(EN) = HR(EN,EN)
  HI(EN,EN) = HI(EN,EN) + TI
  WI(EN) = HI(EN,EN)
  EN = ENM1
  GO TO 220
!
!  ALL ROOTS FOUND.
!  BACKSUBSTITUTE TO FIND VECTORS OF UPPER TRIANGULAR FORM.
!
680 CONTINUE

  NORM = 0.0D+00

  DO I = 1, N
    DO J = I, N
      TR = ABS ( HR(I,J) ) + ABS ( HI(I,J) )
      NORM = MAX ( NORM, TR )
    END DO
  END DO

  IF ( N == 1 ) THEN
    RETURN
  END IF

  IF ( NORM == 0.0D+00 ) THEN
    RETURN
  END IF

  DO NN = 2, N

     EN = N + 2 - NN
     XR = WR(EN)
     XI = WI(EN)
     HR(EN,EN) = 1.0D+00
     HI(EN,EN) = 0.0D+00
     ENM1 = EN - 1

     DO II = 1, ENM1

        I = EN - II
        ZZR = 0.0D+00
        ZZI = 0.0D+00

        DO J = I+1, EN
          ZZR = ZZR + HR(I,J) * HR(J,EN) - HI(I,J) * HI(J,EN)
          ZZI = ZZI + HR(I,J) * HI(J,EN) + HI(I,J) * HR(J,EN)
        END DO

        YR = XR - WR(I)
        YI = XI - WI(I)

        IF ( YR == 0.0D+00 .AND. YI == 0.0D+00 ) THEN

           TST1 = NORM
           YR = TST1
           DO
             YR = 0.01D+00 * YR
             TST2 = NORM + YR
             IF ( TST2 <= TST1 ) THEN
               EXIT
             END IF
           END DO

        END IF

        CALL CDIV ( ZZR, ZZI, YR, YI, HR(I,EN), HI(I,EN) )
!
!  OVERFLOW CONTROL.
!
        TR = ABS ( HR(I,EN) ) + ABS ( HI(I,EN) )

        IF ( TR /= 0.0D+00 ) THEN

          TST1 = TR
          TST2 = TST1 + 1.0D+00 / TST1

          IF ( TST2 <= TST1 ) THEN

            DO J = I, EN
              HR(J,EN) = HR(J,EN)/TR
              HI(J,EN) = HI(J,EN)/TR
            END DO

          END IF

       END IF

     END DO

  END DO
!
!  END BACKSUBSTITUTION.
!
  ENM1 = N - 1
!
!  VECTORS OF ISOLATED ROOTS.
!
  DO I = 1, N - 1

    IF ( I < LOW .OR. I > IGH ) THEN

      DO J = I+1, N
        ZR(I,J) = HR(I,J)
        ZI(I,J) = HI(I,J)
      END DO

    END IF

  END DO
!
!  MULTIPLY BY TRANSFORMATION MATRIX TO GIVE VECTORS OF ORIGINAL FULL MATRIX.
!
  DO JJ = LOW, N - 1

     J = N + LOW - JJ
     M = MIN ( J, IGH )

     DO I = LOW, IGH

        ZZR = 0.0D+00
        ZZI = 0.0D+00
        DO K = LOW, M
          ZZR = ZZR + ZR(I,K) * HR(K,J) - ZI(I,K) * HI(K,J)
          ZZI = ZZI + ZR(I,K) * HI(K,J) + ZI(I,K) * HR(K,J)
        END DO

        ZR(I,J) = ZZR
        ZI(I,J) = ZZI

      END DO

  END DO

  RETURN
!
!  SET ERROR: ALL EIGENVALUES HAVE NOT CONVERGED AFTER 30*N ITERATIONS.
!
1000 CONTINUE

  IERR = EN
  RETURN
END
SUBROUTINE CORTB ( N, LOW, IGH, AR, AI, ORTR, ORTI, M, ZR, ZI )

!*****************************************************************************80
!
!! CORTB DETERMINES EIGENVECTORS BY UNDOING THE CORTH TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX GENERAL
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    UPPER HESSENBERG MATRIX DETERMINED BY CORTH.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH TO THE ORDER
!    OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) AR(N,IGH), AI(N,IGH), INFORMATION ABOUT THE UNITARY
!    TRANSFORMATIONS USED IN THE REDUCTION BY CORTH IN THEIR STRICT LOWER
!    TRIANGLES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ORTR(IGH), ORTI(IGH).  ON INPUT, FURTHER INFORMATION
!    ABOUT THE TRANSFORMATIONS USED IN THE REDUCTION BY CORTH.  ON OUTPUT,
!    ORTR AND ORTI HAVE BEEN FURTHER ALTERED.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF COLUMNS OF ZR AND ZI TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ZR(N,M), ZI(N,M).  ON INPUT, THE REAL AND IMAGINARY
!    PARTS OF THE EIGENVECTORS TO BE BACK TRANSFORMED.  ON OUTPUT, THE REAL
!    AND IMAGINARY PARTS OF THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,IGH)
  REAL    ( KIND = 8 ) AR(N,IGH)
  REAL    ( KIND = 8 ) GI
  REAL    ( KIND = 8 ) GR
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) ORTI(IGH)
  REAL    ( KIND = 8 ) ORTR(IGH)
  REAL    ( KIND = 8 ) ZI(N,M)
  REAL    ( KIND = 8 ) ZR(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF

  LA = IGH - 1

  IF ( IGH - 1 < LOW + 1 ) THEN
    RETURN
  END IF

  DO MM = LOW + 1, LA

    MP = LOW + IGH - MM

    IF ( AR(MP,MP-1) /= 0.0D+00 .OR. AI(MP,MP-1) /= 0.0D+00 ) THEN

      H = AR(MP,MP-1) * ORTR(MP) + AI(MP,MP-1) * ORTI(MP)

      ORTR(MP+1:IGH) = AR(MP+1:IGH,MP-1)
      ORTI(MP+1:IGH) = AI(MP+1:IGH,MP-1)

      DO J = 1, M

        GR = ( DOT_PRODUCT ( ORTR(MP:IGH), ZR(MP:IGH,J) ) &
             + DOT_PRODUCT ( ORTI(MP:IGH), ZI(MP:IGH,J) ) ) / H

        GI = ( DOT_PRODUCT ( ORTR(MP:IGH), ZI(MP:IGH,J) ) &
             - DOT_PRODUCT ( ORTI(MP:IGH), ZR(MP:IGH,J) ) ) / H

        DO I = MP, IGH
          ZR(I,J) = ZR(I,J) + GR * ORTR(I) - GI * ORTI(I)
          ZI(I,J) = ZI(I,J) + GR * ORTI(I) + GI * ORTR(I)
        END DO

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE CORTH ( N, LOW, IGH, AR, AI, ORTR, ORTI )

!*****************************************************************************80
!
!! CORTH TRANSFORMS A COMPLEX GENERAL MATRIX TO UPPER HESSENBERG FORM.
!
!  DISCUSSION:
!
!    GIVEN A COMPLEX GENERAL MATRIX, THIS SUBROUTINE
!    REDUCES A SUBMATRIX SITUATED IN ROWS AND COLUMNS
!    LOW THROUGH IGH TO UPPER HESSENBERG FORM BY
!    UNITARY SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE CBAL.  IF CBAL IS NOT USED, SET LOW = 1 AND IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N).  ON INPUT, THE REAL AND IMAGINARY
!    PARTS OF THE COMPLEX INPUT MATRIX.  ON OUTPUT, THE REAL AND IMAGINARY
!    PARTS OF THE HESSENBERG MATRIX.  INFORMATION ABOUT THE UNITARY
!    TRANSFORMATIONS USED IN THE REDUCTION IS STORED IN THE REMAINING
!    TRIANGLES UNDER THE HESSENBERG MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) ORTR(IGH), ORTI(IGH), FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) FI
  REAL    ( KIND = 8 ) FR
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) M,MP,LOW
  REAL    ( KIND = 8 ) ORTI(IGH)
  REAL    ( KIND = 8 ) ORTR(IGH)
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) SCALE

  LA = IGH - 1

  IF ( IGH - 1 < LOW + 1 ) THEN
    RETURN
  END IF

  DO M = LOW + 1, LA

    H = 0.0D+00
    ORTR(M) = 0.0D+00
    ORTI(M) = 0.0D+00
    SCALE = 0.0D+00
!
!  SCALE COLUMN.
!
    DO I = M, IGH
      SCALE = SCALE + ABS ( AR(I,M-1) ) + ABS ( AI(I,M-1) )
    END DO

    IF ( SCALE == 0.0D+00 ) THEN
      CYCLE
    END IF

    MP = M + IGH

    DO II = M, IGH
      I = MP - II
      ORTR(I) = AR(I,M-1) / SCALE
      ORTI(I) = AI(I,M-1) / SCALE
      H = H + ORTR(I) * ORTR(I) + ORTI(I) * ORTI(I)
    END DO

    G = SQRT ( H )
    F = PYTHAG ( ORTR(M), ORTI(M) )

    IF ( F /= 0.0D+00 ) THEN
      H = H + F * G
      G = G / F
      ORTR(M) = ( 1.0D+00 + G ) * ORTR(M)
      ORTI(M) = ( 1.0D+00 + G ) * ORTI(M)
    ELSE
      ORTR(M) = G
      AR(M,M-1) = SCALE
    END IF
!
!  FORM (I-(U*UT)/H) * A.
!
    DO J = M, N

      FR = 0.0D+00
      FI = 0.0D+00

      DO II = M, IGH
        I = MP - II
        FR = FR + ORTR(I) * AR(I,J) + ORTI(I) * AI(I,J)
        FI = FI + ORTR(I) * AI(I,J) - ORTI(I) * AR(I,J)
      END DO

      FR = FR / H
      FI = FI / H

      AR(M:IGH,J) = AR(M:IGH,J) - FR * ORTR(M:IGH) + FI * ORTI(M:IGH)
      AI(M:IGH,J) = AI(M:IGH,J) - FR * ORTI(M:IGH) - FI * ORTR(M:IGH)

    END DO
!
!  FORM (I-(U*UT)/H) * A * (I-(U*UT)/H)
!
    DO I = 1, IGH

      FR = 0.0D+00
      FI = 0.0D+00

      DO JJ = M, IGH
        J = MP - JJ
        FR = FR + ORTR(J) * AR(I,J) - ORTI(J) * AI(I,J)
        FI = FI + ORTR(J) * AI(I,J) + ORTI(J) * AR(I,J)
      END DO

      FR = FR / H
      FI = FI / H

      AR(I,M:IGH) = AR(I,M:IGH) - FR * ORTR(M:IGH) - FI * ORTI(M:IGH)
      AI(I,M:IGH) = AI(I,M:IGH) + FR * ORTI(M:IGH) - FI * ORTR(M:IGH)

    END DO

    ORTR(M) = SCALE * ORTR(M)
    ORTI(M) = SCALE * ORTI(M)
    AR(M,M-1) = - G * AR(M,M-1)
    AI(M,M-1) = - G * AI(M,M-1)

  END DO

  RETURN
END
SUBROUTINE CSROOT ( XR, XI, YR, YI )

!*****************************************************************************80
!
!! CSROOT COMPUTES THE COMPLEX SQUARE ROOT OF A COMPLEX QUANTITY.
!
!  DISCUSSION:
!
!    THE BRANCH OF THE SQUARE FUNCTION IS CHOSEN SO THAT
!      YR >= 0.0D+00
!    AND
!      SIGN ( YI ) == SIGN ( XI )
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, REAL ( KIND = 8 ) XR, XI, THE REAL AND IMAGINARY PARTS OF THE QUANTITY
!    WHOSE SQUARE ROOT IS DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) YR, YI, THE REAL AND IMAGINARY PARTS OF THE SQUARE ROOT.
!
  IMPLICIT NONE

  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) XI
  REAL    ( KIND = 8 ) XR
  REAL    ( KIND = 8 ) YI
  REAL    ( KIND = 8 ) YR

  TR = XR
  TI = XI
  S = SQRT ( 0.5D+00 * ( PYTHAG ( TR, TI ) + ABS ( TR ) ) )

  IF ( TR >= 0.0D+00 ) YR = S
  IF ( TI < 0.0D+00 ) S = -S
  IF ( TR <= 0.0D+00 ) YI = S

  IF ( TR < 0.0D+00 ) THEN
    YR = 0.5D+00 * ( TI / YI )
  ELSE IF ( TR > 0.0D+00 ) THEN
    YI = 0.5D+00 * ( TI / YR )
  END IF

  RETURN
END
SUBROUTINE ELMBAK ( N, LOW, IGH, A, IND, M, Z )

!*****************************************************************************80
!
!! ELMBAK DETERMINES EIGENVECTORS BY UNDOING THE ELMHES TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A REAL GENERAL
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    UPPER HESSENBERG MATRIX DETERMINED BY ELMHES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, INTEGERS DETERMINED BY THE BALANCING
!    ROUTINE BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1 AND
!    IGH EQUAL TO THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,IGH), THE MULTIPLIERS WHICH WERE USED IN THE
!    REDUCTION BY ELMHES IN ITS LOWER TRIANGLE BELOW THE SUBDIAGONAL.
!
!    INPUT, INTEGER ( KIND = 4 ) IND(IGH), INFORMATION ON THE ROWS AND COLUMNS
!    INTERCHANGED IN THE REDUCTION BY ELMHES.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF COLUMNS OF Z TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE REAL AND IMAGINARY PARTS
!    OF THE EIGENVECTORS TO BE BACK TRANSFORMED.  ON OUTPUT, THE REAL AND
!    IMAGINARY PARTS OF THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,IGH)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IND(IGH)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Z(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF

  LA = IGH - 1

  IF ( LA < LOW + 1 ) THEN
    RETURN
  END IF

  DO MM = LOW + 1, LA

     MP = LOW + IGH - MM

     DO I = MP+1, IGH

       X = A(I,MP-1)
       IF ( X /= 0.0D+00 ) THEN
         DO J = 1, M
           Z(I,J) = Z(I,J) + X * Z(MP,J)
         END DO
       END IF

     END DO

     I = IND(MP)

     IF ( I /= MP ) THEN

       DO J = 1, M
         CALL R8_SWAP ( Z(I,J), Z(MP,J) )
       END DO

     END IF

  END DO

  RETURN
END
SUBROUTINE ELMHES ( N, LOW, IGH, A, IND )

!*****************************************************************************80
!
!! ELMHES TRANSFORMS A REAL GENERAL MATRIX TO UPPER HESSENBERG FORM.
!
!  DISCUSSION:
!
!    GIVEN A REAL GENERAL MATRIX, THIS SUBROUTINE REDUCES A SUBMATRIX
!    SITUATED IN ROWS AND COLUMNS LOW THROUGH IGH TO UPPER HESSENBERG
!    FORM BY STABILIZED ELEMENTARY SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN AND WILKINSON,
!    ELMHES,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 12, PAGES 349-368, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING ROUTINE
!    BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1, IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, THE MATRIX TO BE REDUCED.
!    ON OUTPUT, THE HESSENBERG MATRIX.  THE MULTIPLIERS
!    WHICH WERE USED IN THE REDUCTION ARE STORED IN THE
!    REMAINING TRIANGLE UNDER THE HESSENBERG MATRIX.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IND(N), CONTAINS INFORMATION ON THE ROWS
!    AND COLUMNS INTERCHANGED IN THE REDUCTION.  ONLY ELEMENTS LOW THROUGH
!    IGH ARE USED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IND(IGH)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y

  LA = IGH - 1

  DO M = LOW + 1, LA

    X = 0.0D+00
    I = M

    DO J = M, IGH
      IF ( ABS ( A(J,M-1) ) > ABS ( X ) ) THEN
        X = A(J,M-1)
        I = J
      END IF
    END DO

    IND(M) = I
!
!  INTERCHANGE ROWS AND COLUMNS OF THE MATRIX.
!
    IF ( I /= M ) THEN

      DO J = M-1, N
        CALL R8_SWAP ( A(I,J), A(M,J) )
      END DO

      DO J = 1, IGH
        CALL R8_SWAP ( A(J,I), A(J,M) )
      END DO

    END IF

    IF ( X /= 0.0D+00 ) THEN

      DO I = M+1, IGH

        Y = A(I,M-1)

        IF ( Y /= 0.0D+00 ) THEN

          Y = Y / X
          A(I,M-1) = Y

          DO J = M, N
            A(I,J) = A(I,J) - Y * A(M,J)
          END DO

          A(1:IGH,M) = A(1:IGH,M) + Y * A(1:IGH,I)

        END IF

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE ELTRAN ( N, LOW, IGH, A, IND, Z )

!*****************************************************************************80
!
!! ELTRAN ACCUMULATES SIMILARITY TRANSFORMATIONS USED BY ELMHES.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE ACCUMULATES THE STABILIZED ELEMENTARY
!    SIMILARITY TRANSFORMATIONS USED IN THE REDUCTION OF A
!    REAL GENERAL MATRIX TO UPPER HESSENBERG FORM BY ELMHES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    PETERS AND WILKINSON,
!    ELMTRANS,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 16, PAGES 181-204, 1970.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING ROUTINE
!    BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1, IGH = N.
!
!    INPUT, REAL ( KIND = 8 ) A(N,IGH), THE MULTIPLIERS WHICH WERE USED IN THE
!    REDUCTION BY ELMHES IN ITS LOWER TRIANGLE BELOW THE SUBDIAGONAL.
!
!    INPUT, INTEGER ( KIND = 4 ) IND(IGH), INFORMATION ON THE ROWS AND COLUMNS
!    INTERCHANGED IN THE REDUCTION BY ELMHES.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), THE TRANSFORMATION MATRIX PRODUCED IN THE
!    REDUCTION BY ELMHES.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,IGH)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IND(IGH)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) KL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) Z(N,N)
!
!  INITIALIZE Z TO THE IDENTITY MATRIX.
!
  Z(1:N,1:N) = 0.0D+00

  DO I = 1, N
    Z(I,I) = 1.0D+00
  END DO

  KL = IGH - LOW - 1

  IF ( KL < 1 ) THEN
    RETURN
  END IF

  DO MM = 1, KL

     MP = IGH - MM

     DO I = MP+1, IGH
       Z(I,MP) = A(I,MP-1)
     END DO

     I = IND(MP)

     IF ( I /= MP ) THEN

       Z(MP,MP:IGH) = Z(I,MP:IGH)

       Z(I,MP) = 1.0D+00
       Z(I,MP+1:IGH) = 0.0D+00

     END IF

  END DO

  RETURN
END
SUBROUTINE FIGI ( N, T, D, E, E2, IERR )

!*****************************************************************************80
!
!! FIGI TRANSFORMS A REAL NONSYMMETRIC TRIDIAGONAL MATRIX TO SYMMETRIC FORM.
!
!  DISCUSSION:
!
!    GIVEN A NONSYMMETRIC TRIDIAGONAL MATRIX SUCH THAT THE PRODUCTS
!    OF CORRESPONDING PAIRS OF OFF-DIAGONAL ELEMENTS ARE ALL
!    NON-NEGATIVE, THIS SUBROUTINE REDUCES IT TO A SYMMETRIC
!    TRIDIAGONAL MATRIX WITH THE SAME EIGENVALUES.  IF, FURTHER,
!    A ZERO PRODUCT ONLY OCCURS WHEN BOTH FACTORS ARE ZERO,
!    THE REDUCED MATRIX IS SIMILAR TO THE ORIGINAL MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) T(N,3) CONTAINS THE INPUT MATRIX.  ITS SUBDIAGONAL IS
!    STORED IN THE LAST N-1 POSITIONS OF THE FIRST COLUMN, ITS DIAGONAL IN
!    THE N POSITIONS OF THE SECOND COLUMN, AND ITS SUPERDIAGONAL IN THE
!    FIRST N-1 POSITIONS OF THE THIRD COLUMN.  T(1,1) AND T(N,3) ARE ARBITRARY.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE SYMMETRIC MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF
!    THE SYMMETRIC MATRIX IN E(2:N).  E(1) IS NOT SET.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N), THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
!    E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    N+I, IF T(I,1) * T(I-1,3) IS NEGATIVE,
!    -(3*N+I), IF T(I,1) * T(I-1,3) IS ZERO WITH ONE FACTOR NON-ZERO.  IN
!      THIS CASE, THE EIGENVECTORS OF THE SYMMETRIC MATRIX ARE NOT SIMPLY
!      RELATED TO THOSE OF T AND SHOULD NOT BE SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  REAL    ( KIND = 8 ) T(N,3)

  IERR = 0

  DO I = 1, N

    IF ( I >= 1 ) THEN

      E2(I) = T(I,1) * T(I-1,3)

      IF ( E2(I) < 0.0D+00 ) THEN

        IERR = N + I
        RETURN

      ELSE IF ( E2(I) == 0.0D+00 ) THEN

        IF ( T(I,1) /= 0.0D+00 .OR. T(I-1,3) /= 0.0D+00 ) THEN
          IERR = - 3 * N - I
          RETURN
        END IF

        E(I) = 0.0D+00

      ELSE

        E(I) = SQRT ( E2(I) )

      END IF

    END IF

    D(I) = T(I,2)

  END DO

  RETURN
END
SUBROUTINE FIGI2 ( N, T, D, E, Z, IERR )

!*****************************************************************************80
!
!! FIGI2 TRANSFORMS A REAL NONSYMMETRIC TRIDIAGONAL MATRIX TO SYMMETRIC FORM.
!
!  DISCUSSION:
!
!    GIVEN A NONSYMMETRIC TRIDIAGONAL MATRIX SUCH THAT THE PRODUCTS
!    OF CORRESPONDING PAIRS OF OFF-DIAGONAL ELEMENTS ARE ALL
!    NON-NEGATIVE, AND ZERO ONLY WHEN BOTH FACTORS ARE ZERO, THIS
!    SUBROUTINE REDUCES IT TO A SYMMETRIC TRIDIAGONAL MATRIX
!    USING AND ACCUMULATING DIAGONAL SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) T(N,3) CONTAINS THE INPUT MATRIX.  ITS SUBDIAGONAL IS
!    STORED IN THE LAST N-1 POSITIONS OF THE FIRST COLUMN, ITS DIAGONAL IN
!    THE N POSITIONS OF THE SECOND COLUMN, AND ITS SUPERDIAGONAL IN THE
!    FIRST N-1 POSITIONS OF THE THIRD COLUMN.  T(1,1) AND T(N,3) ARE ARBITRARY.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE SYMMETRIC MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF THE SYMMETRIC
!    MATRIX IN E(2:N).  E(1) IS NOT SET.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    N+I, IF T(I,1) * T(I-1,3) IS NEGATIVE,
!    2*N+I, IF T(I,1) * T(I-1,3) IS ZERO WITH ONE FACTOR NON-ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) J
  REAL    ( KIND = 8 ) T(N,3)
  REAL    ( KIND = 8 ) Z(N,N)

  IERR = 0

  DO I = 1, N

    Z(I,1:N) = 0.0D+00

    IF ( I == 1 ) THEN

      Z(I,I) = 1.0D+00

    ELSE

      H = T(I,1) * T(I-1,3)

      IF ( H < 0.0D+00 ) THEN

        IERR = N + I
        RETURN

      ELSE IF ( H == 0 ) THEN

        IF ( T(I,1) /= 0.0D+00 .OR. T(I-1,3) /= 0.0D+00 ) THEN
          IERR = 2 * N + I
          RETURN
        END IF

        E(I) = 0.0D+00
        Z(I,I) = 1.0D+00

      ELSE

        E(I) = SQRT ( H )
        Z(I,I) = Z(I-1,I-1) * E(I) / T(I-1,3)

      END IF

    END IF

    D(I) = T(I,2)

  END DO

  RETURN
END
SUBROUTINE HQR ( N, LOW, IGH, H, WR, WI, IERR )

!*****************************************************************************80
!
!! HQR COMPUTES ALL EIGENVALUES OF A REAL UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A REAL
!    UPPER HESSENBERG MATRIX BY THE QR METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN, PETERS, AND WILKINSON,
!    HQR,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 14, PAGES 219-231, 1970.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, TWO INTEGERS DETERMINED BY THE ROUTINE
!    BALANC.  IF BALANC IS NOT USED, SET LOW=1, IGH=N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) H(N,N), THE N BY N UPPER HESSENBERG MATRIX.
!    INFORMATION ABOUT THE TRANSFORMATIONS USED IN THE REDUCTION TO
!    HESSENBERG FORM BY ELMHES OR ORTHES, IF PERFORMED, IS STORED
!    IN THE REMAINING TRIANGLE UNDER THE HESSENBERG MATRIX.
!    ON OUTPUT, THE INFORMATION IN H HAS BEEN DESTROYED.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVALUES.  THE EIGENVALUES ARE UNORDERED, EXCEPT THAT COMPLEX
!    CONJUGATE PAIRS OF VALUES APPEAR CONSECUTIVELY, WITH THE EIGENVALUE
!    HAVING POSITIVE IMAGINARY PART LISTED FIRST.  IF AN ERROR EXIT
!    OCCURRED, THEN THE EIGENVALUES SHOULD BE CORRECT FOR INDICES
!    IERR+1 THROUGH N.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NO ERROR.
!    J, THE LIMIT OF 30*N ITERATIONS WAS REACHED WHILE SEARCHING FOR
!      THE J-TH EIGENVALUE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM2
  REAL    ( KIND = 8 ) H(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) NA
  REAL    ( KIND = 8 ) NORM
  LOGICAL              NOTLAS
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) Q
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) W
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) ZZ

  IERR = 0
  NORM = 0.0D+00
  K = 1
!
!  STORE ROOTS ISOLATED BY BALANC AND COMPUTE MATRIX NORM.
!
  DO I = 1, N

    DO J = K, N
      NORM = NORM + ABS ( H(I,J) )
    END DO

    K = I
    IF ( I < LOW .OR. I > IGH ) THEN
      WR(I) = H(I,I)
      WI(I) = 0.0D+00
    END IF

  END DO

  EN = IGH
  T = 0.0D+00
  ITN = 30 * N
!
!  SEARCH FOR NEXT EIGENVALUES.
!
60 CONTINUE

  IF ( EN < LOW ) THEN
    RETURN
  END IF

  ITS = 0
  NA = EN - 1
  ENM2 = NA - 1
!
!  LOOK FOR A SINGLE SMALL SUB-DIAGONAL ELEMENT.
!
70 CONTINUE

  DO LL = LOW, EN
    L = EN + LOW - LL
    IF ( L == LOW ) THEN
      EXIT
    END IF
    S = ABS ( H(L-1,L-1) ) + ABS ( H(L,L) )
    IF ( S == 0.0D+00 ) THEN
      S = NORM
    END IF
    TST1 = S
    TST2 = TST1 + ABS ( H(L,L-1) )
    IF ( TST2 == TST1 ) THEN
      EXIT
    END IF
  END DO
!
!  FORM SHIFT.
!
  X = H(EN,EN)
  IF ( L == EN ) THEN
    GO TO 270
  END IF

  Y = H(NA,NA)
  W = H(EN,NA) * H(NA,EN)

  IF ( L == NA ) THEN
    GO TO 280
  END IF

  IF ( ITN == 0 ) THEN
    IERR = EN
    RETURN
  END IF
!
!  FORM AN EXCEPTIONAL SHIFT.
!
  IF ( ITS == 10 .OR. ITS == 20 ) THEN

    T = T + X

    DO I = LOW, EN
      H(I,I) = H(I,I) - X
    END DO

    S = ABS ( H(EN,NA) ) + ABS ( H(NA,ENM2) )
    X = 0.75D+00 * S
    Y = X
    W = -0.4375D+00 * S * S

  END IF

  ITS = ITS + 1
  ITN = ITN - 1
!
!  LOOK FOR TWO CONSECUTIVE SMALL SUB-DIAGONAL ELEMENTS.
!
  DO MM = L, ENM2

    M = ENM2 + L - MM
    ZZ = H(M,M)
    R = X - ZZ
    S = Y - ZZ
    P = ( R * S - W ) / H(M+1,M) + H(M,M+1)
    Q = H(M+1,M+1) - ZZ - R - S
    R = H(M+2,M+1)
    S = ABS ( P ) + ABS ( Q ) + ABS ( R )
    P = P / S
    Q = Q / S
    R = R / S

    IF ( M == L ) THEN
      EXIT
    END IF

    TST1 = ABS ( P ) * ( ABS ( H(M-1,M-1) ) + ABS ( ZZ ) + ABS ( H(M+1,M+1) ) )
    TST2 = TST1 + ABS ( H(M,M-1) ) * ( ABS ( Q ) + ABS ( R ) )

    IF ( TST2 == TST1 ) THEN
      EXIT
    END IF

  END DO

  DO I = M+2, EN
    H(I,I-2) = 0.0D+00
    IF ( I /= M+2 ) THEN
      H(I,I-3) = 0.0D+00
    END IF
  END DO
!
!  DOUBLE QR STEP INVOLVING ROWS L TO EN AND COLUMNS M TO EN.
!
  DO K = M, NA

    NOTLAS = K /= NA

    IF ( K /= M ) THEN

      P = H(K,K-1)
      Q = H(K+1,K-1)

      IF ( NOTLAS ) THEN
        R = H(K+2,K-1)
      ELSE
        R = 0.0D+00
      END IF

      X = ABS ( P ) + ABS ( Q ) + ABS ( R )

      IF ( X == 0.0D+00 ) THEN
        CYCLE
      END IF

      P = P / X
      Q = Q / X
      R = R / X

    END IF

    S = SIGN ( SQRT ( P**2 + Q**2 + R**2 ), P )

    IF ( K /= M ) THEN
      H(K,K-1) = - S * X
    ELSE IF ( L /= M ) THEN
      H(K,K-1) = - H(K,K-1)
    END IF

    P = P + S
    X = P / S
    Y = Q / S
    ZZ = R / S
    Q = Q / P
    R = R / P

    IF ( .NOT. NOTLAS ) THEN
!
!  ROW MODIFICATION.
!
      DO J = K, N
        P = H(K,J) + Q * H(K+1,J)
        H(K,J) = H(K,J) - P * X
        H(K+1,J) = H(K+1,J) - P * Y
      END DO

      J = MIN ( EN, K+3 )
!
!  COLUMN MODIFICATION.
!
      DO I = 1, J
        P = X * H(I,K) + Y * H(I,K+1)
        H(I,K) = H(I,K) - P
        H(I,K+1) = H(I,K+1) - P * Q
      END DO

    ELSE
!
!  ROW MODIFICATION.
!
      DO J = K, N
        P = H(K,J) + Q * H(K+1,J) + R * H(K+2,J)
        H(K,J) = H(K,J) - P * X
        H(K+1,J) = H(K+1,J) - P * Y
        H(K+2,J) = H(K+2,J) - P * ZZ
      END DO

      J = MIN ( EN, K+3 )
!
!  COLUMN MODIFICATION.
!
      DO I = 1, J
        P = X * H(I,K) + Y * H(I,K+1) + ZZ * H(I,K+2)
        H(I,K) = H(I,K) - P
        H(I,K+1) = H(I,K+1) - P * Q
        H(I,K+2) = H(I,K+2) - P * R
      END DO

    END IF

  END DO

  GO TO 70
!
!  ONE ROOT FOUND.
!
270 CONTINUE

  WR(EN) = X + T
  WI(EN) = 0.0D+00
  EN = NA
  GO TO 60
!
!  TWO ROOTS FOUND.
!
280 CONTINUE

  P = ( Y - X ) / 2.0D+00
  Q = P * P + W
  ZZ = SQRT ( ABS ( Q ) )
  X = X + T
!
!  REAL ROOT, OR COMPLEX PAIR.
!
  IF ( Q >= 0.0D+00 ) THEN

    ZZ = P + SIGN ( ZZ, P )
    WR(NA) = X + ZZ
    IF ( ZZ == 0.0D+00 ) THEN
      WR(EN) = WR(NA)
    ELSE
      WR(EN) = X - W / ZZ
    END IF
    WI(NA) = 0.0D+00
    WI(EN) = 0.0D+00

  ELSE

    WR(NA) = X + P
    WR(EN) = X + P
    WI(NA) = ZZ
    WI(EN) = -ZZ

  END IF

  EN = ENM2
  GO TO 60
END
SUBROUTINE HQR2 ( N, LOW, IGH, H, WR, WI, Z, IERR )

!*****************************************************************************80
!
!! HQR2 COMPUTES EIGENVALUES AND EIGENVECTORS OF A REAL UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
!    OF A REAL UPPER HESSENBERG MATRIX BY THE QR METHOD.  THE
!    EIGENVECTORS OF A REAL GENERAL MATRIX CAN ALSO BE FOUND
!    IF ELMHES AND ELTRAN OR ORTHES AND ORTRAN HAVE
!    BEEN USED TO REDUCE THIS GENERAL MATRIX TO HESSENBERG FORM
!    AND TO ACCUMULATE THE SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, DETERMINED BY THE BALANCING
!    ROUTINE BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1, IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) H(N,N), THE N BY N UPPER HESSENBERG MATRIX.
!    ON OUTPUT, THE INFORMATION IN H HAS BEEN DESTROYED.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVALUES.  THE EIGENVALUES ARE UNORDERED, EXCEPT THAT COMPLEX
!    CONJUGATE PAIRS OF VALUES APPEAR CONSECUTIVELY, WITH THE EIGENVALUE
!    HAVING POSITIVE IMAGINARY PART LISTED FIRST.  IF AN ERROR EXIT
!    OCCURRED, THEN THE EIGENVALUES SHOULD BE CORRECT FOR INDICES
!    IERR+1 THROUGH N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,N).  ON INPUT, THE TRANSFORMATION MATRIX
!    PRODUCED BY ELTRAN AFTER THE REDUCTION BY ELMHES, OR BY ORTRAN AFTER THE
!    REDUCTION BY ORTHES, IF PERFORMED.  IF THE EIGENVECTORS OF THE HESSENBERG
!    MATRIX ARE DESIRED, Z MUST CONTAIN THE IDENTITY MATRIX.  ON OUTPUT,
!    Z CONTAINS THE REAL AND IMAGINARY PARTS OF THE EIGENVECTORS.
!    IF THE I-TH EIGENVALUE IS REAL, THE I-TH COLUMN OF Z CONTAINS ITS
!    EIGENVECTOR.  IF THE I-TH EIGENVALUE IS COMPLEX WITH POSITIVE IMAGINARY
!    PART, THE I-TH AND (I+1)-TH COLUMNS OF Z CONTAIN THE REAL AND IMAGINARY
!    PARTS OF ITS EIGENVECTOR.  THE EIGENVECTORS ARE UNNORMALIZED.  IF AN
!    ERROR EXIT IS MADE, NONE OF THE EIGENVECTORS HAS BEEN FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE LIMIT OF 30*N ITERATIONS IS EXHAUSTED WHILE THE J-TH
!      EIGENVALUE IS BEING SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM2
  REAL    ( KIND = 8 ) H(N,N)
  REAL    ( KIND = 8 ) HNORM
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) NA
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) NORM
  LOGICAL              NOTLAS
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) Q
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RA
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SA
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) TEMP
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) VI
  REAL    ( KIND = 8 ) VR
  REAL    ( KIND = 8 ) W
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z(N,N)
  REAL    ( KIND = 8 ) ZZ

  IERR = 0
  NORM = 0.0D+00
  K = 1
!
!  STORE ROOTS ISOLATED BY BALANC AND COMPUTE THE MATRIX NORM.
!
  DO I = 1, N

    DO J = K, N
      NORM = NORM + ABS ( H(I,J) )
    END DO

    K = I
    IF ( I < LOW .OR. I > IGH ) THEN
      WR(I) = H(I,I)
      WI(I) = 0.0D+00
    END IF

  END DO

  EN = IGH
  T = 0.0D+00
  ITN = 30 * N
!
!  SEARCH FOR NEXT EIGENVALUES.
!
60 CONTINUE

  IF ( EN < LOW ) THEN
    GO TO 340
  END IF

  ITS = 0
  NA = EN - 1
  ENM2 = NA - 1
!
!  LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT.
!
70 CONTINUE

  DO LL = LOW, EN

    L = EN + LOW - LL

    IF ( L == LOW ) THEN
      EXIT
    END IF

    S = ABS ( H(L-1,L-1) ) + ABS ( H(L,L) )
    IF ( S == 0.0D+00 ) THEN
      S = NORM
    END IF

    TST1 = S
    TST2 = TST1 + ABS ( H(L,L-1) )

    IF ( TST2 == TST1 ) THEN
      EXIT
    END IF

  END DO
!
!  FORM SHIFT.
!
  X = H(EN,EN)
  IF ( L == EN ) THEN
    GO TO 270
  END IF

  Y = H(NA,NA)
  W = H(EN,NA) * H(NA,EN)

  IF ( L == NA ) THEN
    GO TO 280
  END IF

  IF ( ITN == 0 ) THEN
    IERR = EN
    RETURN
  END IF
!
!  FORM EXCEPTIONAL SHIFT.
!
  IF ( ITS == 10 .OR. ITS == 20 ) THEN

    T = T + X

    DO I = LOW, EN
      H(I,I) = H(I,I) - X
    END DO

    S = ABS ( H(EN,NA) ) + ABS ( H(NA,ENM2) )
    X = 0.75D+00 * S
    Y = X
    W = -0.4375D+00 * S * S

  END IF

  ITS = ITS + 1
  ITN = ITN - 1
!
!  LOOK FOR TWO CONSECUTIVE SMALL SUB-DIAGONAL ELEMENTS.
!
  DO MM = L, ENM2
     M = ENM2 + L - MM
     ZZ = H(M,M)
     R = X - ZZ
     S = Y - ZZ
     P = ( R * S - W ) / H(M+1,M) + H(M,M+1)
     Q = H(M+1,M+1) - ZZ - R - S
     R = H(M+2,M+1)
     S = ABS ( P ) + ABS ( Q ) + ABS ( R )
     P = P / S
     Q = Q / S
     R = R / S
     IF ( M == L ) THEN
       EXIT
     END IF

     TST1 = ABS ( P ) * ( ABS ( H(M-1,M-1) ) + ABS ( ZZ ) + ABS ( H(M+1,M+1) ) )
     TST2 = TST1 + ABS ( H(M,M-1) ) * ( ABS ( Q ) + ABS ( R ) )
     IF ( TST2 == TST1 ) THEN
       EXIT
     END IF

  END DO

  DO I = M+2, EN
    H(I,I-2) = 0.0D+00
    IF ( I /= M+2 ) THEN
      H(I,I-3) = 0.0D+00
    END IF
  END DO
!
!  DOUBLE QR STEP INVOLVING ROWS L TO EN AND COLUMNS M TO EN.
!
  DO K = M, NA

     NOTLAS = K /= NA

     IF ( K /= M ) THEN

       P = H(K,K-1)
       Q = H(K+1,K-1)
       R = 0.0D+00
       IF ( NOTLAS ) THEN
         R = H(K+2,K-1)
       END IF

       X = ABS ( P ) + ABS ( Q ) + ABS ( R )
       IF ( X == 0.0D+00 ) THEN
         CYCLE
       END IF

       P = P / X
       Q = Q / X
       R = R / X

     END IF

     S = SIGN ( SQRT ( P**2 + Q**2 + R**2 ), P )

     IF ( K /= M ) THEN
       H(K,K-1) = - S * X
     ELSE IF ( L /= M ) THEN
       H(K,K-1) = -H(K,K-1)
     END IF

     P = P + S
     X = P / S
     Y = Q / S
     ZZ = R / S
     Q = Q / P
     R = R / P
     IF ( NOTLAS ) GO TO 225
!
!  ROW MODIFICATION.
!
     DO J = K, N
       P = H(K,J) + Q * H(K+1,J)
       H(K,J) = H(K,J) - P * X
       H(K+1,J) = H(K+1,J) - P * Y
     END DO

     J = MIN ( EN, K+3 )
!
!  COLUMN MODIFICATION.
!
     DO I = 1, J
       P = X * H(I,K) + Y * H(I,K+1)
       H(I,K) = H(I,K) - P
       H(I,K+1) = H(I,K+1) - P * Q
     END DO
!
!  ACCUMULATE TRANSFORMATIONS.
!
     DO I = LOW, IGH
       P = X * Z(I,K) + Y * Z(I,K+1)
       Z(I,K) = Z(I,K) - P
       Z(I,K+1) = Z(I,K+1) - P * Q
     END DO

     GO TO 255

225  CONTINUE
!
!  ROW MODIFICATION.
!
     DO J = K, N
       P = H(K,J) + Q * H(K+1,J) + R * H(K+2,J)
       H(K,J) = H(K,J) - P * X
       H(K+1,J) = H(K+1,J) - P * Y
       H(K+2,J) = H(K+2,J) - P * ZZ
     END DO

     J = MIN ( EN, K+3 )
!
!  COLUMN MODIFICATION.
!
     DO I = 1, J
       P = X * H(I,K) + Y * H(I,K+1) + ZZ * H(I,K+2)
       H(I,K) = H(I,K) - P
       H(I,K+1) = H(I,K+1) - P * Q
       H(I,K+2) = H(I,K+2) - P * R
     END DO
!
!  ACCUMULATE TRANSFORMATIONS.
!
     DO I = LOW, IGH
        P = X * Z(I,K) + Y * Z(I,K+1) + ZZ * Z(I,K+2)
        Z(I,K) = Z(I,K) - P
        Z(I,K+1) = Z(I,K+1) - P * Q
        Z(I,K+2) = Z(I,K+2) - P * R
     END DO

255 CONTINUE

260 CONTINUE

  END DO

  GO TO 70
!
!  ONE ROOT FOUND.
!
270 CONTINUE

  H(EN,EN) = X + T
  WR(EN) = H(EN,EN)
  WI(EN) = 0.0D+00
  EN = NA
  GO TO 60
!
!  TWO ROOTS FOUND.
!
280 CONTINUE

  P = ( Y - X ) / 2.0D+00
  Q = P * P + W
  ZZ = SQRT ( ABS ( Q ) )
  H(EN,EN) = X + T
  X = H(EN,EN)
  H(NA,NA) = Y + T

  IF ( Q < 0.0D+00 ) GO TO 320
!
!  REAL PAIR.
!
  ZZ = P + SIGN ( ZZ, P )
  WR(NA) = X + ZZ
  WR(EN) = WR(NA)

  IF ( ZZ /= 0.0D+00 ) THEN
    WR(EN) = X - W / ZZ
  END IF

  WI(NA) = 0.0D+00
  WI(EN) = 0.0D+00
  X = H(EN,NA)
  S = ABS ( X ) + ABS ( ZZ )
  P = X / S
  Q = ZZ / S
  R = SQRT ( P**2 + Q**2 )
  P = P / R
  Q = Q / R
!
!  ROW MODIFICATION.
!
  DO J = NA, N
    ZZ = H(NA,J)
    H(NA,J) = Q * ZZ + P * H(EN,J)
    H(EN,J) = Q * H(EN,J) - P * ZZ
  END DO
!
!  COLUMN MODIFICATION.
!
  DO I = 1, EN
    ZZ = H(I,NA)
    H(I,NA) = Q * ZZ + P * H(I,EN)
    H(I,EN) = Q * H(I,EN) - P * ZZ
  END DO
!
!  ACCUMULATE TRANSFORMATIONS.
!
  DO I = LOW, IGH
    ZZ = Z(I,NA)
    Z(I,NA) = Q * ZZ + P * Z(I,EN)
    Z(I,EN) = Q * Z(I,EN) - P * ZZ
  END DO

  GO TO 330
!
!  COMPLEX PAIR
!
320 CONTINUE

  WR(NA) = X + P
  WR(EN) = X + P
  WI(NA) = ZZ
  WI(EN) = -ZZ

330 CONTINUE

  EN = ENM2
  GO TO 60
!
!  ALL ROOTS FOUND.
!  BACKSUBSTITUTE TO FIND VECTORS OF UPPER TRIANGULAR FORM.
!
340 CONTINUE

  IF ( NORM == 0.0D+00 ) THEN
    RETURN
  END IF

  DO NN = 1, N

     EN = N + 1 - NN
     P = WR(EN)
     Q = WI(EN)
     NA = EN - 1
     IF ( Q ) 710, 600, 800
!
!  REAL VECTOR
!
600  CONTINUE

     M = EN
     H(EN,EN) = 1.0D+00

     IF ( NA == 0 ) GO TO 800

     DO II = 1, NA

        I = EN - II
        W = H(I,I) - P
        R = DOT_PRODUCT ( H(I,M:EN), H(M:EN,EN) )

        IF ( WI(I) < 0.0D+00 ) THEN
          ZZ = W
          S = R
          GO TO 700
        END IF

        M = I
        IF ( WI(I) /= 0.0D+00 ) GO TO 640
        T = W

        IF ( T == 0.0D+00 ) THEN

          TST1 = NORM
          T = TST1

          DO
            T = 0.01D+00 * T
            TST2 = NORM + T
            IF ( TST2 <= TST1 ) THEN
              EXIT
            END IF
          END DO

        END IF

        H(I,EN) = -R / T
        GO TO 680
!
!  SOLVE REAL EQUATIONS.
!
640     CONTINUE

        X = H(I,I+1)
        Y = H(I+1,I)
        Q = ( WR(I) - P ) * ( WR(I) - P) + WI(I) * WI(I)
        T = ( X * S - ZZ * R ) / Q
        H(I,EN) = T

        IF ( ABS ( X ) > ABS ( ZZ ) ) THEN
          H(I+1,EN) = (-R - W * T) / X
        ELSE
          H(I+1,EN) = (-S - Y * T) / ZZ
        END IF
!
!  OVERFLOW CONTROL.
!
680     CONTINUE

        T = ABS ( H(I,EN) )

        IF ( T /= 0.0D+00 ) THEN

          TST1 = T
          TST2 = TST1 + 1.0D+00 / TST1

          IF ( TST2 <= TST1 ) THEN
            H(I:EN,EN) = H(I:EN,EN) / T
          END IF

        END IF

700   CONTINUE

    END DO
!
!  END REAL VECTOR
!
     GO TO 800
!
!  COMPLEX VECTOR
!
710  CONTINUE

     M = NA
!
!  LAST VECTOR COMPONENT CHOSEN IMAGINARY, SO THAT THE EIGENVECTOR
!  MATRIX IS TRIANGULAR.
!
     IF ( ABS ( H(EN,NA) ) > ABS ( H(NA,EN) ) ) THEN

       H(NA,NA) = Q / H(EN,NA)
       H(NA,EN) = -(H(EN,EN) - P) / H(EN,NA)

     ELSE

       CALL CDIV ( 0.0D+00, -H(NA,EN), H(NA,NA)-P, Q, H(NA,NA), H(NA,EN) )

     END IF

     H(EN,NA) = 0.0D+00
     H(EN,EN) = 1.0D+00
     ENM2 = NA - 1

     DO II = 1, ENM2

        I = NA - II
        W = H(I,I) - P
        RA = DOT_PRODUCT ( H(I,M:EN), H(M:EN,NA) )
        SA = DOT_PRODUCT ( H(I,M:EN), H(M:EN,EN) )

        IF ( WI(I) < 0.0D+00 ) THEN
          ZZ = W
          R = RA
          S = SA
        END IF

         M = I

        IF ( WI(I) == 0.0D+00 ) THEN
          CALL CDIV ( -RA, -SA, W, Q, H(I,NA), H(I,EN) )
          GO TO 790
        END IF
!
!  SOLVE COMPLEX EQUATIONS.
!
        X = H(I,I+1)
        Y = H(I+1,I)
        VR = ( WR(I) - P ) * ( WR(I) - P ) + WI(I) * WI(I) - Q * Q
        VI = ( WR(I) - P ) * 2.0D+00 * Q

        IF ( VR == 0.0D+00 .AND. VI == 0.0D+00 ) THEN

          TST1 = NORM * ( ABS ( W ) + ABS ( Q ) + ABS ( X ) &
            + ABS ( Y ) + ABS ( ZZ ) )
          VR = TST1

          DO
            VR = 0.01D+00 * VR
            TST2 = TST1 + VR
            IF ( TST2 <= TST1 ) THEN
              EXIT
            END IF
          END DO

        END IF

        CALL CDIV ( X*R-ZZ*RA+Q*SA, X*S-ZZ*SA-Q*RA, VR, VI, H(I,NA), H(I,EN) )

        IF ( ABS ( X ) > ABS ( ZZ ) + ABS ( Q ) ) THEN
          H(I+1,NA) = ( -RA - W * H(I,NA) + Q * H(I,EN) ) / X
          H(I+1,EN) = ( -SA - W * H(I,EN) - Q * H(I,NA) ) / X
        ELSE
          CALL CDIV ( -R-Y*H(I,NA), -S-Y*H(I,EN), ZZ, Q, H(I+1,NA), H(I+1,EN) )
        END IF
!
!  OVERFLOW CONTROL.
!
790     CONTINUE

        T = MAX ( ABS ( H(I,NA) ), ABS ( H(I,EN) ) )

        IF ( T /= 0.0D+00 ) THEN
          TST1 = T
          TST2 = TST1 + 1.0D+00 / TST1
          IF ( TST2 <= TST1 ) THEN
            H(I:EN,NA) = H(I:EN,NA) / T
            H(I:EN,EN) = H(I:EN,EN) / T
          END IF
        END IF

795     CONTINUE

      END DO
!
!  END COMPLEX VECTOR.
!
800 CONTINUE

  END DO
!
!  END BACK SUBSTITUTION.
!
!  VECTORS OF ISOLATED ROOTS.
!
  DO I = 1, N

    IF ( I < LOW .OR. I > IGH ) THEN
      Z(I,I:N) = H(I,I:N)
    END IF

  END DO
!
!  MULTIPLY BY TRANSFORMATION MATRIX TO GIVE VECTORS OF ORIGINAL FULL MATRIX.
!
  DO JJ = LOW, N

     J = N + LOW - JJ
     M = MIN ( J, IGH )

     DO I = LOW, IGH
       Z(I,J) = DOT_PRODUCT ( Z(I,LOW:M), H(LOW:M,J) )
     END DO

  END DO

  RETURN
END
SUBROUTINE HTRIB3 ( N, A, TAU, M, ZR, ZI )

!*****************************************************************************80
!
!! HTRIB3 DETERMINES EIGENVECTORS BY UNDOING THE HTRID3 TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX HERMITIAN
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    REAL SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY HTRID3.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, IS THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS INFORMATION ABOUT THE UNITARY
!    TRANSFORMATIONS USED IN THE REDUCTION BY HTRID3.
!
!    INPUT, REAL ( KIND = 8 ) TAU(2,N), CONTAINS FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ZR(N,M), ZI(N,M).  ON INPUT, ZR CONTAINS THE
!    EIGENVECTORS TO BE BACK TRANSFORMED.  ON OUTPUT, ZR AND ZI CONTAIN
!    THE REAL AND IMAGINARY PARTS OF THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) TAU(2,N)
  REAL    ( KIND = 8 ) ZI(N,M)
  REAL    ( KIND = 8 ) ZR(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF
!
!  TRANSFORM THE EIGENVECTORS OF THE REAL SYMMETRIC TRIDIAGONAL MATRIX
!  TO THOSE OF THE HERMITIAN TRIDIAGONAL MATRIX.
!
  DO K = 1, N
    DO J = 1, M
      ZI(K,J) = -ZR(K,J) * TAU(2,K)
      ZR(K,J) = ZR(K,J) * TAU(1,K)
    END DO
  END DO
!
!  RECOVER AND APPLY THE HOUSEHOLDER MATRICES.
!
  DO I = 2, N

    L = I - 1
    H = A(I,I)

    IF ( H /= 0.0D+00 ) THEN

      DO J = 1, M

        S = 0.0D+00
        SI = 0.0D+00

        DO K = 1, L
          S = S + A(I,K) * ZR(K,J) - A(K,I) * ZI(K,J)
          SI = SI + A(I,K) * ZI(K,J) + A(K,I) * ZR(K,J)
        END DO

        S = ( S / H ) / H
        SI = ( SI / H ) / H

        ZR(1:L,J) = ZR(1:L,J) - S * A(I,1:L) - SI * A(1:L,I)
        ZI(1:L,J) = ZI(1:L,J) - SI * A(I,1:L) + S * A(1:L,I)

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE HTRIBK ( N, AR, AI, TAU, M, ZR, ZI )

!*****************************************************************************80
!
!! HTRIBK DETERMINES EIGENVECTORS BY UNDOING THE HTRIDI TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A COMPLEX HERMITIAN
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    REAL SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY HTRIDI.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N), CONTAIN INFORMATION ABOUT
!    THE UNITARY TRANSFORMATIONS USED IN THE REDUCTION BY HTRIDI IN THEIR
!    FULL LOWER TRIANGLES, EXCEPT FOR THE DIAGONAL OF AR.
!
!    INPUT, REAL ( KIND = 8 ) TAU(2,N), CONTAINS FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ZR(N,M), ZI(N,M).  ON INPUT, ZR CONTAINS THE
!    EIGENVECTORS TO BE BACK TRANSFORMED.  ON OUTPUT, ZR AND ZI CONTAIN
!    THE REAL AND IMAGINARY PARTS OF THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) TAU(2,N)
  REAL    ( KIND = 8 ) ZI(N,M)
  REAL    ( KIND = 8 ) ZR(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF
!
!  TRANSFORM THE EIGENVECTORS OF THE REAL SYMMETRIC TRIDIAGONAL MATRIX TO
!  THOSE OF THE HERMITIAN TRIDIAGONAL MATRIX.
!
  DO K = 1, N
    DO J = 1, M
      ZI(K,J) = -ZR(K,J) * TAU(2,K)
      ZR(K,J) = ZR(K,J) * TAU(1,K)
    END DO
  END DO
!
!  RECOVER AND APPLY THE HOUSEHOLDER MATRICES.
!
  DO I = 2, N

    L = I - 1
    H = AI(I,I)

    IF ( H /= 0.0D+00 ) THEN

      DO J = 1, M

        S = 0.0D+00
        SI = 0.0D+00
        DO K = 1, L
          S = S + AR(I,K) * ZR(K,J) - AI(I,K) * ZI(K,J)
          SI = SI + AR(I,K) * ZI(K,J) + AI(I,K) * ZR(K,J)
        END DO

        S = ( S / H ) / H
        SI = ( SI / H ) / H

        ZR(1:L,J) = ZR(1:L,J) - S * AR(I,1:L) - SI * AI(I,1:L)
        ZI(1:L,J) = ZI(1:L,J) - SI * AR(I,1:L) + S * AI(I,1:L)

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE HTRID3 ( N, A, D, E, E2, TAU )

!*****************************************************************************80
!
!! HTRID3 TRIDIAGONALIZES A COMPLEX HERMITIAN PACKED MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES A COMPLEX HERMITIAN MATRIX, STORED AS
!    A SINGLE SQUARE ARRAY, TO A REAL SYMMETRIC TRIDIAGONAL MATRIX
!    USING UNITARY SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, THE LOWER TRIANGLE OF THE COMPLEX
!    HERMITIAN INPUT MATRIX.  THE REAL PARTS OF THE MATRIX ELEMENTS ARE STORED
!    IN THE FULL LOWER TRIANGLE OF A, AND THE IMAGINARY PARTS ARE STORED IN
!    THE TRANSPOSED POSITIONS OF THE STRICT UPPER TRIANGLE OF A.  NO STORAGE
!    IS REQUIRED FOR THE ZERO IMAGINARY PARTS OF THE DIAGONAL ELEMENTS.
!    ON OUTPUT, A CONTAINS INFORMATION ABOUT THE UNITARY TRANSFORMATIONS
!    USED IN THE REDUCTION.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX IN E(2:N).  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N), THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
!    E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
!    OUTPUT, REAL ( KIND = 8 ) TAU(2,N), CONTAINS FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) FI
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) GI
  REAL    ( KIND = 8 ) H
  REAL    ( KIND = 8 ) HH
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) TAU(2,N)

  TAU(1,N) = 1.0D+00
  TAU(2,N) = 0.0D+00

  DO II = 1, N

    I = N + 1 - II
    L = I - 1
    H = 0.0D+00
    SCALE = 0.0D+00

    IF ( L < 1 ) THEN
      E(I) = 0.0D+00
      E2(I) = 0.0D+00
      GO TO 290
    END IF
!
!  SCALE ROW.
!
     DO K = 1, L
       SCALE = SCALE + ABS ( A(I,K) ) + ABS ( A(K,I) )
     END DO

     IF ( SCALE == 0.0D+00 ) THEN
       TAU(1,L) = 1.0D+00
       TAU(2,L) = 0.0D+00
       E(I) = 0.0D+00
       E2(I) = 0.0D+00
       GO TO 290
     END IF

      DO K = 1, L
        A(I,K) = A(I,K) / SCALE
        A(K,I) = A(K,I) / SCALE
        H = H + A(I,K) * A(I,K) + A(K,I) * A(K,I)
     END DO

     E2(I) = SCALE * SCALE * H
     G = SQRT ( H )
     E(I) = SCALE * G
     F = PYTHAG ( A(I,L), A(L,I) )
!
!  FORM NEXT DIAGONAL ELEMENT OF MATRIX T.
!
     IF ( F /= 0.0D+00 ) THEN

       TAU(1,L) = ( A(L,I) * TAU(2,I) - A(I,L) * TAU(1,I) ) / F
       SI = ( A(I,L) * TAU(2,I) + A(L,I) * TAU(1,I) ) / F
       H = H + F * G
       G = 1.0D+00 + G / F
       A(I,L) = G * A(I,L)
       A(L,I) = G * A(L,I)

       IF ( L == 1 ) GO TO 270

     ELSE

       TAU(1,L) = -TAU(1,I)
       SI = TAU(2,I)
       A(I,L) = G

     END IF

     F = 0.0D+00

     DO J = 1, L

        G = 0.0D+00
        GI = 0.0D+00
!
!  FORM ELEMENT OF A*U.
!
        DO K = 1, J-1
          G = G + A(J,K) * A(I,K) + A(K,J) * A(K,I)
          GI = GI - A(J,K) * A(K,I) + A(K,J) * A(I,K)
        END DO

        G = G + A(J,J) * A(I,J)
        GI = GI - A(J,J) * A(J,I)

        DO K = J+1, L
          G = G + A(K,J) * A(I,K) - A(J,K) * A(K,I)
          GI = GI - A(K,J) * A(K,I) - A(J,K) * A(I,K)
        END DO
!
!  FORM ELEMENT OF P.
!
        E(J) = G / H
        TAU(2,J) = GI / H
        F = F + E(J) * A(I,J) - TAU(2,J) * A(J,I)

     END DO

     HH = F / ( H + H )
!
!  FORM REDUCED A.
!
     DO J = 1, L

        F = A(I,J)
        G = E(J) - HH * F
        E(J) = G
        FI = -A(J,I)
        GI = TAU(2,J) - HH * FI
        TAU(2,J) = -GI
        A(J,J) = A(J,J) - 2.0D+00 * ( F * G + FI * GI )

        DO K = 1, J-1
          A(J,K) = A(J,K) - F * E(K) - G * A(I,K) + FI * TAU(2,K) + GI * A(K,I)
          A(K,J) = A(K,J) - F * TAU(2,K) - G * A(K,I) - FI * E(K) - GI * A(I,K)
        END DO

     END DO

270  CONTINUE

     A(I,1:L) = SCALE * A(I,1:L)
     A(1:L,I) = SCALE * A(1:L,I)
     TAU(2,L) = -SI

290  CONTINUE

     D(I) = A(I,I)
     A(I,I) = SCALE * SQRT ( H )

  END DO

  RETURN
END
SUBROUTINE HTRIDI ( N, AR, AI, D, E, E2, TAU )

!*****************************************************************************80
!
!! HTRIDI TRIDIAGONALIZES A COMPLEX HERMITIAN MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES A COMPLEX HERMITIAN MATRIX TO A REAL SYMMETRIC
!    TRIDIAGONAL MATRIX USING UNITARY SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) AR(N,N), AI(N,N).  ON INPUT, THE REAL
!    AND IMAGINARY PARTS, RESPECTIVELY, OF THE COMPLEX HERMITIAN INPUT MATRIX.
!    ONLY THE LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!    ON OUTPUT, INFORMATION ABOUT THE UNITARY TRANSFORMATIONS USED IN THE
!    REDUCTION IN THEIR FULL LOWER TRIANGLES.  THEIR STRICT UPPER TRIANGLES
!    AND THE DIAGONAL OF AR ARE UNALTERED.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N), THE SQUARES OF THE CORRESPONDING ELEMENTS OF E.
!    E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
!    OUTPUT, REAL ( KIND = 8 ) TAU(2,N), CONTAINS FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) AI(N,N)
  REAL    ( KIND = 8 ) AR(N,N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) FI
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) GI
  REAL    ( KIND = 8 ) H
  REAL    ( KIND = 8 ) HH
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) SI
  REAL    ( KIND = 8 ) TAU(2,N)

  TAU(1,N) = 1.0D+00
  TAU(2,N) = 0.0D+00

  DO I = 1, N
    D(I) = AR(I,I)
  END DO

  DO II = 1, N

    I = N + 1 - II
    L = I - 1
    H = 0.0D+00
    SCALE = 0.0D+00

    IF ( L < 1 ) THEN
      E(I) = 0.0D+00
      E2(I) = 0.0D+00
      GO TO 290
    END IF
!
!  SCALE ROW.
!
    DO K = 1, L
      SCALE = SCALE + ABS ( AR(I,K) ) + ABS ( AI(I,K) )
    END DO

    IF ( SCALE == 0.0D+00 ) THEN
      TAU(1,L) = 1.0D+00
      TAU(2,L) = 0.0D+00
      E(I) = 0.0D+00
      E2(I) = 0.0D+00
      GO TO 290
    END IF

    AR(I,1:L) = AR(I,1:L) / SCALE
    AI(I,1:L) = AI(I,1:L) / SCALE

    DO K = 1, L
      H = H + AR(I,K) * AR(I,K) + AI(I,K) * AI(I,K)
    END DO

    E2(I) = SCALE * SCALE * H
    G = SQRT ( H )
    E(I) = SCALE * G
    F = PYTHAG ( AR(I,L), AI(I,L) )
!
!  FORM NEXT DIAGONAL ELEMENT OF MATRIX T.
!
    IF ( F /= 0.0D+00 ) THEN
      TAU(1,L) = ( AI(I,L) * TAU(2,I) - AR(I,L) * TAU(1,I) ) / F
      SI = ( AR(I,L) * TAU(2,I) + AI(I,L) * TAU(1,I) ) / F
      H = H + F * G
      G = 1.0D+00 + G / F
      AR(I,L) = G * AR(I,L)
      AI(I,L) = G * AI(I,L)
      IF ( L == 1 ) GO TO 270
    ELSE
      TAU(1,L) = -TAU(1,I)
      SI = TAU(2,I)
      AR(I,L) = G
    END IF

    F = 0.0D+00

    DO J = 1, L

      G = 0.0D+00
      GI = 0.0D+00
!
!  FORM ELEMENT OF A*U.
!
      DO K = 1, J
        G = G + AR(J,K) * AR(I,K) + AI(J,K) * AI(I,K)
        GI = GI - AR(J,K) * AI(I,K) + AI(J,K) * AR(I,K)
      END DO

      DO K = J+1, L
        G = G + AR(K,J) * AR(I,K) - AI(K,J) * AI(I,K)
        GI = GI - AR(K,J) * AI(I,K) - AI(K,J) * AR(I,K)
      END DO
!
!  FORM ELEMENT OF P.
!
      E(J) = G / H
      TAU(2,J) = GI / H
      F = F + E(J) * AR(I,J) - TAU(2,J) * AI(I,J)

    END DO

    HH = F / ( H + H )
!
!  FORM THE REDUCED A.
!
    DO J = 1, L

      F = AR(I,J)
      G = E(J) - HH * F
      E(J) = G
      FI = - AI(I,J)
      GI = TAU(2,J) - HH * FI
      TAU(2,J) = -GI

      DO K = 1, J
        AR(J,K) = AR(J,K) - F * E(K) - G * AR(I,K) + FI * TAU(2,K) &
          + GI * AI(I,K)
        AI(J,K) = AI(J,K) - F * TAU(2,K) - G * AI(I,K) - FI * E(K) &
          - GI * AR(I,K)
      END DO

    END DO

270 CONTINUE

    AR(I,1:L) = SCALE * AR(I,1:L)
    AI(I,1:L) = SCALE * AI(I,1:L)
    TAU(2,L) = -SI

290 CONTINUE

    HH = D(I)
    D(I) = AR(I,I)
    AR(I,I) = HH
    AI(I,I) = SCALE * SQRT ( H )

  END DO

  RETURN
END
SUBROUTINE IMTQL1 ( N, D, E, IERR )

!*****************************************************************************80
!
!! IMTQL1 COMPUTES ALL EIGENVALUES OF A SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC
!    TRIDIAGONAL MATRIX BY THE IMPLICIT QL METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).  ON INPUT, THE DIAGONAL ELEMENTS OF
!    THE MATRIX.  ON OUTPUT, THE EIGENVALUES IN ASCENDING ORDER.  IF AN ERROR
!    EXIT IS MADE, THE EIGENVALUES ARE CORRECT AND ORDERED FOR INDICES
!    1,2,...IERR-1, BUT MAY NOT BE THE SMALLEST EIGENVALUES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E(N).  ON INPUT, THE SUBDIAGONAL ELEMENTS
!    OF THE MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS ARBITRARY.  ON OUTPUT,
!    E HAS BEEN OVERWRITTEN.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NORMAL RETURN,
!    J, IF THE J-TH EIGENVALUE HAS NOT BEEN DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2

  IERR = 0

  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E(I-1) = E(I)
  END DO
  E(N) = 0.0D+00

  DO L = 1, N

    J = 0
!
!  LOOK FOR A SMALL SUB-DIAGONAL ELEMENT.
!
105 CONTINUE

    DO M = L, N

      IF ( M == N ) THEN
        EXIT
      END IF

      TST1 = ABS ( D(M) ) + ABS ( D(M+1) )
      TST2 = TST1 + ABS ( E(M) )

      IF ( TST2 == TST1 ) THEN
        EXIT
      END IF

    END DO

    P = D(L)

    IF ( M == L ) THEN
      GO TO 215
    END IF

    IF ( 30 <= J ) THEN
      IERR = L
      RETURN
    END IF

    J = J + 1
!
!  FORM SHIFT.
!
    G = ( D(L+1) - P ) / ( 2.0D+00 * E(L) )
    R = PYTHAG ( G, 1.0D+00 )
    G = D(M) - P + E(L) / ( G + SIGN ( R, G ) )
    S = 1.0D+00
    C = 1.0D+00
    P = 0.0D+00
    MML = M - L

    DO II = 1, MML

      I = M - II
      F = S * E(I)
      B = C * E(I)
      R = PYTHAG ( F, G )
      E(I+1) = R
!
!  RECOVER FROM UNDERFLOW.
!
      IF ( R == 0.0D+00 ) THEN
        D(I+1) = D(I+1) - P
        E(M) = 0.0D+00
        GO TO 105
      END IF

      S = F / R
      C = G / R
      G = D(I+1) - P
      R = ( D(I) - G ) * S + 2.0D+00 * C * B
      P = S * R
      D(I+1) = G + P
      G = C * R - B

    END DO

    D(L) = D(L) - P
    E(L) = G
    E(M) = 0.0D+00
    GO TO 105
!
!  ORDER THE EIGENVALUES.
!
215 CONTINUE

    DO II = 2, L
      I = L + 2 - II
      IF ( D(I-1) <= P ) THEN
        GO TO 270
      END IF
      D(I) = D(I-1)
    END DO

    I = 1

270 CONTINUE

    D(I) = P

  END DO

  RETURN
END
SUBROUTINE IMTQL2 ( N, D, E, Z, IERR )

!*****************************************************************************80
!
!! IMTQL2 COMPUTES ALL EIGENVALUES/VECTORS OF A SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS
!    OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE IMPLICIT QL METHOD.
!    THE EIGENVECTORS OF A FULL SYMMETRIC MATRIX CAN ALSO
!    BE FOUND IF TRED2 HAS BEEN USED TO REDUCE THIS
!    FULL MATRIX TO TRIDIAGONAL FORM.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).  ON INPUT, THE DIAGONAL ELEMENTS OF
!    THE INPUT MATRIX.  ON OUTPUT, THE EIGENVALUES IN ASCENDING ORDER.  IF AN
!    ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT
!    UNORDERED FOR INDICES 1,2,...,IERR-1.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E(N).  ON INPUT, THE SUBDIAGONAL ELEMENTS
!    OF THE INPUT MATRIX IN E(2:N).  E(1) IS ARBITRARY.  ON OUTPUT, E IS
!    OVERWRITTEN.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,N).  ON INPUT, THE TRANSFORMATION
!    MATRIX PRODUCED IN THE REDUCTION BY TRED2, IF PERFORMED.  IF THE
!    EIGENVECTORS OF THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN THE
!    IDENTITY MATRIX.  ON OUTPUT, Z CONTAINS ORTHONORMAL EIGENVECTORS OF THE
!    SYMMETRIC TRIDIAGONAL (OR FULL) MATRIX.  IF AN ERROR EXIT IS MADE, Z
!    CONTAINS THE EIGENVECTORS ASSOCIATED WITH THE STORED EIGENVALUES.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE J-TH EIGENVALUE HAS NOT BEEN DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T(N)
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) Z(N,N)

  IERR = 0

  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E(I-1) = E(I)
  END DO
  E(N) = 0.0D+00

  DO L = 1, N

    J = 0
!
!  LOOK FOR A SMALL SUB-DIAGONAL ELEMENT.
!
105 CONTINUE

    DO M = L, N

      IF ( M == N ) THEN
        EXIT
      END IF

      TST1 = ABS ( D(M) ) + ABS ( D(M+1) )
      TST2 = TST1 + ABS ( E(M) )

      IF ( TST2 == TST1 ) THEN
        EXIT
      END IF

    END DO

    P = D(L)

    IF ( M == L ) THEN
      CYCLE
    END IF

    IF ( 30 <= J ) THEN
      IERR = L
      RETURN
    END IF

    J = J + 1
!
!  FORM SHIFT.
!
    G = ( D(L+1) - P ) / ( 2.0D+00 * E(L) )
    R = PYTHAG ( G, 1.0D+00 )
    G = D(M) - P + E(L) / ( G + SIGN ( R, G ) )
    S = 1.0D+00
    C = 1.0D+00
    P = 0.0D+00
    MML = M - L

    DO II = 1, MML

      I = M - II
      F = S * E(I)
      B = C * E(I)
      R = PYTHAG ( F, G )
      E(I+1) = R
!
!  RECOVER FROM UNDERFLOW.
!
      IF ( R == 0.0D+00 ) THEN
        D(I+1) = D(I+1) - P
        E(M) = 0.0D+00
        GO TO 105
      END IF

      S = F / R
      C = G / R
      G = D(I+1) - P
      R = ( D(I) - G ) * S + 2.0D+00 * C * B
      P = S * R
      D(I+1) = G + P
      G = C * R - B
!
!  FORM VECTOR.
!
      DO K = 1, N
        F = Z(K,I+1)
        Z(K,I+1) = S * Z(K,I) + C * F
        Z(K,I) = C * Z(K,I) - S * F
      END DO

    END DO

    D(L) = D(L) - P
    E(L) = G
    E(M) = 0.0D+00
    GO TO 105

  END DO
!
!  ORDER EIGENVALUES AND EIGENVECTORS.
!
  DO II = 2, N

    I = II - 1
    K = I
    P = D(I)

    DO J = II, N
      IF ( D(J) < P ) THEN
        K = J
        P = D(J)
      END IF
    END DO

    IF ( K /= I ) THEN

      D(K) = D(I)
      D(I) = P

      T(1:N)   = Z(1:N,I)
      Z(1:N,I) = Z(1:N,K)
      Z(1:N,K) = T(1:N)

    END IF

  END DO

  RETURN
END
SUBROUTINE IMTQLV ( N, D, E, E2, W, IND, IERR )

!*****************************************************************************80
!
!! IMTQLV COMPUTES ALL EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC TRIDIAGONAL
!    MATRIX BY THE IMPLICIT QL METHOD AND ASSOCIATES WITH THEM
!    THEIR CORRESPONDING SUBMATRIX INDICES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
!    IN E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N).  ON INPUT, THE SQUARES OF THE
!    CORRESPONDING ELEMENTS OF E.  E2(1) IS ARBITRARY.  ON OUTPUT, ELEMENTS OF E2
!    CORRESPONDING TO ELEMENTS OF E REGARDED AS NEGLIGIBLE HAVE BEEN
!    REPLACED BY ZERO, CAUSING THE MATRIX TO SPLIT INTO A DIRECT SUM OF
!    SUBMATRICES.  E2(1) IS ALSO SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.  IF AN
!    ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT AND ORDERED FOR
!    INDICES 1,2,...IERR-1, BUT MAY NOT BE THE SMALLEST EIGENVALUES.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IND(N), THE SUBMATRIX INDICES ASSOCIATED WITH THE
!    CORRESPONDING EIGENVALUES IN W: 1 FOR EIGENVALUES BELONGING TO THE
!    FIRST SUBMATRIX FROM THE TOP, 2 FOR THOSE BELONGING TO THE SECOND
!    SUBMATRIX, AND SO ON.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE J-TH EIGENVALUE HAS NOT BEEN DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IND(N)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) S
  INTEGER ( KIND = 4 ) TAG
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) W(N)

  IERR = 0
  K = 0
  TAG = 0
  W(1:N) = D(1:N)
  E2(1) = 0.0D+00
  RV1(1:N-1) = E(2:N)
  RV1(N) = 0.0D+00

  DO L = 1, N

    J = 0
!
!  LOOK FOR A SMALL SUB-DIAGONAL ELEMENT.
!
105 CONTINUE

     DO M = L, N

       IF ( M == N ) THEN
         EXIT
       END IF

       TST1 = ABS ( W(M) ) + ABS ( W(M+1) )
       TST2 = TST1 + ABS ( RV1(M) )

       IF ( TST2 == TST1 ) THEN
         EXIT
       END IF
!
!  GUARD AGAINST UNDERFLOWED ELEMENT OF E2.
!
       IF ( E2(M+1) == 0.0D+00 ) GO TO 125

     END DO

120  CONTINUE

     IF ( M <= K ) GO TO 130

     IF ( M /= N ) E2(M+1) = 0.0D+00

125  CONTINUE

     K = M
     TAG = TAG + 1

130  CONTINUE

     P = W(L)

     IF ( M == L ) GO TO 215

     IF ( J >= 30 ) THEN
       IERR = L
       RETURN
     END IF

     J = J + 1
!
!  FORM SHIFT.
!
     G = ( W(L+1) - P ) / ( 2.0D+00 * RV1(L) )
     R = PYTHAG ( G, 1.0D+00 )
     G = W(M) - P + RV1(L) / (G + SIGN ( R, G ) )
     S = 1.0D+00
     C = 1.0D+00
     P = 0.0D+00
     MML = M - L

     DO II = 1, MML
       I = M - II
       F = S * RV1(I)
       B = C * RV1(I)
       R = PYTHAG ( F, G )
       RV1(I+1) = R

       IF ( R == 0.0D+00 ) GO TO 210

       S = F / R
       C = G / R
       G = W(I+1) - P
       R = ( W(I) - G ) * S + 2.0D+00 * C * B
       P = S * R
       W(I+1) = G + P
       G = C * R - B
     END DO

     W(L) = W(L) - P
     RV1(L) = G
     RV1(M) = 0.0D+00
     GO TO 105
!
!  RECOVER FROM UNDERFLOW.
!
210  CONTINUE

     W(I+1) = W(I+1) - P
     RV1(M) = 0.0D+00
     GO TO 105
!
!  ORDER THE EIGENVALUES.
!
215  CONTINUE

     DO II = 2, L
        I = L + 2 - II
        IF ( P >= W(I-1) ) GO TO 270
        W(I) = W(I-1)
        IND(I) = IND(I-1)
     END DO

     I = 1

  270   CONTINUE

     W(I) = P
     IND(I) = TAG

  END DO

  RETURN
END
SUBROUTINE INVIT ( N, A, WR, WI, SELECT, MM, M, Z, IERR )

!*****************************************************************************80
!
!! INVIT COMPUTES EIGENVECTORS GIVEN EIGENVALUES, FOR A REAL UPPER HESSENBERG MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVECTORS OF A REAL UPPER HESSENBERG
!    MATRIX CORRESPONDING TO SPECIFIED EIGENVALUES, USING INVERSE ITERATION.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), THE HESSENBERG MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N).  ON INPUT, THE REAL AND IMAGINARY
!    PARTS, RESPECTIVELY, OF THE EIGENVALUES OF THE MATRIX.  THE EIGENVALUES
!    MUST BE STORED IN A MANNER IDENTICAL TO THAT OF SUBROUTINE HQR,
!    WHICH RECOGNIZES POSSIBLE SPLITTING OF THE MATRIX.  ON OUTPUT,
!    WR MAY HAVE BEEN ALTERED SINCE CLOSE EIGENVALUES ARE PERTURBED
!    SLIGHTLY IN SEARCHING FOR INDEPENDENT EIGENVECTORS.
!
!    INPUT/OUTPUT, LOGICAL SELECT(N).  ON INPUT, SPECIFIES THE EIGENVECTORS
!    TO BE FOUND.  THE EIGENVECTOR CORRESPONDING TO THE J-TH EIGENVALUE IS
!    SPECIFIED BY SETTING SELECT(J) TO TRUE.  ON OUTPUT, SELECT MAY HAVE BEEN
!    ALTERED.  IF THE ELEMENTS CORRESPONDING TO A PAIR OF CONJUGATE COMPLEX
!    EIGENVALUES WERE EACH INITIALLY SET TO TRUE, THE PROGRAM RESETS THE
!    SECOND OF THE TWO ELEMENTS TO FALSE.
!
!    INPUT, INTEGER ( KIND = 4 ) MM, AN UPPER BOUND FOR THE NUMBER OF COLUMNS
!    REQUIRED TO STORE THE EIGENVECTORS TO BE FOUND.  NOTE THAT TWO COLUMNS ARE
!    REQUIRED TO STORE THE EIGENVECTOR CORRESPONDING TO A COMPLEX EIGENVALUE.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF COLUMNS ACTUALLY USED TO STORE
!    THE EIGENVECTORS.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,MM), THE REAL AND IMAGINARY PARTS OF THE EIGENVECTORS.
!    IF THE NEXT SELECTED EIGENVALUE IS REAL, THE NEXT COLUMN
!    OF Z CONTAINS ITS EIGENVECTOR.  IF THE EIGENVALUE IS COMPLEX, THE NEXT
!    TWO COLUMNS OF Z CONTAIN THE REAL AND IMAGINARY PARTS OF ITS EIGENVECTOR.
!    THE EIGENVECTORS ARE NORMALIZED SO THAT THE COMPONENT OF LARGEST
!    MAGNITUDE IS 1.  ANY VECTOR WHICH FAILS THE ACCEPTANCE TEST IS SET TO ZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    -(2*N+1), IF MORE THAN MM COLUMNS OF Z ARE NECESSARY TO STORE THE
!      EIGENVECTORS CORRESPONDING TO THE SPECIFIED EIGENVALUES.
!    -K, IF THE ITERATION CORRESPONDING TO THE K-TH VALUE FAILS,
!    -(N+K), IF BOTH ERROR SITUATIONS OCCUR.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) EPS3
  REAL    ( KIND = 8 ) GROWTO
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  REAL    ( KIND = 8 ) ILAMBD
  INTEGER ( KIND = 4 ) IP
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) KM1
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) MP
  INTEGER ( KIND = 4 ) N1
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) NORMV
  INTEGER ( KIND = 4 ) NS
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) RLAMBD
  REAL    ( KIND = 8 ) RM1(N,N)
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) RV2(N)
  INTEGER ( KIND = 4 ) S
  LOGICAL              SELECT(N)
  REAL    ( KIND = 8 ) T
  INTEGER ( KIND = 4 ) UK
  REAL    ( KIND = 8 ) UKROOT
  REAL    ( KIND = 8 ) W
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z(N,MM)

  IERR = 0
  UK = 0
  S = 1
!
!  THE VALUE OF IP IS:
!
!   0, REAL EIGENVALUE;
!   1, FIRST OF CONJUGATE COMPLEX PAIR;
!  -1, SECOND OF CONJUGATE COMPLEX PAIR.
!
  IP = 0
  N1 = N - 1

  DO K = 1, N

     IF ( WI(K) /= 0.0D+00 .AND. IP >= 0 ) THEN
       IP = 1
       IF ( SELECT(K) .AND. SELECT(K+1) ) SELECT(K+1) = .FALSE.
     END IF

     IF ( .NOT. SELECT(K) ) GO TO 960

     IF ( WI(K) /= 0.0D+00 ) THEN
       S = S + 1
     END IF

     IF ( S > MM ) GO TO 1000

     IF ( UK >= K ) GO TO 200
!
!  CHECK FOR POSSIBLE SPLITTING.
!
     DO UK = K, N
       IF ( UK == N ) THEN
         EXIT
       END IF
       IF ( A(UK+1,UK) == 0.0D+00 ) THEN
         EXIT
       END IF
     END DO
!
!  COMPUTE INFINITY NORM OF LEADING UK BY UK (HESSENBERG) MATRIX.
!
     NORM = 0.0D+00
     MP = 1

     DO I = 1, UK

       X = SUM ( ABS ( A(I,MP:UK) ) )
       NORM = MAX ( NORM, X )
       MP = I

     END DO
!
!  EPS3 REPLACES ZERO PIVOT IN DECOMPOSITION AND CLOSE ROOTS ARE MODIFIED
!  BY EPS3.
!
     IF ( NORM == 0.0D+00 ) THEN
       NORM = 1.0D+00
     END IF

     EPS3 = ABS ( NORM ) * EPSILON ( EPS3 )
!
!  GROWTO IS THE CRITERION FOR THE GROWTH.
!
     UKROOT = UK
     UKROOT = SQRT ( UKROOT )
     GROWTO = 0.1D+00 / UKROOT

200  CONTINUE

     RLAMBD = WR(K)
     ILAMBD = WI(K)
     IF ( K == 1 ) GO TO 280
     KM1 = K - 1
     GO TO 240
!
!  PERTURB EIGENVALUE IF IT IS CLOSE TO ANY PREVIOUS EIGENVALUE.
!
220 CONTINUE

     RLAMBD = RLAMBD + EPS3

240  CONTINUE

     DO II = 1, KM1
       I = K - II
       IF ( SELECT(I) .AND. ABS ( WR(I) - RLAMBD ) < EPS3 .AND. &
          ABS ( WI(I) - ILAMBD ) < EPS3 ) THEN
        GO TO 220
       END IF
     END DO

     WR(K) = RLAMBD
!
!  PERTURB CONJUGATE EIGENVALUE TO MATCH.
!
     WR(K+IP) = RLAMBD
!
!  FORM UPPER HESSENBERG A - RLAMBD*I (TRANSPOSED) AND INITIAL REAL VECTOR.
!
280  CONTINUE

     MP = 1

     DO I = 1, UK

        RM1(MP:UK,I) = A(I,MP:UK)

        RM1(I,I) = RM1(I,I) - RLAMBD
        MP = I
        RV1(I) = EPS3

     END DO

     ITS = 0

     IF ( ILAMBD /= 0.0D+00 ) GO TO 520
!
!  REAL EIGENVALUE.
!
!  TRIANGULAR DECOMPOSITION WITH INTERCHANGES, REPLACING ZERO PIVOTS BY EPS3.
!
     DO I = 2, UK

        MP = I - 1

        IF ( ABS ( RM1(MP,I) ) > ABS ( RM1(MP,MP) ) ) THEN

          DO J = MP, UK
            CALL R8_SWAP ( RM1(J,I), RM1(J,MP) )
          END DO

        END IF

        IF ( RM1(MP,MP) == 0.0D+00 ) THEN
          RM1(MP,MP) = EPS3
        END IF

        X = RM1(MP,I) / RM1(MP,MP)

        IF ( X /= 0.0D+00 ) THEN
          RM1(I:UK,I) = RM1(I:UK,I) - X * RM1(I:UK,MP)
        END IF

      END DO

      IF ( RM1(UK,UK) == 0.0D+00 ) THEN
        RM1(UK,UK) = EPS3
      END IF
!
!  BACK SUBSTITUTION FOR REAL VECTOR.
!
440   CONTINUE

      DO II = 1, UK

        I = UK + 1 - II
        Y = RV1(I)

        DO J = I+1, UK
          Y = Y - RM1(J,I) * RV1(J)
        END DO

        RV1(I) = Y / RM1(I,I)

     END DO

     GO TO 740
!
!  COMPLEX EIGENVALUE.
!
!  TRIANGULAR DECOMPOSITION WITH INTERCHANGES,
!  REPLACING ZERO PIVOTS BY EPS3.
!  STORE IMAGINARY PARTS IN UPPER TRIANGLE STARTING AT (1,3)
!
520  CONTINUE

     NS = N - S
     Z(1,S-1) = -ILAMBD
     Z(1,S) = 0.0D+00

     IF ( N /= 2 ) THEN
       RM1(1,3) = -ILAMBD
       Z(1,S-1) = 0.0D+00
       RM1(1,4:N) = 0.0D+00
     END IF

     DO I = 2, UK

        MP = I - 1
        W = RM1(MP,I)

        IF ( I < N ) THEN
          T = RM1(MP,I+1)
        ELSE IF ( I == N ) THEN
          T = Z(MP,S-1)
        END IF

        X = RM1(MP,MP) * RM1(MP,MP) + T * T

        IF ( W * W <= X ) GO TO 580

        X = RM1(MP,MP) / W
        Y = T / W
        RM1(MP,MP) = W

        IF ( I < N ) THEN
          RM1(MP,I+1) = 0.0D+00
        ELSE IF ( I == N ) THEN
          Z(MP,S-1) = 0.0D+00
        END IF

        DO J = I, UK

          W = RM1(J,I)
          RM1(J,I) = RM1(J,MP) - X * W
          RM1(J,MP) = W

          IF ( J >= N1 ) THEN
            L = J - NS
            Z(I,L) = Z(MP,L) - Y * W
            Z(MP,L) = 0.0D+00
          ELSE
            RM1(I,J+2) = RM1(MP,J+2) - Y * W
            RM1(MP,J+2) = 0.0D+00
          END IF

        END DO

        RM1(I,I) = RM1(I,I) - Y * ILAMBD

        IF ( I >= N1 ) THEN
          L = I - NS
          Z(MP,L) = -ILAMBD
          Z(I,L) = Z(I,L) + X * ILAMBD
        ELSE
          RM1(MP,I+2) = -ILAMBD
          RM1(I,I+2) = RM1(I,I+2) + X * ILAMBD
        END IF

        GO TO 640

580     CONTINUE

        IF ( X == 0.0D+00 ) THEN
          RM1(MP,MP) = EPS3
          IF ( I < N ) THEN
            RM1(MP,I+1) = 0.0D+00
          ELSE IF ( I == N ) THEN
            Z(MP,S-1) = 0.0D+00
          END IF
          T = 0.0D+00
          X = EPS3**2
        END IF

        W = W / X
        X = RM1(MP,MP) * W
        Y = -T * W

        DO J = I, UK
          IF ( J >= N1 ) THEN
            L = J - NS
            T = Z(MP,L)
            Z(I,L) = -X * T - Y * RM1(J,MP)
          ELSE
            T = RM1(MP,J+2)
            RM1(I,J+2) = -X * T - Y * RM1(J,MP)
          END IF
          RM1(J,I) = RM1(J,I) - X * RM1(J,MP) + Y * T
        END DO

        IF ( I >= N1 ) THEN
          L = I - NS
          Z(I,L) = Z(I,L) - ILAMBD
        ELSE
          RM1(I,I+2) = RM1(I,I+2) - ILAMBD
        END IF

640    CONTINUE

     END DO

     IF ( UK >= N1 ) THEN
       L = UK - NS
       T = Z(UK,L)
     ELSE
       T = RM1(UK,UK+2)
     END IF

     IF ( RM1(UK,UK) == 0.0D+00 .AND. T == 0.0D+00 ) THEN
       RM1(UK,UK) = EPS3
     END IF
!
!  BACK SUBSTITUTION FOR COMPLEX VECTOR.
!
660  CONTINUE

     DO II = 1, UK

        I = UK + 1 - II
        X = RV1(I)
        Y = 0.0D+00

        DO J = I+1, UK

          IF ( J >= N1 ) THEN
            T = Z(I,J-NS)
          ELSE
            T = RM1(I,J+2)
          END IF

          X = X - RM1(J,I) * RV1(J) + T * RV2(J)
          Y = Y - RM1(J,I) * RV2(J) - T * RV1(J)

        END DO

        IF ( I >= N1 ) THEN
          T = Z(I,I-NS)
        ELSE
          T = RM1(I,I+2)
        END IF

       CALL CDIV ( X, Y, RM1(I,I), T, RV1(I), RV2(I) )

     END DO
!
!  ACCEPTANCE TEST FOR REAL OR COMPLEX EIGENVECTOR AND NORMALIZATION.
!
740  CONTINUE

     ITS = ITS + 1
     NORM = 0.0D+00
     NORMV = 0.0D+00

     DO I = 1, UK
       IF ( ILAMBD == 0.0D+00 ) THEN
         X = ABS ( RV1(I) )
       ELSE
         X = PYTHAG ( RV1(I), RV2(I) )
       END IF
       IF ( NORMV < X )  THEN
         NORMV = X
         J = I
       END IF
       NORM = NORM + X
     END DO

     IF ( NORM < GROWTO ) GO TO 840
!
!  ACCEPT VECTOR.
!
     X = RV1(J)
     IF ( ILAMBD == 0.0D+00 ) THEN
       X = 1.0D+00 / X
     ELSE
       Y = RV2(J)
     END IF

     DO I = 1, UK
       IF ( ILAMBD == 0.0D+00 ) THEN
         Z(I,S) = RV1(I) * X
       ELSE
         CALL CDIV ( RV1(I), RV2(I), X, Y, Z(I,S-1), Z(I,S) )
       END IF
     END DO

     IF ( UK == N ) GO TO 940
     J = UK + 1
     GO TO 900
!
!  CHOOSE A NEW STARTING VECTOR.
!
840  CONTINUE

     IF ( ITS >= UK ) GO TO 880

     X = UKROOT
     Y = EPS3 / ( X + 1.0D+00 )

     RV1(1) = EPS3
     RV1(2:UK) = Y

     J = UK - ITS + 1
     RV1(J) = RV1(J) - EPS3 * X
     IF ( ILAMBD == 0.0D+00 ) GO TO 440
     GO TO 660
!
!  SET ERROR: UNACCEPTED EIGENVECTOR.
!
880  CONTINUE

     J = 1
     IERR = -K
!
!  SET REMAINING VECTOR COMPONENTS TO ZERO.
!
900  CONTINUE

     DO I = J, N
       Z(I,S) = 0.0D+00
       IF ( ILAMBD /= 0.0D+00 ) Z(I,S-1) = 0.0D+00
     END DO

940  CONTINUE

     S = S + 1

960  CONTINUE

     IF ( IP == (-1) ) THEN
       IP = 0
     END IF

     IF ( IP == 1 ) THEN
       IP = -1
     END IF

  END DO

  GO TO 1001
!
!  SET ERROR: UNDERESTIMATE OF EIGENVECTOR SPACE REQUIRED.
!
1000 CONTINUE

  IF ( IERR /= 0 ) THEN
    IERR = IERR - N
  END IF

  IF ( IERR == 0 ) THEN
    IERR = -(2 * N + 1)
  END IF

1001 CONTINUE

  M = S - 1 - ABS ( IP )

  RETURN
END
SUBROUTINE MINFIT ( NM, M, N, A, W, IP, B, IERR )

!*****************************************************************************80
!
!! MINFIT: LEAST SQUARES PROBLEM FOR A REAL OVERDETERMINED LINEAR SYSTEM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE IS PART OF AN ALGORITHM FOR SOLVING GENERAL LINEAR
!    SYSTEMS OF THE FORM A*X=B.
!
!    IT DETERMINES THE SINGULAR VALUE DECOMPOSITION
!      A = U * S * V'
!    OF A REAL M BY N RECTANGULAR MATRIX, FORMING U' * B
!    RATHER THAN U.  HOUSEHOLDER BIDIAGONALIZATION AND A VARIANT OF THE
!    QR ALGORITHM ARE USED.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) NM, THE LEADING DIMENSION OF THE
!    TWO-DIMENSIONAL ARRAYS.  NM MUST BE AT LEAST AS LARGE AS THE MAXIMUM
!    OF M AND N.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF ROWS OF A AND B.
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE NUMBER OF COLUMNS OF A, AND THE ORDER
!    OF V.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(NM,N). ON INPUT, THE RECTANGULAR
!    COEFFICIENT MATRIX.  ON OUTPUT, A HAS BEEN OVERWRITTEN BY THE ORTHOGONAL
!    MATRIX V OF THE DECOMPOSITION IN ITS FIRST N ROWS AND COLUMNS.  IF AN
!    ERROR EXIT IS MADE, THE COLUMNS OF V CORRESPONDING TO INDICES OF CORRECT
!    SINGULAR VALUES SHOULD BE CORRECT.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE SINGULAR VALUES OF A.  THESE ARE THE
!    DIAGONAL ELEMENTS OF S.  THEY ARE UNORDERED.  IF AN ERROR EXIT IS MADE, THE
!    SINGULAR VALUES SHOULD BE CORRECT FOR INDICES IERR+1, IERR+2,...,N.
!
!    INPUT, INTEGER ( KIND = 4 ) IP, IS THE NUMBER OF COLUMNS OF B.  IP CAN
!    BE ZERO.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(NM,IP).  ON INPUT, THE CONSTANT COLUMN
!    MATRIX.  ON OUTPUT, B HAS BEEN OVERWRITTEN BY U'*B.  IF AN ERROR EXIT IS
!    MADE, THE ROWS OF U'*B CORRESPONDING TO INDICES OF CORRECT SINGULAR VALUES
!    SHOULD BE CORRECT.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    K, IF THE K-TH SINGULAR VALUE HAS NOT BEEN DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IP
  INTEGER ( KIND = 4 ) N
  INTEGER ( KIND = 4 ) NM

  REAL    ( KIND = 8 ) A(NM,N)
  REAL    ( KIND = 8 ) B(NM,IP)
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) I1
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) K1
  INTEGER ( KIND = 4 ) KK
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) M1
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z

  IERR = 0
!
!  HOUSEHOLDER REDUCTION TO BIDIAGONAL FORM.
!
  G = 0.0D+00
  SCALE = 0.0D+00
  X = 0.0D+00

  DO I = 1, N

    L = I + 1
    RV1(I) = SCALE * G
    G = 0.0D+00
    S = 0.0D+00
    SCALE = 0.0D+00

    IF ( I <= M ) THEN

      SCALE = SUM ( ABS ( A(I:M,I) ) )

      IF ( SCALE /= 0.0D+00 ) THEN

        A(I:M,I) = A(I:M,I) / SCALE

        S = S + SUM ( A(I:M,I)**2 )

        F = A(I,I)
        G = - SIGN ( SQRT ( S ), F )
        H = F * G - S
        A(I,I) = F - G

        DO J = L, N

          S = DOT_PRODUCT ( A(I:M,I), A(I:M,J) )

          F = S / H
          A(I:M,J) = A(I:M,J) + F * A(I:M,I)

        END DO

        DO J = 1, IP

          S = DOT_PRODUCT ( A(I:M,I), B(I:M,J) )

          B(I:M,J) = B(I:M,J) + S * A(I:M,I) / H

        END DO

        A(I:M,I) = SCALE * A(I:M,I)

      END IF

    END IF

    W(I) = SCALE * G
    G = 0.0D+00
    S = 0.0D+00
    SCALE = 0.0D+00

    IF ( I <= M .AND. I /= N ) THEN

      DO K = L, N
        SCALE = SCALE + ABS ( A(I,K) )
      END DO

      IF ( SCALE /= 0.0D+00 ) THEN

        A(I,L:N) = A(I,L:N) / SCALE

        S = S + SUM ( A(I,L:N)**2 )

        F = A(I,L)
        G = - SIGN ( SQRT ( S ), F )
        H = F * G - S
        A(I,L) = F - G
        RV1(L:N) = A(I,L:N) / H

        DO J = L, M

          S = DOT_PRODUCT ( A(J,L:N), A(I,L:N) )

          A(J,L:N) = A(J,L:N) + S * RV1(L:N)

        END DO

        A(I,L:N) = SCALE * A(I,L:N)

      END IF

    END IF

    X = MAX ( X, ABS ( W(I) ) + ABS ( RV1(I) ) )

  END DO
!
!  ACCUMULATION OF RIGHT-HAND TRANSFORMATIONS.
!
  DO II = 1, N

    I = N + 1 - II

    IF ( I /= N ) THEN

      IF ( G /= 0.0D+00 ) THEN

        A(L:N,I) = ( A(I,L:N) / A(I,L) ) / G

        DO J = L, N

          S = DOT_PRODUCT ( A(I,L:N), A(L:N,J) )

          A(L:N,J) = A(L:N,J) + S * A(L:N,I)

        END DO

      END IF

      A(I,L:N) = 0.0D+00
      A(L:N,I) = 0.0D+00

    END IF

    A(I,I) = 1.0D+00
    G = RV1(I)
    L = I

  END DO

  IF ( M < N .AND. IP /= 0 ) THEN
    M1 = M + 1
    B(M+1:N,1:IP) = 0.0D+00
  END IF
!
!  DIAGONALIZATION OF THE BIDIAGONAL FORM.
!
  TST1 = X

  DO KK = 1, N

    K1 = N - KK
    K = K1 + 1
    ITS = 0
!
!  TEST FOR SPLITTING.
!
520 CONTINUE

    DO LL = 1, K

      L1 = K - LL
      L = L1 + 1
      TST2 = TST1 + ABS ( RV1(L) )

      IF ( TST2 == TST1 ) THEN
        GO TO 565
      END IF

      TST2 = TST1 + ABS ( W(K-LL) )

      IF ( TST2 == TST1 ) THEN
        EXIT
      END IF

    END DO
!
!  CANCELLATION OF RV1(L) IF L GREATER THAN 1.
!
540 CONTINUE

    C = 0.0D+00
    S = 1.0D+00

    DO I = L, K

      F = S * RV1(I)
      RV1(I) = C * RV1(I)
      TST2 = TST1 + ABS ( F)

      IF ( TST2 == TST1 ) THEN
        EXIT
      END IF

      G = W(I)
      H = PYTHAG ( F, G )
      W(I) = H
      C = G / H
      S = -F / H

      DO J = 1, IP
        Y = B(L1,J)
        Z = B(I,J)
        B(L1,J) = Y * C + Z * S
        B(I,J) = -Y * S + Z * C
      END DO

    END DO
!
!  TEST FOR CONVERGENCE.
!
565 CONTINUE

    Z = W(K)

    IF ( L == K ) GO TO 650
!
!  SHIFT FROM BOTTOM 2 BY 2 MINOR.
!
     IF ( ITS >= 30 ) THEN
       IERR = K
       RETURN
     END IF

     ITS = ITS + 1
     X = W(L)
     Y = W(K1)
     G = RV1(K1)
     H = RV1(K)
     F = 0.5D+00 * ( ( ( G + Z ) / H ) * ( ( G - Z ) / Y ) + Y / H - H / Y )
     G = PYTHAG ( F, 1.0D+00 )
     F = X - ( Z / X ) * Z + ( H / X ) * ( Y / ( F + SIGN ( G, F ) ) - H )
!
!  NEXT QR TRANSFORMATION.
!
     C = 1.0D+00
     S = 1.0D+00

     DO I1 = L, K1

        I = I1 + 1
        G = RV1(I)
        Y = W(I)
        H = S * G
        G = C * G
        Z = PYTHAG ( F, H )
        RV1(I1) = Z
        C = F / Z
        S = H / Z
        F = X * C + G * S
        G = -X * S + G * C
        H = Y * S
        Y = Y * C

        DO J = 1, N
          X = A(J,I1)
          Z = A(J,I)
          A(J,I1) = X * C + Z * S
          A(J,I) = -X * S + Z * C
        END DO

        Z = PYTHAG ( F, H )
        W(I1) = Z

        IF ( Z /= 0.0D+00 ) THEN
          C = F / Z
          S = H / Z
        END IF

        F = C * G + S * Y
        X = -S * G + C * Y

        DO J = 1, IP
          Y = B(I1,J)
          Z = B(I,J)
          B(I1,J) = Y * C + Z * S
          B(I,J) = -Y * S + Z * C
        END DO

     END DO

     RV1(L) = 0.0D+00
     RV1(K) = F
     W(K) = X
     GO TO 520
!
!  CONVERGENCE.
!
650 CONTINUE

    IF ( Z < 0.0D+00 ) THEN
      W(K) = - Z
      A(1:N,K) = - A(1:N,K)
    END IF

  END DO

  RETURN
END
SUBROUTINE ORTBAK ( N, LOW, IGH, A, ORT, M, Z )

!*****************************************************************************80
!
!! ORTBAK DETERMINES EIGENVECTORS BY UNDOING THE ORTHES TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A REAL GENERAL
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    UPPER HESSENBERG MATRIX DETERMINED BY ORTHES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1 AND IGH EQUAL
!    TO THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,IGH), CONTAINS INFORMATION ABOUT THE ORTHOGONAL
!    TRANSFORMATIONS USED IN THE REDUCTION BY ORTHES IN ITS STRICT
!    LOWER TRIANGLE.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ORT(IGH), CONTAINS FURTHER INFORMATION
!    ABOUT THE TRANSFORMATIONS USED IN THE REDUCTION BY ORTHES.  ON OUTPUT, ORT
!    HAS BEEN ALTERED.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF COLUMNS OF Z TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,N).  ON INPUT, THE REAL AND IMAGINARY
!    PARTS OF THE EIGENVECTORS TO BE BACK TRANSFORMED IN THE FIRST M COLUMNS.
!    ON OUTPUT, THE REAL AND IMAGINARY PARTS OF THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,IGH)
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) ORT(IGH)
  REAL    ( KIND = 8 ) Z(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF

  DO MP = IGH - 1, LOW + 1, -1

    IF ( A(MP,MP-1) /= 0.0D+00 ) THEN

      ORT(MP+1:IGH) = A(MP+1:IGH,MP-1)

      DO J = 1, M

        G = DOT_PRODUCT ( ORT(MP:IGH), Z(MP:IGH,J) )

        G = ( G / ORT(MP) ) / A(MP,MP-1)

        DO I = MP, IGH
          Z(I,J) = Z(I,J) + G * ORT(I)
        END DO

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE ORTHES ( N, LOW, IGH, A, ORT )

!*****************************************************************************80
!
!! ORTHES TRANSFORMS A REAL GENERAL MATRIX TO UPPER HESSENBERG FORM.
!
!  DISCUSSION:
!
!    GIVEN A REAL GENERAL MATRIX, THIS SUBROUTINE REDUCES A SUBMATRIX
!    SITUATED IN ROWS AND COLUMNS LOW THROUGH IGH TO UPPER HESSENBERG FORM BY
!    ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!  MODIFIED:
!
!    04 FEBRUARY 2003
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1 AND IGH = N.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, THE MATRIX.  ON OUTPUT,
!    THE HESSENBERG MATRIX.  INFORMATION ABOUT THE ORTHOGONAL TRANSFORMATIONS
!    USED IN THE REDUCTION IS STORED IN THE REMAINING TRIANGLE UNDER THE
!    HESSENBERG MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) ORT(IGH), CONTAINS FURTHER INFORMATION ABOUT THE
!    TRANSFORMATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) LA
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) ORT(IGH)
  REAL    ( KIND = 8 ) SCALE

  LA = IGH - 1

  DO M = LOW + 1, LA

     H = 0.0D+00
     ORT(M) = 0.0D+00
     SCALE = 0.0D+00
!
!  SCALE THE COLUMN.
!
     DO I = M, IGH
       SCALE = SCALE + ABS ( A(I,M-1) )
     END DO

     IF ( SCALE /= 0.0D+00 ) THEN

     MP = M + IGH

     DO II = M, IGH
       I = MP - II
       ORT(I) = A(I,M-1) / SCALE
       H = H + ORT(I) * ORT(I)
     END DO

     G = - SIGN ( SQRT ( H ), ORT(M) )
     H = H - ORT(M) * G
     ORT(M) = ORT(M) - G
!
!  FORM (I-(U*UT)/H) * A.
!
     DO J = M, N

        F = 0.0D+00

        DO II = M, IGH
          I = MP - II
          F = F + ORT(I) * A(I,J)
        END DO

        F = F / H

        DO I = M, IGH
          A(I,J) = A(I,J) - F * ORT(I)
        END DO

     END DO
!
!  FORM (I-(U*UT)/H) * A * (I-(U*UT)/H).
!
     DO I = 1, IGH

        F = 0.0D+00
        DO JJ = M, IGH
          J = MP - JJ
          F = F + ORT(J) * A(I,J)
        END DO

        A(I,M:IGH) = A(I,M:IGH) - F * ORT(M:IGH) / H

     END DO

     ORT(M) = SCALE * ORT(M)
     A(M,M-1) = SCALE * G

    END IF

  END DO

  RETURN
END
SUBROUTINE ORTRAN ( N, LOW, IGH, A, ORT, Z )

!*****************************************************************************80
!
!! ORTRAN ACCUMULATES SIMILARITY TRANSFORMATIONS GENERATED BY ORTHES.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE ACCUMULATES THE ORTHOGONAL SIMILARITY
!    TRANSFORMATIONS USED IN THE REDUCTION OF A REAL GENERAL
!    MATRIX TO UPPER HESSENBERG FORM BY ORTHES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) LOW, IGH, ARE DETERMINED BY THE BALANCING
!    ROUTINE BALANC.  IF BALANC HAS NOT BEEN USED, SET LOW = 1, IGH = N.
!
!    INPUT, REAL ( KIND = 8 ) A(N,IGH), CONTAINS INFORMATION ABOUT THE ORTHOGONAL
!    TRANSFORMATIONS USED IN THE REDUCTION BY ORTHES IN ITS STRICT LOWER
!    TRIANGLE.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) ORT(IGH), CONTAINS FURTHER INFORMATION
!    ABOUT THE TRANSFORMATIONS USED IN THE REDUCTION BY ORTHES.  ON OUTPUT, ORT
!    HAS BEEN FURTHER ALTERED.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION BY ORTHES.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) IGH
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,IGH)
  REAL    ( KIND = 8 ) G
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) KL
  INTEGER ( KIND = 4 ) LOW
  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) MP
  REAL    ( KIND = 8 ) ORT(IGH)
  REAL    ( KIND = 8 ) Z(N,N)
!
!  INITIALIZE Z TO THE IDENTITY MATRIX.
!
  Z(1:N,1:N) = 0.0D+00

  DO I = 1, N
    Z(I,I) = 1.0D+00
  END DO

  KL = IGH - LOW - 1

  IF ( KL < 1 ) THEN
    RETURN
  END IF

  DO MM = 1, KL

    MP = IGH - MM

    IF ( A(MP,MP-1) /= 0.0D+00 ) THEN

      ORT(MP+1:IGH) = A(MP+1:IGH,MP-1)

      DO J = MP, IGH

        G = DOT_PRODUCT ( ORT(MP:IGH), Z(MP:IGH,J) )

        G = ( G / ORT(MP) ) / A(MP,MP-1)

        Z(MP:IGH,J) = Z(MP:IGH,J) + G * ORT(MP:IGH)

      END DO

    END IF

  END DO

  RETURN
END
FUNCTION PYTHAG ( A, B )

!*****************************************************************************80
!
!! PYTHAG COMPUTES SQRT ( A * A + B * B ) CAREFULLY.
!
!  DISCUSSION:
!
!    THE FORMULA
!
!      PYTHAG = SQRT ( A * A + B * B )
!
!    IS REASONABLY ACCURATE, BUT CAN FAIL IF, FOR EXAMPLE, A**2 IS LARGER
!    THAN THE MACHINE OVERFLOW.  THE FORMULA CAN LOSE MOST OF ITS ACCURACY
!    IF THE SUM OF THE SQUARES IS VERY LARGE OR VERY SMALL.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  MODIFIED:
!
!    04 FEBRUARY 2003
!
!  PARAMETERS:
!
!    INPUT, REAL ( KIND = 8 ) A, B, THE TWO LEGS OF A RIGHT TRIANGLE.
!
!    OUTPUT, REAL ( KIND = 8 ) PYTHAG, THE LENGTH OF THE HYPOTENUSE.
!
  IMPLICIT NONE

  REAL    ( KIND = 8 ) A
  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) U

  P = MAX ( ABS ( A ), ABS ( B ) )

  IF ( P /= 0.0D+00 ) THEN

    R = ( MIN ( ABS ( A ), ABS ( B ) ) / P )**2

    DO

      T = 4.0D+00 + R

      IF ( T == 4.0D+00 ) THEN
        EXIT
      END IF

      S = R / T
      U = 1.0D+00 + 2.0D+00 * S
      P = U * P
      R = ( S / U )**2 * R

    END DO

  END IF

  PYTHAG = P

  RETURN
END
SUBROUTINE QZHES ( N, A, B, MATZ, Z )

!*****************************************************************************80
!
!! QZHES CARRIES OUT TRANSFORMATIONS FOR A GENERALIZED EIGENVALUE PROBLEM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE IS THE FIRST STEP OF THE QZ ALGORITHM
!    FOR SOLVING GENERALIZED MATRIX EIGENVALUE PROBLEMS.
!
!    THIS SUBROUTINE ACCEPTS A PAIR OF REAL GENERAL MATRICES AND
!    REDUCES ONE OF THEM TO UPPER HESSENBERG FORM AND THE OTHER
!    TO UPPER TRIANGULAR FORM USING ORTHOGONAL TRANSFORMATIONS.
!    IT IS USUALLY FOLLOWED BY QZIT, QZVAL AND, POSSIBLY, QZVEC.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, THE FIRST REAL GENERAL
!    MATRIX.  ON OUTPUT, A HAS BEEN REDUCED TO UPPER HESSENBERG FORM.  THE
!    ELEMENTS BELOW THE FIRST SUBDIAGONAL HAVE BEEN SET TO ZERO.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, A REAL GENERAL MATRIX.
!    ON OUTPUT, B HAS BEEN REDUCED TO UPPER TRIANGULAR FORM.  THE ELEMENTS
!    BELOW THE MAIN DIAGONAL HAVE BEEN SET TO ZERO.
!
!    INPUT, LOGICAL MATZ, SHOULD BE TRUE IF THE RIGHT HAND TRANSFORMATIONS
!    ARE TO BE ACCUMULATED FOR LATER USE IN COMPUTING EIGENVECTORS.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE PRODUCT OF THE RIGHT HAND
!    TRANSFORMATIONS IF MATZ IS TRUE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) LB
  LOGICAL              MATZ
  INTEGER ( KIND = 4 ) NK1
  INTEGER ( KIND = 4 ) NM1
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RHO
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) U1
  REAL    ( KIND = 8 ) U2
  REAL    ( KIND = 8 ) V1
  REAL    ( KIND = 8 ) V2
  REAL    ( KIND = 8 ) Z(N,N)
!
!  SET Z TO THE IDENTITY MATRIX.
!
  IF ( MATZ ) THEN

    Z(1:N,1:N) = 0.0D+00

    DO I = 1, N
      Z(I,I) = 1.0D+00
    END DO

  END IF
!
!  REDUCE B TO UPPER TRIANGULAR FORM.
!
  IF ( N <= 1 ) THEN
    RETURN
  END IF

  NM1 = N - 1

  DO L = 1, N-1

    L1 = L + 1

    S = SUM ( ABS ( B(L+1:N,L) ) )

    IF ( S /= 0.0D+00 ) THEN

      S = S + ABS ( B(L,L) )
      B(L:N,L) = B(L:N,L) / S

      R = SQRT ( SUM ( B(L:N,L)**2 ) )
      R = SIGN ( R, B(L,L) )
      B(L,L) = B(L,L) + R
      RHO = R * B(L,L)

      DO J = L+1, N

        T = DOT_PRODUCT ( B(L:N,L), B(L:N,J) )

        B(L:N,J) = B(L:N,J) - T * B(L:N,L) / RHO

      END DO

      DO J = 1, N

        T = DOT_PRODUCT ( B(L:N,L), A(L:N,J) )

        A(L:N,J) = A(L:N,J) - T * B(L:N,L) / RHO

      END DO

      B(L,L) = - S * R
      B(L+1:N,L) = 0.0D+00

    END IF

  END DO
!
!  REDUCE A TO UPPER HESSENBERG FORM, WHILE KEEPING B TRIANGULAR.
!
  IF ( N == 2 ) THEN
    RETURN
  END IF

  DO K = 1, N-2

     NK1 = NM1 - K

     DO LB = 1, NK1

        L = N - LB
        L1 = L + 1
!
!  ZERO A(L+1,K).
!
        S = ABS ( A(L,K) ) + ABS ( A(L1,K) )

        IF ( S /= 0.0D+00 ) THEN

        U1 = A(L,K) / S
        U2 = A(L1,K) / S
        R = SIGN ( SQRT ( U1**2 + U2**2 ), U1 )
        V1 =  -(U1 + R) / R
        V2 = -U2 / R
        U2 = V2 / V1

        DO J = K, N
          T = A(L,J) + U2 * A(L1,J)
          A(L,J) = A(L,J) + T * V1
          A(L1,J) = A(L1,J) + T * V2
        END DO

        A(L1,K) = 0.0D+00

        DO J = L, N
          T = B(L,J) + U2 * B(L1,J)
          B(L,J) = B(L,J) + T * V1
          B(L1,J) = B(L1,J) + T * V2
        END DO
!
!  ZERO B(L+1,L).
!
        S = ABS ( B(L1,L1) ) + ABS ( B(L1,L) )

        IF ( S /= 0.0 ) THEN

        U1 = B(L1,L1) / S
        U2 = B(L1,L) / S
        R = SIGN ( SQRT ( U1**2 + U2**2 ), U1 )
        V1 =  -( U1 + R ) / R
        V2 = -U2 / R
        U2 = V2 / V1

        DO I = 1, L1
          T = B(I,L1) + U2 * B(I,L)
          B(I,L1) = B(I,L1) + T * V1
          B(I,L) = B(I,L) + T * V2
        END DO

        B(L1,L) = 0.0D+00

        DO I = 1, N
          T = A(I,L1) + U2 * A(I,L)
          A(I,L1) = A(I,L1) + T * V1
          A(I,L) = A(I,L) + T * V2
        END DO

        IF ( MATZ ) THEN

          DO I = 1, N
            T = Z(I,L1) + U2 * Z(I,L)
            Z(I,L1) = Z(I,L1) + T * V1
            Z(I,L) = Z(I,L) + T * V2
          END DO

        END IF

        END IF

      END IF

    END DO

  END DO

  RETURN
END
SUBROUTINE QZIT ( N, A, B, EPS1, MATZ, Z, IERR )

!*****************************************************************************80
!
!! QZIT CARRIES OUT ITERATIONS TO SOLVE A GENERALIZED EIGENVALUE PROBLEM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE IS THE SECOND STEP OF THE QZ ALGORITHM
!    FOR SOLVING GENERALIZED MATRIX EIGENVALUE PROBLEMS.
!
!    THIS SUBROUTINE ACCEPTS A PAIR OF REAL MATRICES, ONE OF THEM
!    IN UPPER HESSENBERG FORM AND THE OTHER IN UPPER TRIANGULAR FORM.
!    IT REDUCES THE HESSENBERG MATRIX TO QUASI-TRIANGULAR FORM USING
!    ORTHOGONAL TRANSFORMATIONS WHILE MAINTAINING THE TRIANGULAR FORM
!    OF THE OTHER MATRIX.  IT IS USUALLY PRECEDED BY QZHES AND
!    FOLLOWED BY QZVAL AND, POSSIBLY, QZVEC.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, A REAL UPPER HESSENBERG MATRIX.
!    ON OUTPUT, A HAS BEEN REDUCED TO QUASI-TRIANGULAR FORM.  THE ELEMENTS
!    BELOW THE FIRST SUBDIAGONAL ARE STILL ZERO AND NO TWO CONSECUTIVE
!    SUBDIAGONAL ELEMENTS ARE NONZERO.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, A REAL UPPER TRIANGULAR MATRIX.
!    ON OUTPUT, B IS STILL IN UPPER TRIANGULAR FORM, ALTHOUGH ITS ELEMENTS
!    HAVE BEEN ALTERED.  THE LOCATION B(N,1) IS USED TO STORE EPS1 TIMES
!    THE NORM OF B FOR LATER USE BY QZVAL AND QZVEC.
!
!    INPUT, REAL ( KIND = 8 ) EPS1, A TOLERANCE USED TO DETERMINE NEGLIGIBLE
!    ELEMENTS.  EPS1 = 0.0 (OR NEGATIVE) MAY BE INPUT, IN WHICH CASE AN ELEMENT
!    WILL BE NEGLECTED ONLY IF IT IS LESS THAN ROUNDOFF ERROR TIMES THE
!    NORM OF ITS MATRIX.  IF THE INPUT EPS1 IS POSITIVE, THEN AN ELEMENT
!    WILL BE CONSIDERED NEGLIGIBLE IF IT IS LESS THAN EPS1 TIMES THE NORM
!    OF ITS MATRIX.  A POSITIVE VALUE OF EPS1 MAY RESULT IN FASTER EXECUTION,
!    BUT LESS ACCURATE RESULTS.
!
!    INPUT, LOGICAL MATZ, SHOULD BE TRUE IF THE RIGHT HAND TRANSFORMATIONS
!    ARE TO BE ACCUMULATED FOR LATER USE IN COMPUTING EIGENVECTORS.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,N).  IF MATZ IS FALSE, Z IS NOT REFERENCED.
!    OTHERWISE, ON INPUT, THE TRANSFORMATION MATRIX PRODUCED IN THE REDUCTION
!    BY QZHES, IF PERFORMED, OR ELSE THE IDENTITY MATRIX.  ON OUTPUT, Z
!    CONTAINS THE PRODUCT OF THE RIGHT HAND TRANSFORMATIONS FOR BOTH STEPS.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    J, IF THE LIMIT OF 30*N ITERATIONS IS EXHAUSTED WHILE THE J-TH
!      EIGENVALUE IS BEING SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) A1
  REAL    ( KIND = 8 ) A11
  REAL    ( KIND = 8 ) A12
  REAL    ( KIND = 8 ) A2
  REAL    ( KIND = 8 ) A21
  REAL    ( KIND = 8 ) A22
  REAL    ( KIND = 8 ) A3
  REAL    ( KIND = 8 ) A33
  REAL    ( KIND = 8 ) A34
  REAL    ( KIND = 8 ) A43
  REAL    ( KIND = 8 ) A44
  REAL    ( KIND = 8 ) ANI
  REAL    ( KIND = 8 ) ANORM
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) B11
  REAL    ( KIND = 8 ) B12
  REAL    ( KIND = 8 ) B22
  REAL    ( KIND = 8 ) B33
  REAL    ( KIND = 8 ) B34
  REAL    ( KIND = 8 ) B44
  REAL    ( KIND = 8 ) BNI
  REAL    ( KIND = 8 ) BNORM
  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM2
  INTEGER ( KIND = 4 ) ENORN
  REAL    ( KIND = 8 ) EP
  REAL    ( KIND = 8 ) EPS1
  REAL    ( KIND = 8 ) EPSA
  REAL    ( KIND = 8 ) EPSB
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) ISH
  INTEGER ( KIND = 4 ) ITN
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) K1
  INTEGER ( KIND = 4 ) K2
  INTEGER ( KIND = 4 ) KM1
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) LD
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) LM1
  INTEGER ( KIND = 4 ) LOR1
  LOGICAL              MATZ
  INTEGER ( KIND = 4 ) NA
  LOGICAL              NOTLAS
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SH
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) U1
  REAL    ( KIND = 8 ) U2
  REAL    ( KIND = 8 ) U3
  REAL    ( KIND = 8 ) V1
  REAL    ( KIND = 8 ) V2
  REAL    ( KIND = 8 ) V3
  REAL    ( KIND = 8 ) Z(N,N)

  IERR = 0
!
!  COMPUTE EPSA AND EPSB.
!
  ANORM = 0.0D+00
  BNORM = 0.0D+00

  DO I = 1, N

    IF ( I == 1 ) THEN
      ANI = 0.0D+00
    ELSE
      ANI = ABS ( A(I,I-1) )
    END IF

    BNI = 0.0D+00

    DO J = I, N
      ANI = ANI + ABS ( A(I,J) )
      BNI = BNI + ABS ( B(I,J) )
    END DO

    ANORM = MAX ( ANORM, ANI )
    BNORM = MAX ( BNORM, BNI )

  END DO

  IF ( ANORM == 0.0D+00 ) THEN
    ANORM = 1.0D+00
  END IF

  IF ( BNORM == 0.0D+00 ) THEN
    BNORM = 1.0D+00
  END IF

  EP = EPS1

  IF ( EP > 0.0D+00 ) THEN
    GO TO 50
  END IF
!
!  USE ROUNDOFF LEVEL IF EPS1 IS 0.
!
  EP = EPSILON ( EP )

50 CONTINUE

  EPSA = EP * ANORM
  EPSB = EP * BNORM
!
!  REDUCE A TO QUASI-TRIANGULAR FORM, WHILE KEEPING B TRIANGULAR.
!
  LOR1 = 1
  ENORN = N
  EN = N
  ITN = 30 * N
!
!  BEGIN QZ STEP.
!
60 CONTINUE

  IF ( EN <= 2 ) THEN
    GO TO 1001
  END IF

  IF (.NOT. MATZ) ENORN = EN
  ITS = 0
  NA = EN - 1
  ENM2 = NA - 1

70 CONTINUE

  ISH = 2
!
!  CHECK FOR CONVERGENCE OR REDUCIBILITY.
!
  DO LL = 1, EN
    LM1 = EN - LL
    L = LM1 + 1
    IF ( L == 1 ) GO TO 95
    IF ( ABS ( A(L,LM1) ) <= EPSA ) THEN
      EXIT
    END IF
  END DO

90 CONTINUE

  A(L,LM1) = 0.0D+00
  IF ( L < NA ) GO TO 95
!
!  1-BY-1 OR 2-BY-2 BLOCK ISOLATED.
!
  EN = LM1
  GO TO 60
!
!  CHECK FOR SMALL TOP OF B.
!
95 CONTINUE

  LD = L

100 CONTINUE

  L1 = L + 1
  B11 = B(L,L)

  IF ( ABS ( B11 ) > EPSB ) GO TO 120

  B(L,L) = 0.0D+00
  S = ABS ( A(L,L) ) + ABS ( A(L1,L) )
  U1 = A(L,L) / S
  U2 = A(L1,L) / S
  R = SIGN ( SQRT ( U1**2 + U2**2 ), U1 )
  V1 = - ( U1 + R ) / R
  V2 = -U2 / R
  U2 = V2 / V1

  DO J = L, ENORN
    T = A(L,J) + U2 * A(L1,J)
    A(L,J) = A(L,J) + T * V1
    A(L1,J) = A(L1,J) + T * V2
    T = B(L,J) + U2 * B(L1,J)
    B(L,J) = B(L,J) + T * V1
    B(L1,J) = B(L1,J) + T * V2
  END DO

  IF ( L /= 1 ) THEN
    A(L,LM1) = -A(L,LM1)
  END IF
  LM1 = L
  L = L1
  GO TO 90

120 CONTINUE

  A11 = A(L,L) / B11
  A21 = A(L1,L) / B11
  IF ( ISH == 1 ) GO TO 140
!
!  ITERATION STRATEGY.
!
  IF ( ITN == 0 ) GO TO 1000
  IF ( ITS == 10 ) GO TO 155
!
!  DETERMINE TYPE OF SHIFT.
!
  B22 = B(L1,L1)
  IF ( ABS ( B22 ) < EPSB ) B22 = EPSB
  B33 = B(NA,NA)
  IF ( ABS ( B33 ) < EPSB ) B33 = EPSB
  B44 = B(EN,EN)
  IF ( ABS ( B44 ) < EPSB ) B44 = EPSB
  A33 = A(NA,NA) / B33
  A34 = A(NA,EN) / B44
  A43 = A(EN,NA) / B33
  A44 = A(EN,EN) / B44
  B34 = B(NA,EN) / B44
  T = 0.5D+00 * (A43 * B34 - A33 - A44)
  R = T * T + A34 * A43 - A33 * A44

  IF ( R < 0.0D+00 ) GO TO 150
!
!  DETERMINE SINGLE SHIFT ZEROTH COLUMN OF A.
!
  ISH = 1
  R = SQRT ( R )
  SH = -T + R
  S = -T - R
  IF ( ABS ( S - A44 ) < ABS ( SH - A44 ) ) SH = S
!
!  LOOK FOR TWO CONSECUTIVE SMALL SUB-DIAGONAL ELEMENTS OF A.
!
  DO LL = LD, ENM2
    L = ENM2 + LD - LL
    IF ( L == LD ) THEN
      EXIT
    END IF
    LM1 = L - 1
    L1 = L + 1
    T = A(L,L)
    IF ( ABS ( B(L,L) ) > EPSB ) T = T - SH * B(L,L)
    IF ( ABS ( A(L,LM1) ) <= ABS ( T / A(L1,L) ) * EPSA ) GO TO 100
  END DO

140 CONTINUE

  A1 = A11 - SH
  A2 = A21

  IF ( L /= LD ) THEN
    A(L,LM1) = -A(L,LM1)
  END IF

  GO TO 160
!
!  DETERMINE DOUBLE SHIFT ZEROTH COLUMN OF A.
!
150 CONTINUE

  A12 = A(L,L1) / B22
  A22 = A(L1,L1) / B22
  B12 = B(L,L1) / B22
  A1 = ( ( A33 - A11 ) * ( A44 - A11 ) - A34 * A43 + A43 * B34 * A11 ) &
    / A21 + A12 - A11 * B12
  A2 = (A22 - A11) - A21 * B12 - (A33 - A11) - (A44 - A11) + A43 * B34
  A3 = A(L1+1,L1) / B22
  GO TO 160
!
!  AD HOC SHIFT.
!
155 CONTINUE

  A1 = 0.0D+00
  A2 = 1.0D+00
  A3 = 1.1605D+00

  160 CONTINUE
  ITS = ITS + 1
  ITN = ITN - 1
  IF ( .NOT. MATZ ) LOR1 = LD
!
!  MAIN LOOP.
!
  DO K = L, NA

     NOTLAS = K /= NA .AND. ISH == 2
     K1 = K + 1
     K2 = K + 2
     KM1 = MAX ( K-1, L )
     LL = MIN ( EN, K1+ISH )

     IF ( NOTLAS ) GO TO 190
!
!  ZERO A(K+1,K-1).
!
     IF ( K /= L ) THEN
       A1 = A(K,KM1)
       A2 = A(K1,KM1)
     END IF

     S = ABS ( A1 ) + ABS ( A2 )

     IF ( S == 0.0D+00 ) GO TO 70

     U1 = A1 / S
     U2 = A2 / S
     R = SIGN ( SQRT ( U1**2 + U1**2 ), U1 )
     V1 = -( U1 + R ) / R
     V2 = -U2 / R
     U2 = V2 / V1

     DO J = KM1, ENORN
       T = A(K,J) + U2 * A(K1,J)
       A(K,J) = A(K,J) + T * V1
       A(K1,J) = A(K1,J) + T * V2
       T = B(K,J) + U2 * B(K1,J)
       B(K,J) = B(K,J) + T * V1
       B(K1,J) = B(K1,J) + T * V2
     END DO

     IF ( K /= L ) THEN
       A(K1,KM1) = 0.0D+00
     END IF

     GO TO 240
!
!  ZERO A(K+1,K-1) AND A(K+2,K-1).
!
190  CONTINUE

     IF ( K /= L ) THEN
       A1 = A(K,KM1)
       A2 = A(K1,KM1)
       A3 = A(K2,KM1)
     END IF

     S = ABS ( A1 ) + ABS ( A2 ) + ABS ( A3 )

     IF ( S == 0.0D+00 ) GO TO 260

     U1 = A1 / S
     U2 = A2 / S
     U3 = A3 / S
     R = SIGN ( SQRT ( U1**2 + U2**2 + U3**2 ), U1 )
     V1 = -(U1 + R) / R
     V2 = -U2 / R
     V3 = -U3 / R
     U2 = V2 / V1
     U3 = V3 / V1

     DO J = KM1, ENORN
       T = A(K,J) + U2 * A(K1,J) + U3 * A(K2,J)
       A(K,J) = A(K,J) + T * V1
       A(K1,J) = A(K1,J) + T * V2
       A(K2,J) = A(K2,J) + T * V3
       T = B(K,J) + U2 * B(K1,J) + U3 * B(K2,J)
       B(K,J) = B(K,J) + T * V1
       B(K1,J) = B(K1,J) + T * V2
       B(K2,J) = B(K2,J) + T * V3
     END DO

     IF ( K /= L ) THEN
       A(K1,KM1) = 0.0D+00
       A(K2,KM1) = 0.0D+00
     END IF
!
!  ZERO B(K+2,K+1) AND B(K+2,K).
!
     S = ABS ( B(K2,K2) ) + ABS ( B(K2,K1) ) + ABS ( B(K2,K) )
     IF ( S == 0.0D+00 ) GO TO 240
     U1 = B(K2,K2) / S
     U2 = B(K2,K1) / S
     U3 = B(K2,K) / S
     R = SIGN ( SQRT ( U1**2 + U2**2 + U3**2 ), U1 )
     V1 = -(U1 + R) / R
     V2 = -U2 / R
     V3 = -U3 / R
     U2 = V2 / V1
     U3 = V3 / V1

     DO I = LOR1, LL
       T = A(I,K2) + U2 * A(I,K1) + U3 * A(I,K)
       A(I,K2) = A(I,K2) + T * V1
       A(I,K1) = A(I,K1) + T * V2
       A(I,K) = A(I,K) + T * V3
       T = B(I,K2) + U2 * B(I,K1) + U3 * B(I,K)
       B(I,K2) = B(I,K2) + T * V1
       B(I,K1) = B(I,K1) + T * V2
       B(I,K) = B(I,K) + T * V3
     END DO

     B(K2,K) = 0.0D+00
     B(K2,K1) = 0.0D+00

     IF ( MATZ ) THEN

       DO I = 1, N
         T = Z(I,K2) + U2 * Z(I,K1) + U3 * Z(I,K)
         Z(I,K2) = Z(I,K2) + T * V1
         Z(I,K1) = Z(I,K1) + T * V2
         Z(I,K) = Z(I,K) + T * V3
       END DO

     END IF
!
!  ZERO B(K+1,K).
!
240  CONTINUE

     S = ABS ( B(K1,K1) ) + ABS ( B(K1,K) )

     IF ( S /= 0.0D+00 ) THEN

     U1 = B(K1,K1) / S
     U2 = B(K1,K) / S
     R = SIGN ( SQRT ( U1**2 + U2**2 ), U1 )
     V1 = -( U1 + R ) / R
     V2 = -U2 / R
     U2 = V2 / V1

     DO I = LOR1, LL
       T = A(I,K1) + U2 * A(I,K)
       A(I,K1) = A(I,K1) + T * V1
       A(I,K) = A(I,K) + T * V2
       T = B(I,K1) + U2 * B(I,K)
       B(I,K1) = B(I,K1) + T * V1
       B(I,K) = B(I,K) + T * V2
     END DO

     B(K1,K) = 0.0D+00

     IF ( MATZ ) THEN

       DO I = 1, N
         T = Z(I,K1) + U2 * Z(I,K)
         Z(I,K1) = Z(I,K1) + T * V1
         Z(I,K) = Z(I,K) + T * V2
       END DO

     END IF

   END IF

260  CONTINUE

  END DO

  GO TO 70
!
!  SET ERROR: NOT ALL EIGENVALUES HAVE CONVERGED AFTER 30*N ITERATIONS.
!
1000 CONTINUE

  IERR = EN
!
!  SAVE EPSB FOR USE BY QZVAL AND QZVEC.
!
 1001 CONTINUE

  IF ( N > 1 ) THEN
    B(N,1) = EPSB
  END IF

  RETURN
END
SUBROUTINE QZVAL ( N, A, B, ALFR, ALFI, BETA, MATZ, Z )

!*****************************************************************************80
!
!! QZVAL COMPUTES EIGENVALUES FOR A GENERALIZED EIGENVALUE PROBLEM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE IS THE THIRD STEP OF THE QZ ALGORITHM
!    FOR SOLVING GENERALIZED MATRIX EIGENVALUE PROBLEMS.
!
!    THIS SUBROUTINE ACCEPTS A PAIR OF REAL MATRICES, ONE OF THEM
!    IN QUASI-TRIANGULAR FORM AND THE OTHER IN UPPER TRIANGULAR FORM.
!    IT REDUCES THE QUASI-TRIANGULAR MATRIX FURTHER, SO THAT ANY
!    REMAINING 2-BY-2 BLOCKS CORRESPOND TO PAIRS OF COMPLEX
!    EIGENVALUES, AND RETURNS QUANTITIES WHOSE RATIOS GIVE THE
!    GENERALIZED EIGENVALUES.  IT IS USUALLY PRECEDED BY QZHES
!    AND QZIT AND MAY BE FOLLOWED BY QZVEC.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, A REAL UPPER
!    QUASI-TRIANGULAR MATRIX.  ON OUTPUT, A HAS BEEN REDUCED FURTHER TO A
!    QUASI-TRIANGULAR MATRIX IN WHICH ALL NONZERO SUBDIAGONAL ELEMENTS
!    CORRESPOND TO PAIRS OF COMPLEX EIGENVALUES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, A REAL UPPER TRIANGULAR MATRIX.
!    IN ADDITION, LOCATION B(N,1) CONTAINS THE TOLERANCE QUANTITY EPSB
!    COMPUTED AND SAVED IN QZIT.  ON OUTPUT, B IS STILL IN UPPER TRIANGULAR
!    FORM, ALTHOUGH ITS ELEMENTS HAVE BEEN ALTERED.  B(N,1) IS UNALTERED.
!
!    OUTPUT, REAL ( KIND = 8 ) ALFR(N), ALFI(N), THE REAL AND IMAGINARY PARTS OF THE
!    DIAGONAL ELEMENTS OF THE TRIANGULAR MATRIX THAT WOULD BE OBTAINED
!    IF A WERE REDUCED COMPLETELY TO TRIANGULAR FORM BY UNITARY
!    TRANSFORMATIONS.  NON-ZERO VALUES OF ALFI OCCUR IN PAIRS, THE FIRST
!    MEMBER POSITIVE AND THE SECOND NEGATIVE.
!
!    OUTPUT, REAL ( KIND = 8 ) BETA(N), THE DIAGONAL ELEMENTS OF THE CORRESPONDING B,
!    NORMALIZED TO BE REAL AND NON-NEGATIVE.  THE GENERALIZED EIGENVALUES
!    ARE THEN THE RATIOS (ALFR + I * ALFI) / BETA.
!
!    INPUT, LOGICAL MATZ, SHOULD BE TRUE IF THE RIGHT HAND TRANSFORMATIONS
!    ARE TO BE ACCUMULATED FOR LATER USE IN COMPUTING EIGENVECTORS, AND
!    TO FALSE OTHERWISE.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,N), IS ONLY USED IF MATZ IS TRUE.
!    ON INPUT, THE TRANSFORMATION MATRIX PRODUCED IN THE REDUCTIONS BY QZHES
!    AND QZIT, IF PERFORMED, OR ELSE THE IDENTITY MATRIX.  ON OUTPUT,
!    THE PRODUCT OF THE RIGHT HAND TRANSFORMATIONS FOR ALL THREE STEPS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) A1
  REAL    ( KIND = 8 ) A11
  REAL    ( KIND = 8 ) A11I
  REAL    ( KIND = 8 ) A11R
  REAL    ( KIND = 8 ) A12
  REAL    ( KIND = 8 ) A12I
  REAL    ( KIND = 8 ) A12R
  REAL    ( KIND = 8 ) A1I
  REAL    ( KIND = 8 ) A2
  REAL    ( KIND = 8 ) A21
  REAL    ( KIND = 8 ) A22
  REAL    ( KIND = 8 ) A22I
  REAL    ( KIND = 8 ) A22R
  REAL    ( KIND = 8 ) A2I
  REAL    ( KIND = 8 ) AN
  REAL    ( KIND = 8 ) ALFI(N)
  REAL    ( KIND = 8 ) ALFR(N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) B11
  REAL    ( KIND = 8 ) B12
  REAL    ( KIND = 8 ) B22
  REAL    ( KIND = 8 ) BETA(N)
  REAL    ( KIND = 8 ) BN
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) CQ
  REAL    ( KIND = 8 ) CZ
  REAL    ( KIND = 8 ) D
  REAL    ( KIND = 8 ) DI
  REAL    ( KIND = 8 ) DR
  REAL    ( KIND = 8 ) E
  REAL    ( KIND = 8 ) EI
  INTEGER ( KIND = 4 ) EN
  REAL    ( KIND = 8 ) EPSB
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) ISW
  INTEGER ( KIND = 4 ) J
  LOGICAL              MATZ
  INTEGER ( KIND = 4 ) NA
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SQI
  REAL    ( KIND = 8 ) SQR
  REAL    ( KIND = 8 ) SSI
  REAL    ( KIND = 8 ) SSR
  REAL    ( KIND = 8 ) SZI
  REAL    ( KIND = 8 ) SZR
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) U1
  REAL    ( KIND = 8 ) U2
  REAL    ( KIND = 8 ) V1
  REAL    ( KIND = 8 ) V2
  REAL    ( KIND = 8 ) Z(N,N)

  EPSB = B(N,1)
  ISW = 1
!
!  FIND EIGENVALUES OF QUASI-TRIANGULAR MATRICES.
!
  DO NN = 1, N

     EN = N + 1 - NN
     NA = EN - 1

     IF ( ISW == 2 ) GO TO 505

     IF ( EN == 1 ) GO TO 410

     IF ( A(EN,NA) /= 0.0D+00 ) GO TO 420
!
!  1-BY-1 BLOCK, ONE REAL ROOT.
!
410  CONTINUE

     ALFR(EN) = A(EN,EN)
     IF ( B(EN,EN) < 0.0D+00 ) ALFR(EN) = -ALFR(EN)
     BETA(EN) = ABS ( B(EN,EN) )
     ALFI(EN) = 0.0D+00
     GO TO 510
!
!  2-BY-2 BLOCK.
!
420  CONTINUE

     IF ( ABS ( B(NA,NA) ) <= EPSB ) THEN
       A1 = A(NA,NA)
       A2 = A(EN,NA)
       GO TO 460
     END IF

     IF ( ABS ( B(EN,EN) ) <= EPSB ) THEN
       A1 = A(EN,EN)
       A2 = A(EN,NA)
       BN = 0.0D+00
       GO TO 435
     END IF

     AN = ABS ( A(NA,NA) ) + ABS ( A(NA,EN) ) + ABS ( A(EN,NA) ) &
       + ABS ( A(EN,EN) )
     BN = ABS ( B(NA,NA) ) + ABS ( B(NA,EN) ) + ABS ( B(EN,EN) )
     A11 = A(NA,NA) / AN
     A12 = A(NA,EN) / AN
     A21 = A(EN,NA) / AN
     A22 = A(EN,EN) / AN
     B11 = B(NA,NA) / BN
     B12 = B(NA,EN) / BN
     B22 = B(EN,EN) / BN
     E = A11 / B11
     EI = A22 / B22
     S = A21 / ( B11 * B22 )
     T = ( A22 - E * B22 ) / B22

     IF ( ABS ( E ) > ABS ( EI ) ) THEN
       E = EI
       T = ( A11 - E * B11 ) / B11
     END IF

     C = 0.5D+00 * ( T - S * B12 )
     D = C**2 + S * ( A12 - E * B12 )

     IF ( D < 0.0D+00 ) THEN
       GO TO 480
     END IF
!
!  TWO REAL ROOTS.
!  ZERO BOTH A(EN,NA) AND B(EN,NA).
!
     E = E + ( C + SIGN ( SQRT ( D ), C ) )
     A11 = A11 - E * B11
     A12 = A12 - E * B12
     A22 = A22 - E * B22

     IF ( ABS ( A11 ) + ABS ( A12 ) >= ABS ( A21 ) + ABS ( A22 ) ) THEN
       A1 = A12
       A2 = A11
     ELSE
       A1 = A22
       A2 = A21
     END IF
!
!  CHOOSE AND APPLY REAL Z.
!
435  CONTINUE

     S = ABS ( A1 ) + ABS ( A2 )
     U1 = A1 / S
     U2 = A2 / S
     R = SIGN ( SQRT ( U1**2 + U2**2 ), U1 )
     V1 = - ( U1 + R ) / R
     V2 = - U2 / R
     U2 = V2 / V1

     DO I = 1, EN
       T = A(I,EN) + U2 * A(I,NA)
       A(I,EN) = A(I,EN) + T * V1
       A(I,NA) = A(I,NA) + T * V2
       T = B(I,EN) + U2 * B(I,NA)
       B(I,EN) = B(I,EN) + T * V1
       B(I,NA) = B(I,NA) + T * V2
     END DO

     IF ( MATZ ) THEN

       DO I = 1, N
         T = Z(I,EN) + U2 * Z(I,NA)
         Z(I,EN) = Z(I,EN) + T * V1
         Z(I,NA) = Z(I,NA) + T * V2
       END DO

     END IF

450  CONTINUE

     IF ( BN == 0.0D+00 ) GO TO 475

     IF ( AN >= ABS ( E ) * BN ) THEN
       A1 = B(NA,NA)
       A2 = B(EN,NA)
     ELSE
       A1 = A(NA,NA)
       A2 = A(EN,NA)
     END IF
!
!  CHOOSE AND APPLY REAL Q.
!
460  CONTINUE

     S = ABS ( A1 ) + ABS ( A2 )
     IF ( S == 0.0D+00 ) GO TO 475
     U1 = A1 / S
     U2 = A2 / S
     R = SIGN ( SQRT ( U1**2 + U2**2 ), U1 )
     V1 = -(U1 + R) / R
     V2 = -U2 / R
     U2 = V2 / V1

     DO J = NA, N
       T = A(NA,J) + U2 * A(EN,J)
       A(NA,J) = A(NA,J) + T * V1
       A(EN,J) = A(EN,J) + T * V2
       T = B(NA,J) + U2 * B(EN,J)
       B(NA,J) = B(NA,J) + T * V1
       B(EN,J) = B(EN,J) + T * V2
     END DO

475  CONTINUE

     A(EN,NA) = 0.0D+00
     B(EN,NA) = 0.0D+00
     ALFR(NA) = A(NA,NA)
     ALFR(EN) = A(EN,EN)
     IF ( B(NA,NA) < 0.0D+00 ) ALFR(NA) = -ALFR(NA)
     IF ( B(EN,EN) < 0.0D+00 ) ALFR(EN) = -ALFR(EN)
     BETA(NA) = ABS ( B(NA,NA) )
     BETA(EN) = ABS ( B(EN,EN) )
     ALFI(EN) = 0.0D+00
     ALFI(NA) = 0.0D+00
     GO TO 505
!
!  TWO COMPLEX ROOTS.
!
480  CONTINUE

     E = E + C
     EI = SQRT ( -D )
     A11R = A11 - E * B11
     A11I = EI * B11
     A12R = A12 - E * B12
     A12I = EI * B12
     A22R = A22 - E * B22
     A22I = EI * B22

     IF ( ABS ( A11R ) + ABS ( A11I ) + ABS ( A12R ) + ABS ( A12I ) >= &
            ABS ( A21 ) + ABS ( A22R ) + ABS ( A22I ) ) THEN
       A1 = A12R
       A1I = A12I
       A2 = -A11R
       A2I = -A11I
     ELSE
       A1 = A22R
       A1I = A22I
       A2 = -A21
       A2I = 0.0D+00
     END IF
!
!  CHOOSE COMPLEX Z.
!
     CZ = SQRT ( A1**2 + A1I**2 )

     IF ( CZ /= 0.0D+00 ) THEN
       SZR = ( A1 * A2 + A1I * A2I) / CZ
       SZI = ( A1 * A2I - A1I * A2) / CZ
       R = SQRT ( CZ**2 + SZR**2 + SZI**2 )
       CZ = CZ / R
       SZR = SZR / R
       SZI = SZI / R
     ELSE
       SZR = 1.0D+00
       SZI = 0.0D+00
     END IF

     IF ( AN >= ( ABS ( E ) + EI ) * BN ) THEN
       A1 = CZ * B11 + SZR * B12
       A1I = SZI * B12
       A2 = SZR * B22
       A2I = SZI * B22
     ELSE
       A1 = CZ * A11 + SZR * A12
       A1I = SZI * A12
       A2 = CZ * A21 + SZR * A22
       A2I = SZI * A22
     END IF
!
!  CHOOSE COMPLEX Q.
!
     CQ = SQRT ( A1**2 + A1I**2 )

     IF ( CQ /= 0.0D+00 ) THEN
       SQR = ( A1 * A2 + A1I * A2I ) / CQ
       SQI = ( A1 * A2I - A1I * A2 ) / CQ
       R = SQRT ( CQ**2 + SQR**2 + SQI**2 )
       CQ = CQ / R
       SQR = SQR / R
       SQI = SQI / R
     ELSE
       SQR = 1.0D+00
       SQI = 0.0D+00
     END IF
!
!  COMPUTE DIAGONAL ELEMENTS THAT WOULD RESULT IF TRANSFORMATIONS WERE APPLIED.
!
     SSR = SQR * SZR + SQI * SZI
     SSI = SQR * SZI - SQI * SZR
     I = 1
     TR = CQ * CZ * A11 + CQ * SZR * A12 + SQR * CZ * A21 + SSR * A22
     TI = CQ * SZI * A12 - SQI * CZ * A21 + SSI * A22
     DR = CQ * CZ * B11 + CQ * SZR * B12 + SSR * B22
     DI = CQ * SZI * B12 + SSI * B22
     GO TO 503

502  CONTINUE

     I = 2
     TR = SSR * A11 - SQR * CZ * A12 - CQ * SZR * A21 + CQ * CZ * A22
     TI = -SSI * A11 - SQI * CZ * A12 + CQ * SZI * A21
     DR = SSR * B11 - SQR * CZ * B12 + CQ * CZ * B22
     DI = -SSI * B11 - SQI * CZ * B12

503  CONTINUE

     T = TI * DR - TR * DI

     IF ( T < 0.0D+00 ) THEN
       J = EN
     ELSE
       J = NA
     END IF

     R = SQRT ( DR**2 + DI**2 )
     BETA(J) = BN * R
     ALFR(J) = AN * (TR * DR + TI * DI) / R
     ALFI(J) = AN * T / R

     IF ( I == 1 ) GO TO 502

505  CONTINUE

     ISW = 3 - ISW

510  CONTINUE

  END DO

  B(N,1) = EPSB

  RETURN
END
SUBROUTINE QZVEC ( N, A, B, ALFR, ALFI, BETA, Z )

!*****************************************************************************80
!
!! QZVEC COMPUTES EIGENVECTORS FOR A GENERALIZED EIGENVALUE PROBLEM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE IS THE OPTIONAL FOURTH STEP OF THE QZ ALGORITHM
!    FOR SOLVING GENERALIZED MATRIX EIGENVALUE PROBLEMS.
!
!    THIS SUBROUTINE ACCEPTS A PAIR OF REAL MATRICES, ONE OF THEM IN
!    QUASI-TRIANGULAR FORM (IN WHICH EACH 2-BY-2 BLOCK CORRESPONDS TO
!    A PAIR OF COMPLEX EIGENVALUES) AND THE OTHER IN UPPER TRIANGULAR
!    FORM.  IT COMPUTES THE EIGENVECTORS OF THE TRIANGULAR PROBLEM AND
!    TRANSFORMS THE RESULTS BACK TO THE ORIGINAL COORDINATE SYSTEM.
!    IT IS USUALLY PRECEDED BY QZHES, QZIT, AND QZVAL.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS A REAL UPPER QUASI-TRIANGULAR MATRIX.
!    ITS SUBDIAGONAL ELEMENTS PROVIDE INFORMATION ABOUT THE STORAGE OF
!    THE COMPLEX EIGENVECTORS.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, A REAL UPPER TRIANGULAR
!    MATRIX.  IN ADDITION, LOCATION B(N,1) CONTAINS THE TOLERANCE QUANTITY EPSB
!    COMPUTED AND SAVED IN QZIT.  ON OUTPUT, B HAS BEEN DESTROYED.
!
!    INPUT, REAL ( KIND = 8 ) ALFR(N), ALFI(N), BETA(N), VECTORS WHOSE RATIOS
!      ( ALFR + I * ALFI ) / BETA
!    ARE THE GENERALIZED EIGENVALUES.  THEY ARE USUALLY OBTAINED FROM QZVAL.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,N).  ON INPUT, THE TRANSFORMATION
!    MATRIX PRODUCED IN THE REDUCTIONS BY QZHES, QZIT, AND QZVAL, IF PERFORMED.
!    IF THE EIGENVECTORS OF THE TRIANGULAR PROBLEM ARE DESIRED, Z MUST CONTAIN
!    THE IDENTITY MATRIX.  ON OUTPUT, Z CONTAINS THE REAL AND IMAGINARY PARTS OF
!    THE EIGENVECTORS:
!    IF ALFI(I) == 0.0, THE I-TH EIGENVALUE IS REAL AND THE I-TH COLUMN OF Z
!    CONTAINS ITS EIGENVECTOR.
!    IF ALFI(I) > 0.0, THE EIGENVALUE IS THE FIRST OF A COMPLEX PAIR AND THE
!    I-TH AND (I+1)-TH COLUMNS OF Z CONTAIN ITS EIGENVECTOR.
!    IF ALFI(I) < 0.0, THE EIGENVALUE IS THE SECOND OF A COMPLEX PAIR AND THE
!    (I-1)-TH AND I-TH COLUMNS OF Z CONTAIN THE CONJUGATE OF ITS EIGENVECTOR.
!    EACH EIGENVECTOR IS NORMALIZED SO THAT THE MODULUS OF ITS LARGEST
!    COMPONENT IS 1.0D+00 .
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) ALFI(N)
  REAL    ( KIND = 8 ) ALFM
  REAL    ( KIND = 8 ) ALFR(N)
  REAL    ( KIND = 8 ) ALMI
  REAL    ( KIND = 8 ) ALMR
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) BETA(N)
  REAL    ( KIND = 8 ) BETM
  REAL    ( KIND = 8 ) D
  REAL    ( KIND = 8 ) DI
  REAL    ( KIND = 8 ) DR
  INTEGER ( KIND = 4 ) EN
  INTEGER ( KIND = 4 ) ENM2
  REAL    ( KIND = 8 ) EPSB
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) ISW
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) NA
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) Q
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) RA
  REAL    ( KIND = 8 ) RR
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SA
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) T1
  REAL    ( KIND = 8 ) T2
  REAL    ( KIND = 8 ) TI
  REAL    ( KIND = 8 ) TR
  REAL    ( KIND = 8 ) W
  REAL    ( KIND = 8 ) W1
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) X1
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z(N,N)
  REAL    ( KIND = 8 ) Z1
  REAL    ( KIND = 8 ) ZZ

  EPSB = B(N,1)
  ISW = 1

  DO NN = 1, N

     EN = N + 1 - NN
     NA = EN - 1

     IF ( ISW == 2 ) GO TO 795

     IF ( ALFI(EN) /= 0.0D+00 ) GO TO 710
!
!  REAL VECTOR.
!
     M = EN
     B(EN,EN) = 1.0D+00

     IF ( NA == 0 ) GO TO 800

     ALFM = ALFR(M)
     BETM = BETA(M)

     DO II = 1, NA

        I = EN - II
        W = BETM * A(I,I) - ALFM * B(I,I)
        R = 0.0D+00

        DO J = M, EN
          R = R + ( BETM * A(I,J) - ALFM * B(I,J) ) * B(J,EN)
        END DO

        IF ( I == 1 .OR. ISW == 2 ) GO TO 630

        IF ( BETM * A(I,I-1) == 0.0D+00 ) GO TO 630

        ZZ = W
        S = R
        GO TO 690

630     CONTINUE

        M = I

        IF ( ISW == 2 ) GO TO 640
!
!  REAL 1-BY-1 BLOCK.
!
        T = W
        IF ( W == 0.0D+00 ) T = EPSB
        B(I,EN) = - R / T
        GO TO 700
!
!  REAL 2-BY-2 BLOCK.
!
640     CONTINUE

        X = BETM * A(I,I+1) - ALFM * B(I,I+1)
        Y = BETM * A(I+1,I)
        Q = W * ZZ - X * Y
        T = ( X * S - ZZ * R ) / Q
        B(I,EN) = T

        IF ( ABS ( X ) <= ABS ( ZZ ) ) GO TO 650

        B(I+1,EN) = (-R - W * T) / X

        GO TO 690

650     CONTINUE

        B(I+1,EN) = (-S - Y * T) / ZZ

690     CONTINUE

        ISW = 3 - ISW

700     CONTINUE

     END DO
!
!  END REAL VECTOR.
!
     GO TO 800
!
!  COMPLEX VECTOR.
!
710  CONTINUE

     M = NA
     ALMR = ALFR(M)
     ALMI = ALFI(M)
     BETM = BETA(M)
!
!  LAST VECTOR COMPONENT CHOSEN IMAGINARY SO EIGENVECTOR MATRIX IS TRIANGULAR.
!
     Y = BETM * A(EN,NA)
     B(NA,NA) = -ALMI * B(EN,EN) / Y
     B(NA,EN) = ( ALMR * B(EN,EN) - BETM * A(EN,EN) ) / Y
     B(EN,NA) = 0.0D+00
     B(EN,EN) = 1.0D+00
     ENM2 = NA - 1

     DO II = 1, ENM2

        I = NA - II
        W = BETM * A(I,I) - ALMR * B(I,I)
        W1 = -ALMI * B(I,I)
        RA = 0.0D+00
        SA = 0.0D+00

        DO J = M, EN
          X = BETM * A(I,J) - ALMR * B(I,J)
          X1 = -ALMI * B(I,J)
          RA = RA + X * B(J,NA) - X1 * B(J,EN)
          SA = SA + X * B(J,EN) + X1 * B(J,NA)
        END DO

        IF ( I == 1 .OR. ISW == 2 ) GO TO 770
        IF ( BETM * A(I,I-1) == 0.0D+00 ) GO TO 770

        ZZ = W
        Z1 = W1
        R = RA
        S = SA
        ISW = 2
        GO TO 790
770     CONTINUE

        M = I
        IF ( ISW == 2 ) GO TO 780
!
!  COMPLEX 1-BY-1 BLOCK.
!
        TR = -RA
        TI = -SA

773     CONTINUE

        DR = W
        DI = W1
!
!  COMPLEX DIVIDE (T1,T2) = (TR,TI) / (DR,DI),
!
775     CONTINUE

        IF ( ABS ( DI ) > ABS ( DR ) ) GO TO 777
        RR = DI / DR
        D = DR + DI * RR
        T1 = (TR + TI * RR) / D
        T2 = (TI - TR * RR) / D
        GO TO ( 787, 782 ), ISW

777     CONTINUE

        RR = DR / DI
        D = DR * RR + DI
        T1 = ( TR * RR + TI ) / D
        T2 = ( TI * RR - TR ) / D
        GO TO ( 787, 782 ), ISW
!
!  COMPLEX 2-BY-2 BLOCK.
!
780     CONTINUE

        X = BETM * A(I,I+1) - ALMR * B(I,I+1)
        X1 = -ALMI * B(I,I+1)
        Y = BETM * A(I+1,I)
        TR = Y * RA - W * R + W1 * S
        TI = Y * SA - W * S - W1 * R
        DR = W * ZZ - W1 * Z1 - X * Y
        DI = W * Z1 + W1 * ZZ - X1 * Y
        IF ( DR == 0.0D+00 .AND. DI == 0.0D+00 ) DR = EPSB
        GO TO 775

782     CONTINUE

        B(I+1,NA) = T1
        B(I+1,EN) = T2
        ISW = 1
        IF ( ABS ( Y ) > ABS ( W ) + ABS ( W1 ) ) GO TO 785
        TR = -RA - X * B(I+1,NA) + X1 * B(I+1,EN)
        TI = -SA - X * B(I+1,EN) - X1 * B(I+1,NA)
        GO TO 773

785     CONTINUE

        T1 = (-R - ZZ * B(I+1,NA) + Z1 * B(I+1,EN) ) / Y
        T2 = (-S - ZZ * B(I+1,EN) - Z1 * B(I+1,NA) ) / Y

787     CONTINUE

        B(I,NA) = T1
        B(I,EN) = T2

790     CONTINUE

     END DO
!
!  END COMPLEX VECTOR.
!
795   CONTINUE

      ISW = 3 - ISW

800   CONTINUE

  END DO
!
!  END BACK SUBSTITUTION.
!  TRANSFORM TO ORIGINAL COORDINATE SYSTEM.
!
  DO JJ = 1, N

     J = N + 1 - JJ

     DO I = 1, N

        ZZ = 0.0D+00

        DO K = 1, J
          ZZ = ZZ + Z(I,K) * B(K,J)
        END DO

        Z(I,J) = ZZ

      END DO

  END DO
!
!  NORMALIZE SO THAT MODULUS OF LARGEST COMPONENT OF EACH VECTOR IS 1.
!  (ISW IS 1 INITIALLY FROM BEFORE).
!
  DO J = 1, N

     D = 0.0D+00
     IF ( ISW == 2 ) GO TO 920
     IF ( ALFI(J) /= 0.0D+00 ) GO TO 945

     DO I = 1, N
       D = MAX ( D, ABS ( Z(I,J) ) )
     END DO

     Z(1:N,J) = Z(1:N,J) / D

     GO TO 950

920  CONTINUE

     DO I = 1, N
       R = ABS ( Z(I,J-1) ) + ABS ( Z(I,J) )
       IF ( R /= 0.0D+00 ) THEN
         R = R * SQRT ( ( Z(I,J-1) / R )**2 + ( Z(I,J) / R )**2 )
       END IF
       IF ( R > D ) D = R
     END DO

     Z(1:N,J-1) = Z(1:N,J-1) / D
     Z(1:N,J) = Z(1:N,J) / D

945  CONTINUE

     ISW = 3 - ISW

950  CONTINUE

  END DO

  RETURN
END
SUBROUTINE R8_SWAP ( X, Y )

!*****************************************************************************80
!
!! R8_SWAP SWAPS TWO R8'S.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    22 DECEMBER 2000
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) X, Y.  ON OUTPUT, THE VALUES OF X AND
!    Y HAVE BEEN INTERCHANGED.
!
  IMPLICIT NONE

  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z

  Z = X
  X = Y
  Y = Z

  RETURN
END
SUBROUTINE R8MAT_PRINT ( M, N, A, TITLE )

!*****************************************************************************80
!
!! R8MAT_PRINT PRINTS AN R8MAT.
!
!  DISCUSSION:
!
!    AN R8MAT IS AN ARRAY OF R8 VALUES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    12 SEPTEMBER 2004
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF ROWS IN A.
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE NUMBER OF COLUMNS IN A.
!
!    INPUT, REAL ( KIND = 8 ) A(M,N), THE MATRIX.
!
!    INPUT, CHARACTER ( LEN = * ) TITLE, A TITLE.
!
  IMPLICIT NONE

  INTEGER   ( KIND = 4 ) M
  INTEGER   ( KIND = 4 ) N

  REAL      ( KIND = 8 ) A(M,N)
  CHARACTER ( LEN = * )  TITLE

  CALL R8MAT_PRINT_SOME ( M, N, A, 1, 1, M, N, TITLE )

  RETURN
END
SUBROUTINE R8MAT_PRINT_SOME ( M, N, A, ILO, JLO, IHI, JHI, TITLE )

!*****************************************************************************80
!
!! R8MAT_PRINT_SOME PRINTS SOME OF AN R8MAT.
!
!  DISCUSSION:
!
!    AN R8MAT IS AN ARRAY OF R8 VALUES.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    26 MARCH 2005
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) M, N, THE NUMBER OF ROWS AND COLUMNS.
!
!    INPUT, REAL ( KIND = 8 ) A(M,N), AN M BY N MATRIX TO BE PRINTED.
!
!    INPUT, INTEGER ( KIND = 4 ) ILO, JLO, THE FIRST ROW AND COLUMN TO PRINT.
!
!    INPUT, INTEGER ( KIND = 4 ) IHI, JHI, THE LAST ROW AND COLUMN TO PRINT.
!
!    INPUT, CHARACTER ( LEN = * ) TITLE, A TITLE.
!
  IMPLICIT NONE

  INTEGER   ( KIND = 4 ), PARAMETER :: INCX = 5
  INTEGER   ( KIND = 4 ) M
  INTEGER   ( KIND = 4 ) N

  REAL      ( KIND = 8 ) A(M,N)
  CHARACTER ( LEN = 14 ) CTEMP(INCX)
  INTEGER   ( KIND = 4 ) I
  INTEGER   ( KIND = 4 ) I2HI
  INTEGER   ( KIND = 4 ) I2LO
  INTEGER   ( KIND = 4 ) IHI
  INTEGER   ( KIND = 4 ) ILO
  INTEGER   ( KIND = 4 ) INC
  INTEGER   ( KIND = 4 ) J
  INTEGER   ( KIND = 4 ) J2
  INTEGER   ( KIND = 4 ) J2HI
  INTEGER   ( KIND = 4 ) J2LO
  INTEGER   ( KIND = 4 ) JHI
  INTEGER   ( KIND = 4 ) JLO
  CHARACTER ( LEN = * )  TITLE

  WRITE ( *, '(A)' ) ' '
  WRITE ( *, '(A)' ) TRIM ( TITLE )

  DO J2LO = MAX ( JLO, 1 ), MIN ( JHI, N ), INCX

    J2HI = J2LO + INCX - 1
    J2HI = MIN ( J2HI, N )
    J2HI = MIN ( J2HI, JHI )

    INC = J2HI + 1 - J2LO

    WRITE ( *, '(A)' ) ' '

    DO J = J2LO, J2HI
      J2 = J + 1 - J2LO
      WRITE ( CTEMP(J2), '(I8,6X)' ) J
    END DO

    WRITE ( *, '(''  COL   '',5A14)' ) CTEMP(1:INC)
    WRITE ( *, '(A)' ) '  ROW'
    WRITE ( *, '(A)' ) ' '

    I2LO = MAX ( ILO, 1 )
    I2HI = MIN ( IHI, M )

    DO I = I2LO, I2HI

      DO J2 = 1, INC

        J = J2LO - 1 + J2

        IF ( A(I,J) == REAL ( INT ( A(I,J) ), KIND = 8 ) ) THEN
          WRITE ( CTEMP(J2), '(F8.0,6X)' ) A(I,J)
        ELSE
          WRITE ( CTEMP(J2), '(G14.6)' ) A(I,J)
        END IF

      END DO

      WRITE ( *, '(I5,1X,5A14)' ) I, ( CTEMP(J), J = 1, INC )

    END DO

  END DO

  RETURN
END
SUBROUTINE R8VEC_PRINT ( N, A, TITLE )

!*****************************************************************************80
!
!! R8VEC_PRINT PRINTS AN R8VEC.
!
!  DISCUSSION:
!
!    AN R8VEC IS A VECTOR OF R8 VALUES.
!
!  MODIFIED:
!
!    22 AUGUST 2000
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE NUMBER OF COMPONENTS OF THE VECTOR.
!
!    INPUT, REAL ( KIND = 8 ) A(N), THE VECTOR TO BE PRINTED.
!
!    INPUT, CHARACTER ( LEN = * ) TITLE, A TITLE.
!
  IMPLICIT NONE

  INTEGER   ( KIND = 4 ) N

  REAL      ( KIND = 8 ) A(N)
  INTEGER   ( KIND = 4 ) I
  CHARACTER ( LEN = * ) TITLE

  WRITE ( *, '(A)' ) ' '
  WRITE ( *, '(A)' ) TRIM ( TITLE )
  WRITE ( *, '(A)' ) ' '
  DO I = 1, N
    WRITE ( *, '(2X,I8,2X,G16.8)' ) I, A(I)
  END DO

  RETURN
END
SUBROUTINE R8VEC2_PRINT ( N, A1, A2, TITLE )

!*****************************************************************************80
!
!! R8VEC2_PRINT PRINTS AN R8VEC2.
!
!  DISCUSSION:
!
!    AN R8VEC2 IS A DATASET CONSISTING OF N PAIRS OF R8'S, STORED
!    AS TWO SEPARATE VECTORS A1 AND A2.
!
!  MODIFIED:
!
!    13 DECEMBER 2004
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE NUMBER OF COMPONENTS OF THE VECTOR.
!
!    INPUT, REAL ( KIND = 8 ) A1(N), A2(N), THE VECTORS TO BE PRINTED.
!
!    INPUT, CHARACTER ( LEN = * ) TITLE, A TITLE.
!
  IMPLICIT NONE

  INTEGER   ( KIND = 4 ) N

  REAL      ( KIND = 8 ) A1(N)
  REAL      ( KIND = 8 ) A2(N)
  INTEGER   ( KIND = 4 ) I
  CHARACTER ( LEN = * )  TITLE

  WRITE ( *, '(A)' ) ' '
  WRITE ( *, '(A)' ) TRIM ( TITLE )
  WRITE ( *, '(A)' ) ' '

  IF ( ALL ( A1(1:N) == AINT ( A1(1:N) ) ) .AND. &
       ALL ( A2(1:N) == AINT ( A2(1:N) ) ) ) THEN
    DO I = 1, N
      WRITE ( *, '(I8,2I8)' ) I, INT ( A1(I) ), INT ( A2(I) )
    END DO
  ELSE IF ( ALL ( ABS ( A1(1:N) ) < 1000000.0D+00 ) .AND. &
            ALL ( ABS ( A2(1:N) ) < 1000000.0D+00 ) ) THEN
    DO I = 1, N
      WRITE ( *, '(I8,2F14.6)' ) I, A1(I), A2(I)
    END DO
  ELSE
    DO I = 1, N
      WRITE ( *, '(I8,2G14.6)' ) I, A1(I), A2(I)
    END DO
  END IF

  RETURN
END
SUBROUTINE RATQR ( N, EPS1, D, E, E2, M, W, IND, BD, TYPE, IDEF, IERR )

!*****************************************************************************80
!
!! RATQR COMPUTES SELECTED EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE ALGEBRAICALLY SMALLEST OR LARGEST
!    EIGENVALUES OF A SYMMETRIC TRIDIAGONAL MATRIX BY THE
!    RATIONAL QR METHOD WITH NEWTON CORRECTIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) EPS1.  ON INPUT, A THEORETICAL ABSOLUTE
!    ERROR TOLERANCE FOR THE COMPUTED EIGENVALUES.  IF THE INPUT EPS1 IS
!    NON-POSITIVE, OR INDEED SMALLER THAN ITS DEFAULT VALUE, IT IS RESET AT
!    EACH ITERATION TO THE RESPECTIVE DEFAULT VALUE, NAMELY, THE PRODUCT OF
!    THE RELATIVE MACHINE PRECISION AND THE MAGNITUDE OF THE CURRENT EIGENVALUE
!    ITERATE.  THE THEORETICAL ABSOLUTE ERROR IN THE K-TH EIGENVALUE IS USUALLY
!    NOT GREATER THAN K TIMES EPS1.  ON OUTPUT, EPS1 IS UNALTERED UNLESS IT HAS
!    BEEN RESET TO ITS (LAST) DEFAULT VALUE.
!
!    INPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
!    IN E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N).  ON INPUT, E2(2:N-1) CONTAINS THE
!    SQUARES OF THE CORRESPONDING ELEMENTS OF E, AND E2(1) IS ARBITRARY.  ON
!    OUTPUT, ELEMENTS OF E2 CORRESPONDING TO ELEMENTS OF E REGARDED AS
!    NEGLIGIBLE HAVE BEEN REPLACED BY ZERO, CAUSING THE MATRIX TO SPLIT INTO
!    A DIRECT SUM OF SUBMATRICES.  E2(1) IS SET TO 0.0D+00 IF THE SMALLEST
!    EIGENVALUES HAVE BEEN FOUND, AND TO 2.0D+00 IF THE LARGEST EIGENVALUES
!    HAVE BEEN FOUND.  E2 IS OTHERWISE UNALTERED (UNLESS OVERWRITTEN BY BD).
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVALUES TO BE FOUND.
!
!    OUTPUT, REAL ( KIND = 8 ) W(M), THE M ALGEBRAICALLY SMALLEST EIGENVALUES IN
!    ASCENDING ORDER, OR THE M LARGEST EIGENVALUES IN DESCENDING ORDER.
!    IF AN ERROR EXIT IS MADE BECAUSE OF AN INCORRECT SPECIFICATION OF IDEF,
!    NO EIGENVALUES ARE FOUND.  IF THE NEWTON ITERATES FOR A PARTICULAR
!    EIGENVALUE ARE NOT MONOTONE, THE BEST ESTIMATE OBTAINED IS RETURNED
!    AND IERR IS SET.  W MAY COINCIDE WITH D.
!
!    OUTPT, INTEGER IND(N), CONTAINS IN ITS FIRST M POSITIONS THE SUBMATRIX
!    INDICES ASSOCIATED WITH THE CORRESPONDING EIGENVALUES IN W:
!    1 FOR EIGENVALUES BELONGING TO THE FIRST SUBMATRIX FROM THE TOP, 2 FOR
!    THOSE BELONGING TO THE SECOND SUBMATRIX, AND SO ON.
!
!    OUTPUT, REAL ( KIND = 8 ) BD(N), CONTAINS REFINED BOUNDS FOR THE
!    THEORETICAL ERRORS OF THE CORRESPONDING EIGENVALUES IN W.  THESE BOUNDS
!    ARE USUALLY WITHIN THE TOLERANCE SPECIFIED BY EPS1.  BD MAY COINCIDE
!    WITH E2.
!
!    INPUT, INTEGER ( KIND = 4 ) IDEF, SHOULD BE SET TO 1 IF THE INPUT MATRIX
!    IS KNOWN TO BE POSITIVE DEFINITE, TO -1 IF THE INPUT MATRIX IS KNOWN TO
!    BE NEGATIVE  DEFINITE, AND TO 0 OTHERWISE.
!
!    INPUT, LOGICAL TYPE, SHOULD BE SET TO TRUE IF THE SMALLEST EIGENVALUES
!    ARE TO BE FOUND, AND TO FALSE IF THE LARGEST EIGENVALUES ARE TO BE FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    6*N+1, IF IDEF IS SET TO 1 AND TYPE TO .TRUE. WHEN THE MATRIX IS NOT
!      POSITIVE DEFINITE, OR IF IDEF IS SET TO -1 AND TYPE TO .FALSE.
!      WHEN THE MATRIX IS NOT NEGATIVE DEFINITE,
!    5*N+K, IF SUCCESSIVE ITERATES TO THE K-TH EIGENVALUE ARE NOT MONOTONE
!      INCREASING, WHERE K REFERS TO THE LAST SUCH OCCURRENCE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) BD(N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) DELTA
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) EP
  REAL    ( KIND = 8 ) EPS1
  REAL    ( KIND = 8 ) ERR
  REAL    ( KIND = 8 ) F
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IDEF
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IND(N)
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JDEF
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) K1
  INTEGER ( KIND = 4 ) M
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) Q
  REAL    ( KIND = 8 ) QP
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) TOT
  LOGICAL              TYPE
  REAL    ( KIND = 8 ) W(N)

  IERR = 0
  JDEF = IDEF
  W(1:N) = D(1:N)

  IF ( .NOT. TYPE ) THEN
    J = 1
    GO TO 400
  END IF

40 CONTINUE

  ERR = 0.0D+00
  S = 0.0D+00
!
!  LOOK FOR SMALL SUB-DIAGONAL ENTRIES AND DEFINE INITIAL SHIFT
!  FROM LOWER GERSCHGORIN BOUND.
!
!  COPY E2 ARRAY INTO BD.
!
  TOT = W(1)
  Q = 0.0D+00
  J = 0

  DO I = 1, N

     P = Q

     IF ( I == 1 ) GO TO 60

     IF ( P > ( ABS ( D(I) ) + ABS (  D(I-1) ) ) * EPSILON ( P ) ) THEN
       GO TO 80
     END IF

60   CONTINUE

     E2(I) = 0.0D+00

80   CONTINUE

     BD(I) = E2(I)
!
!  COUNT ALSO IF ELEMENT OF E2 HAS UNDERFLOWED.
!
     IF ( E2(I) == 0.0D+00 ) J = J + 1
     IND(I) = J
     Q = 0.0D+00
     IF ( I /= N ) Q = ABS ( E(I+1) )
     TOT = MIN ( W(I)-P-Q, TOT )

  END DO

  IF ( JDEF == 1 .AND. TOT < 0.0D+00 ) THEN
    GO TO 140
  END IF

  W(1:N) = W(1:N) - TOT

  GO TO 160

140 CONTINUE

  TOT = 0.0D+00

160 CONTINUE

  DO K = 1, M
!
!  NEXT QR TRANSFORMATION.
!
180  CONTINUE

     TOT = TOT + S
     DELTA = W(N) - S
     I = N
     F = ABS ( TOT ) * EPSILON ( F )
     IF ( EPS1 < F ) EPS1 = F
     IF ( DELTA > EPS1 ) GO TO 190
     IF ( DELTA < (-EPS1) ) GO TO 1000
     GO TO 300
!
!  REPLACE SMALL SUB-DIAGONAL SQUARES BY ZERO TO REDUCE THE INCIDENCE OF
!  UNDERFLOWS.
!
190  CONTINUE

     DO J = K+1, N
       IF ( BD(J) <= ( ABS (  W(J) + W(J-1) ) * EPSILON ( BD(J) ) ) ** 2 ) THEN
         BD(J) = 0.0D+00
       END IF
     END DO

     F = BD(N) / DELTA
     QP = DELTA + F
     P = 1.0D+00

     DO II = 1, N-K

       I = N - II
       Q = W(I) - S - F
       R = Q / QP
       P = P * R + 1.0D+00
       EP = F * R
       W(I+1) = QP + EP
       DELTA = Q - EP

       IF ( DELTA > EPS1 ) GO TO 220
       IF ( DELTA < (-EPS1) ) GO TO 1000
       GO TO 300

220    CONTINUE

       F = BD(I) / Q
       QP = DELTA + F
       BD(I+1) = QP * EP

     END DO

     W(K) = QP
     S = QP / P

     IF ( TOT + S > TOT ) GO TO 180
!
!  SET ERROR: IRREGULAR END OF ITERATION.
!  DEFLATE MINIMUM DIAGONAL ELEMENT.
!
     IERR = 5 * N + K
     S = 0.0D+00
     DELTA = QP

     DO J = K, N
       IF ( W(J) <= DELTA ) THEN
         I = J
         DELTA = W(J)
       END IF
     END DO
!
!  CONVERGENCE.
!
300  CONTINUE

     IF ( I < N ) BD(I+1) = BD(I) * F / QP
     II = IND(I)

     DO JJ = 1, I-K
       J = I - JJ
       W(J+1) = W(J) - S
       BD(J+1) = BD(J)
       IND(J+1) = IND(J)
     END DO

     W(K) = TOT
     ERR = ERR + ABS ( DELTA)
     BD(K) = ERR
     IND(K) = II

  END DO

  IF ( TYPE ) THEN
    RETURN
  END IF

  F = BD(1)
  E2(1) = 2.0D+00
  BD(1) = F
  J = 2
!
!  NEGATE ELEMENTS OF W FOR LARGEST VALUES.
!
400 CONTINUE

  W(1:N) = - W(1:N)
  JDEF = -JDEF

  IF ( J == 1 ) THEN
    GO TO 40
  END IF

  RETURN
!
!  SET ERROR: IDEF SPECIFIED INCORRECTLY.
!
 1000 CONTINUE

  IERR = 6 * N + 1
  RETURN
END
SUBROUTINE REBAK ( N, B, DL, M, Z )

!*****************************************************************************80
!
!! REBAK DETERMINES EIGENVECTORS BY UNDOING THE REDUC TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A GENERALIZED
!    SYMMETRIC EIGENSYSTEM BY BACK TRANSFORMING THOSE OF THE
!    DERIVED SYMMETRIC MATRIX DETERMINED BY REDUC.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), CONTAINS INFORMATION ABOUT THE SIMILARITY
!    TRANSFORMATION (CHOLESKY DECOMPOSITION) USED IN THE REDUCTION BY REDUC
!    IN ITS STRICT LOWER TRIANGLE.
!
!    INPUT, REAL ( KIND = 8 ) DL(N), FURTHER INFORMATION ABOUT THE TRANSFORMATION.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE EIGENVECTORS TO BE BACK
!    TRANSFORMED IN ITS FIRST M COLUMNS.  ON OUTPUT, THE TRANSFORMED
!    EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) DL(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  REAL    ( KIND = 8 ) Z(N,M)

  DO J = 1, M
    DO I = N, 1, -1
      Z(I,J) = ( Z(I,J) - DOT_PRODUCT ( B(I+1:N,I), Z(I+1:N,J) ) ) / DL(I)
    END DO
  END DO

  RETURN
END
SUBROUTINE REBAKB ( N, B, DL, M, Z )

!*****************************************************************************80
!
!! REBAKB DETERMINES EIGENVECTORS BY UNDOING THE REDUC2 TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A GENERALIZED
!    SYMMETRIC EIGENSYSTEM BY BACK TRANSFORMING THOSE OF THE
!    DERIVED SYMMETRIC MATRIX DETERMINED BY REDUC2.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), CONTAINS INFORMATION ABOUT THE SIMILARITY
!    TRANSFORMATION (CHOLESKY DECOMPOSITION) USED IN THE REDUCTION BY REDUC2
!    IN ITS STRICT LOWER TRIANGLE.
!
!    INPUT, REAL ( KIND = 8 ) DL(N), FURTHER INFORMATION ABOUT THE TRANSFORMATION.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE EIGENVECTORS TO BE BACK
!    TRANSFORMED IN ITS FIRST M COLUMNS.  ON OUTPUT, THE TRANSFORMED
!    EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) DL(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  REAL    ( KIND = 8 ) Z(N,M)

  DO J = 1, M

    DO I = N, 1, -1

      Z(I,J) = DL(I) * Z(I,J) + DOT_PRODUCT ( B(I,1:I-1), Z(1:I-1,J) )

    END DO

  END DO

  RETURN
END
SUBROUTINE REDUC ( N, A, B, DL, IERR )

!*****************************************************************************80
!
!! REDUC REDUCES THE EIGENVALUE PROBLEM A*X=LAMBDA*B*X TO A*X=LAMBDA*X.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES THE GENERALIZED SYMMETRIC EIGENPROBLEM
!    AX=(LAMBDA)BX, WHERE B IS POSITIVE DEFINITE, TO THE STANDARD
!    SYMMETRIC EIGENPROBLEM USING THE CHOLESKY FACTORIZATION OF B.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.  IF THE
!    CHOLESKY FACTOR L OF B IS ALREADY AVAILABLE, N SHOULD BE PREFIXED WITH A
!    MINUS SIGN.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, A CONTAINS A REAL
!    SYMMETRIC MATRIX.  ONLY THE FULL UPPER TRIANGLE OF THE MATRIX NEED BE
!    SUPPLIED.  ON OUTPUT, A CONTAINS IN ITS FULL LOWER TRIANGLE THE FULL LOWER
!    TRIANGLE OF THE SYMMETRIC MATRIX DERIVED FROM THE REDUCTION TO THE
!    STANDARD FORM.  THE STRICT UPPER TRIANGLE OF A IS UNALTERED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, THE REAL SYMMETRIC
!    INPUT MATRIX.  ONLY THE FULL UPPER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!    IF N IS NEGATIVE, THE STRICT LOWER TRIANGLE OF B CONTAINS, INSTEAD, THE
!    STRICT LOWER TRIANGLE OF ITS CHOLESKY FACTOR L.  IN ANY CASE, ON OUTPUT,
!    B CONTAINS IN ITS STRICT LOWER TRIANGLE THE STRICT LOWER TRIANGLE OF
!    ITS CHOLESKY FACTOR L.  THE FULL UPPER TRIANGLE OF B IS UNALTERED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) DL(N).  IF N IS NEGATIVE, THEN THE DL
!    CONTAINS THE DIAGONAL ELEMENTS OF L ON INPUT.  IN ANY CASE, DL WILL CONTAIN
!    THE DIAGONAL ELEMENTS OF L ON OUTPUT,
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    7*N+1, IF B IS NOT POSITIVE DEFINITE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) DL(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y

  IERR = 0
  NN = ABS ( N )
!
!  FORM L IN THE ARRAYS B AND DL.
!
  DO I = 1, N

     DO J = I, N

        X = B(I,J)

        DO K = 1, I - 1
          X = X - B(I,K) * B(J,K)
        END DO

        IF ( J == I ) THEN

          IF ( X <= 0.0D+00 ) THEN
            WRITE ( *, '(A)' ) ' '
            WRITE ( *, '(A)' ) 'REDUC - FATAL ERROR!'
            WRITE ( *, '(A)' ) '  THE MATRIX IS NOT POSITIVE DEFINITE.'
            IERR = 7 * N + 1
            RETURN
          END IF

          Y = SQRT ( X )
          DL(I) = Y
        ELSE
          B(J,I) = X / Y
        END IF

    END DO

  END DO
!
!  FORM THE TRANSPOSE OF THE UPPER TRIANGLE OF INV(L)*A
!  IN THE LOWER TRIANGLE OF THE ARRAY A.
!
  DO I = 1, NN

     Y = DL(I)

     DO J = I, NN

        X = A(I,J)

        DO K = 1, I - 1
          X = X - B(I,K) * A(J,K)
        END DO

        A(J,I) = X / Y

      END DO

  END DO
!
!  PRE-MULTIPLY BY INV(L) AND OVERWRITE.
!
  DO J = 1, NN

     DO I = J, NN

        X = A(I,J)

        DO K = J, I-1
          X = X - A(K,J) * B(I,K)
        END DO

        DO K = 1, J-1
          X = X - A(J,K) * B(I,K)
        END DO

        A(I,J) = X / DL(I)

    END DO

  END DO

  RETURN
END
SUBROUTINE REDUC2 ( N, A, B, DL, IERR )

!*****************************************************************************80
!
!! REDUC2 REDUCES THE EIGENVALUE PROBLEM A*B*X=LAMDBA*X TO A*X=LAMBDA*X.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES THE GENERALIZED SYMMETRIC EIGENPROBLEMS
!    ABX=(LAMBDA)X OR BAY=(LAMBDA)Y, WHERE B IS POSITIVE DEFINITE,
!    TO THE STANDARD SYMMETRIC EIGENPROBLEM USING THE CHOLESKY
!    FACTORIZATION OF B.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.  IF THE
!    CHOLESKY FACTOR L OF B IS ALREADY AVAILABLE, N SHOULD BE PREFIXED WITH A
!    MINUS SIGN.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, A CONTAINS A REAL
!    SYMMETRIC MATRIX.  ONLY THE FULL UPPER TRIANGLE OF THE MATRIX NEED BE
!    SUPPLIED.  ON OUTPUT, A CONTAINS IN ITS FULL LOWER TRIANGLE THE FULL LOWER
!    TRIANGLE OF THE SYMMETRIC MATRIX DERIVED FROM THE REDUCTION TO THE
!    STANDARD FORM.  THE STRICT UPPER TRIANGLE OF A IS UNALTERED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, THE REAL SYMMETRIC
!    INPUT MATRIX.  ONLY THE FULL UPPER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!    IF N IS NEGATIVE, THE STRICT LOWER TRIANGLE OF B CONTAINS, INSTEAD, THE
!    STRICT LOWER TRIANGLE OF ITS CHOLESKY FACTOR L.  IN ANY CASE, ON OUTPUT,
!    B CONTAINS IN ITS STRICT LOWER TRIANGLE THE STRICT LOWER TRIANGLE OF
!    ITS CHOLESKY FACTOR L.  THE FULL UPPER TRIANGLE OF B IS UNALTERED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) DL(N).  IF N IS NEGATIVE, THEN THE DL
!    CONTAINS THE DIAGONAL ELEMENTS OF L ON INPUT.  IN ANY CASE, DL WILL CONTAIN
!    THE DIAGONAL ELEMENTS OF L ON OUTPUT,
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    7*N+1, IF B IS NOT POSITIVE DEFINITE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) DL(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y

  IERR = 0
  NN = ABS ( N )
!
!  FORM L IN THE ARRAYS B AND DL.
!
  DO I = 1, N

     DO J = I, N

        X = B(I,J)

        DO K = 1, I - 1
          X = X - B(I,K) * B(J,K)
        END DO

        IF ( J == I ) THEN

          IF ( X <= 0.0D+00 ) THEN
            WRITE ( *, '(A)' ) ' '
            WRITE ( *, '(A)' ) 'REDUC2 - FATAL ERROR!'
            WRITE ( *, '(A)' ) '  THE MATRIX IS NOT POSITIVE DEFINITE.'
            IERR = 7 * N + 1
            RETURN
          END IF

          Y = SQRT ( X )
          DL(I) = Y

        ELSE

          B(J,I) = X / Y

        END IF

    END DO

  END DO
!
!  FORM THE LOWER TRIANGLE OF A*L IN THE LOWER TRIANGLE OF A.
!
  DO I = 1, NN

     DO J = 1, I

        X = A(J,I) * DL(J)

        DO K = J+1, I
          X = X + A(K,I) * B(K,J)
        END DO

        DO K = I+1, NN
          X = X + A(I,K) * B(K,J)
        END DO

        A(I,J) = X

     END DO

  END DO
!
!  PRE-MULTIPLY BY L' AND OVERWRITE.
!
  DO I = 1, NN

    Y = DL(I)

    DO J = 1, I

      X = Y * A(I,J)

      DO K = I+1, NN
        X = X + A(K,J) * B(K,I)
      END DO

      A(I,J) = X

    END DO

  END DO

  RETURN
END
SUBROUTINE RG ( N, A, WR, WI, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RG COMPUTES EIGENVALUES AND EIGENVECTORS OF A REAL GENERAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A REAL GENERAL MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N), THE REAL GENERAL MATRIX.  ON OUTPUT,
!    A HAS BEEN OVERWRITTEN.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) WR(N), WI(N), THE REAL AND IMAGINARY PARTS,
!    RESPECTIVELY, OF THE EIGENVALUES.  COMPLEX CONJUGATE PAIRS OF EIGENVALUES
!    APPEAR CONSECUTIVELY WITH THE EIGENVALUE HAVING THE POSITIVE IMAGINARY
!    PART FIRST.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVECTORS IF MATZ IS NOT ZERO.  IF THE J-TH EIGENVALUE IS REAL, THE
!    J-TH COLUMN OF Z CONTAINS ITS EIGENVECTOR.  IF THE J-TH EIGENVALUE IS
!    COMPLEX WITH POSITIVE IMAGINARY PART, THE J-TH AND (J+1)-TH COLUMNS OF
!    Z CONTAIN THE REAL AND IMAGINARY PARTS OF ITS EIGENVECTOR.  THE
!    CONJUGATE OF THIS VECTOR IS THE EIGENVECTOR FOR THE CONJUGATE EIGENVALUE.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, AN ERROR COMPLETION CODE DESCRIBED IN THE
!    DOCUMENTATION FOR HQR AND HQR2.  THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IS1
  INTEGER ( KIND = 4 ) IS2
  INTEGER ( KIND = 4 ) IV1(N)
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) WI(N)
  REAL    ( KIND = 8 ) WR(N)
  REAL    ( KIND = 8 ) Z(N,N)

  CALL BALANC ( N, A, IS1, IS2, FV1 )

  CALL ELMHES ( N, IS1, IS2, A, IV1 )

  IF ( MATZ == 0 ) THEN

    CALL HQR ( N, IS1, IS2, A, WR, WI, IERR )

    IF ( IERR /= 0 ) THEN
      RETURN
    END IF

  ELSE

    CALL ELTRAN ( N, IS1, IS2, A, IV1, Z )

    CALL HQR2 ( N, IS1, IS2, A, WR, WI, Z, IERR )

    IF ( IERR /= 0 ) THEN
      RETURN
    END IF

    CALL BALBAK ( N, IS1, IS2, FV1, N, Z )

  END IF

  RETURN
END
SUBROUTINE RGG ( N, A, B, ALFR, ALFI, BETA, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RGG COMPUTES EIGENVALUES/VECTORS FOR THE GENERALIZED PROBLEM A*X = LAMBDA*B*X.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    FOR THE REAL GENERAL GENERALIZED EIGENPROBLEM
!
!      A * X = LAMBDA * B * X.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N), B(N,N), THE TWO REAL GENERAL MATRICES.
!    ON OUTPUT, A AND B HAVE BEEN OVERWRITTEN.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) ALFR(N), ALFI(N), THE REAL AND IMAGINARY PARTS,
!    RESPECTIVELY, OF THE NUMERATORS OF THE EIGENVALUES.
!
!    OUTPUT, REAL ( KIND = 8 ) BETA(N), THE DENOMINATORS OF THE EIGENVALUES,
!    WHICH ARE THUS GIVEN BY THE RATIOS (ALFR + I * ALFI ) / BETA.
!    COMPLEX CONJUGATE PAIRS OF EIGENVALUES APPEAR CONSECUTIVELY
!    WITH THE EIGENVALUE HAVING THE POSITIVE IMAGINARY PART FIRST.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE REAL AND IMAGINARY PARTS OF THE
!    EIGENVECTORS IF MATZ IS NOT ZERO.  IF THE J-TH EIGENVALUE IS REAL, THE
!    J-TH COLUMN OF Z CONTAINS ITS EIGENVECTOR.  IF THE J-TH EIGENVALUE IS
!    COMPLEX WITH POSITIVE IMAGINARY PART, THE J-TH AND (J+1)-TH COLUMNS OF
!    Z CONTAIN THE REAL AND IMAGINARY PARTS OF ITS EIGENVECTOR.  THE
!    CONJUGATE OF THIS VECTOR IS THE EIGENVECTOR FOR THE CONJUGATE EIGENVALUE.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET EQUAL TO AN ERROR COMPLETION CODE
!    DESCRIBED IN THE DOCUMENTATION FOR QZIT.  THE NORMAL COMPLETION
!    CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) ALFI(N)
  REAL    ( KIND = 8 ) ALFR(N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) BETA(N)
  REAL    ( KIND = 8 ) EPS1
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  LOGICAL              TF
  REAL    ( KIND = 8 ) Z(N,N)

  EPS1 = 0.0D+00

  IF ( MATZ == 0 ) THEN
    TF = .FALSE.
  ELSE
    TF = .TRUE.
  END IF

  CALL QZHES ( N, A, B, TF, Z )

  CALL QZIT ( N, A, B, EPS1, TF, Z, IERR )

  IF ( IERR /= 0 ) THEN
    RETURN
  END IF

  CALL QZVAL ( N, A, B, ALFR, ALFI, BETA, TF, Z )

  IF ( MATZ /= 0 ) THEN
    CALL QZVEC ( N, A, B, ALFR, ALFI, BETA, Z )
  END IF

  RETURN
END
SUBROUTINE RS ( N, A, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RS COMPUTES EIGENVALUES AND EIGENVECTORS OF REAL SYMMETRIC MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A REAL SYMMETRIC MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), THE REAL SYMMETRIC MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET EQUAL TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  IF ( MATZ == 0 ) THEN

    CALL TRED1 ( N, A, W, FV1, FV2 )

    CALL TQLRAT ( N, W, FV2, IERR )

  ELSE

    CALL TRED2 ( N, A, W, FV1, Z )

    CALL TQL2 ( N, W, FV1, Z, IERR )

  END IF

  RETURN
END
SUBROUTINE RSB ( N, MB, A, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RSB COMPUTES EIGENVALUES AND EIGENVECTORS OF A REAL SYMMETRIC BAND MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A REAL SYMMETRIC BAND MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MB, THE HALF BAND WIDTH OF THE MATRIX,
!    DEFINED AS THE NUMBER OF ADJACENT DIAGONALS, INCLUDING THE PRINCIPAL
!    DIAGONAL, REQUIRED TO SPECIFY THE NON-ZERO PORTION OF THE LOWER TRIANGLE
!    OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,MB), CONTAINS THE LOWER TRIANGLE OF THE REAL
!    SYMMETRIC BAND MATRIX.  ITS LOWEST SUBDIAGONAL IS STORED IN THE LAST N+1-MB
!    POSITIONS OF THE FIRST COLUMN, ITS NEXT SUBDIAGONAL IN THE LAST
!    N+2-MB POSITIONS OF THE SECOND COLUMN, FURTHER SUBDIAGONALS SIMILARLY,
!    AND FINALLY ITS PRINCIPAL DIAGONAL IN THE N POSITIONS OF THE LAST
!    COLUMN.  CONTENTS OF STORAGES NOT PART OF THE MATRIX ARE ARBITRARY.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED,
!    AND NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MB
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,MB)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  LOGICAL              TF
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  IF ( MB <= 0 ) THEN
    IERR = 12 * N
    RETURN
  END IF

  IF ( N < MB ) THEN
    IERR = 12 * N
    RETURN
  END IF

  IF ( MATZ == 0 ) THEN

    TF = .FALSE.

    CALL BANDR ( N, MB, A, W, FV1, FV2, TF, Z )

    CALL TQLRAT ( N, W, FV2, IERR )

  ELSE

    TF = .TRUE.

    CALL BANDR ( N, MB, A, W, FV1, FV1, TF, Z )

    CALL TQL2 ( N, W, FV1, Z, IERR )

  END IF

  RETURN
END
SUBROUTINE RSG ( N, A, B, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RSG COMPUTES EIGENVALUES/VECTORS, A*X=LAMBDA*B*X, A SYMMETRIC, B POS-DEF.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    FOR THE REAL SYMMETRIC GENERALIZED EIGENPROBLEM  AX = (LAMBDA)BX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  MODIFIED:
!
!    04 FEBRUARY 2003
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS A REAL SYMMETRIC MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), CONTAINS A POSITIVE DEFINITE REAL
!    SYMMETRIC MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  CALL REDUC ( N, A, B, FV2, IERR )

  IF ( IERR /= 0 ) THEN
    WRITE ( *, '(A)' ) ' '
    WRITE ( *, '(A)' ) 'RSG - FATAL ERROR!'
    WRITE ( *, '(A)' ) '  ERROR RETURN FROM REDUC.'
    RETURN
  END IF

  IF ( MATZ == 0 ) THEN

    CALL TRED1 ( N, A, W, FV1, FV2 )

    CALL TQLRAT ( N, W, FV2, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSG - WARNING!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TQLRAT!'
      RETURN
    END IF

  ELSE

    CALL TRED2 ( N, A, W, FV1, Z )

    CALL TQL2 ( N, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSG - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TQL2!'
      RETURN
    END IF

    CALL REBAK ( N, B, FV2, N, Z )

  END IF

  RETURN
END
SUBROUTINE RSGAB ( N, A, B, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RSGAB COMPUTES EIGENVALUES/VECTORS, A*B*X=LAMBDA*X, A SYMMETRIC, B POS-DEF.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    FOR THE REAL SYMMETRIC GENERALIZED EIGENPROBLEM  ABX = (LAMBDA)X.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS A REAL SYMMETRIC MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), CONTAINS A POSITIVE DEFINITE REAL
!    SYMMETRIC MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  CALL REDUC2 ( N, A, B, FV2, IERR )

  IF ( IERR /= 0 ) THEN
    RETURN
  END IF

  IF ( MATZ == 0 ) THEN

    CALL TRED1 ( N, A, W, FV1, FV2 )

    CALL TQLRAT ( N, W, FV2, IERR )

  ELSE

    CALL TRED2 ( N, A, W, FV1, Z )

    CALL TQL2 ( N, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      RETURN
    END IF

    CALL REBAK ( N, B, FV2, N, Z )

  END IF

  RETURN
END
SUBROUTINE RSGBA ( N, A, B, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RSGBA COMPUTES EIGENVALUES/VECTORS, B*A*X=LAMBDA*X, A SYMMETRIC, B POS-DEF.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    FOR THE REAL SYMMETRIC GENERALIZED EIGENPROBLEM:
!
!      B * A * X = LAMBDA * X
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), A REAL SYMMETRIC MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), A POSITIVE DEFINITE SYMMETRIC MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  CALL REDUC2 ( N, A, B, FV2, IERR )

  IF ( IERR /= 0 ) THEN
    RETURN
  END IF

  IF ( MATZ == 0 ) THEN

    CALL TRED1 ( N, A, W, FV1, FV2 )

    CALL TQLRAT ( N, W, FV2, IERR )

  ELSE

    CALL TRED2 ( N, A, W, FV1, Z )

    CALL TQL2 ( N, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      RETURN
    END IF

    CALL REBAKB ( N, B, FV2, N, Z )

  END IF

  RETURN
END
SUBROUTINE RSM ( N, A, W, M, Z, IERR )

!*****************************************************************************80
!
!! RSM COMPUTES EIGENVALUES, SOME EIGENVECTORS, REAL SYMMETRIC MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND ALL OF THE EIGENVALUES AND SOME OF THE EIGENVECTORS
!    OF A REAL SYMMETRIC MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), THE SYMMETRIC MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) M, SPECIFIES THE NUMBER OF EIGENVECTORS TO COMPUTE.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,M), CONTAINS THE ORTHONORMAL EIGENVECTORS
!    ASSOCIATED WITH THE FIRST M EIGENVALUES.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT, IMTQLV AND
!    TINVIT.  THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) FWORK1(N)
  REAL    ( KIND = 8 ) FWORK2(N)
  REAL    ( KIND = 8 ) FWORK3(N)
  REAL    ( KIND = 8 ) FWORK4(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IWORK(N)
  INTEGER ( KIND = 4 ) K1
  INTEGER ( KIND = 4 ) K2
  INTEGER ( KIND = 4 ) K3
  INTEGER ( KIND = 4 ) K4
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,M)

  K1 = 1
  K2 = K1 + N
  K3 = K2 + N
  K4 = K3 + N

  IF ( M <= 0 ) THEN

    CALL TRED1 ( N, A, W, FWORK1, FWORK2 )

    CALL TQLRAT ( N, W, FWORK2, IERR )

  ELSE

    CALL TRED1 ( N, A, FWORK1, FWORK2, FWORK3 )

    CALL IMTQLV ( N, FWORK1, FWORK2, FWORK3, W, IWORK, IERR )

    CALL TINVIT ( N, FWORK1, FWORK2, FWORK3, M, W, IWORK, Z, IERR )

    CALL TRBAK1 ( N, A, FWORK2, M, Z )

  END IF

  RETURN
END
SUBROUTINE RSP ( N, NV, A, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RSP COMPUTES EIGENVALUES AND EIGENVECTORS OF REAL SYMMETRIC PACKED MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A REAL SYMMETRIC PACKED MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) NV, THE DIMENSION OF THE ARRAY A, WHICH
!    MUST BE AT LEAST (N*(N+1))/2.
!
!    INPUT, REAL ( KIND = 8 ) A(NV), CONTAINS THE LOWER TRIANGLE OF THE
!    REAL SYMMETRIC PACKED MATRIX STORED ROW-WISE.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N
  INTEGER ( KIND = 4 ) NV

  REAL    ( KIND = 8 ) A(NV)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  IF ( ( N * ( N + 1 ) ) / 2 > NV ) THEN
    IERR = 20 * N
    RETURN
  END IF

  CALL TRED3 ( N, NV, A, W, FV1, FV2 )

  IF ( MATZ == 0 ) THEN

    CALL TQLRAT ( N, W, FV2, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSP - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TQLRAT.'
      RETURN
    END IF

  ELSE

    Z(1:N,1:N) = 0.0D+00

    DO I = 1, N
      Z(I,I) = 1.0D+00
    END DO

    CALL TQL2 ( N, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSP - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TQL2.'
      RETURN
    END IF

    CALL TRBAK3 ( N, NV, A, N, Z )

  END IF

  RETURN
END
SUBROUTINE RSPP ( N, NV, A, W, MATZ, Z, IERR, M, TYPE )

!*****************************************************************************80
!
!! RSPP COMPUTES SOME EIGENVALUES/VECTORS, REAL SYMMETRIC PACKED MATRIX.
!
!  DISCUSSION:
!
!    THIS ROUTINE CALLS THE APPROPRIATE ROUTINES FOR THE FOLLOWING PROBLEM:
!
!    GIVEN A SYMMETRIC MATRIX A, WHICH IS STORED IN A PACKED MODE, FIND
!    THE M SMALLEST OR LARGEST EIGENVALUES, AND CORRESPONDING EIGENVECTORS.
!
!    THE ROUTINE RSP RETURNS ALL EIGENVALUES AND EIGENVECTORS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF A, THE NUMBER OF ROWS AND
!    COLUMNS IN THE ORIGINAL MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) NV, IS THE OF THE ARRAY A AS SPECIFIED IN THE
!    CALLING PROGRAM.  NV MUST NOT BE LESS THAN N*(N+1)/2.
!
!    INPUT, REAL ( KIND = 8 ) A((N*(N+1))/2), ON INPUT THE LOWER TRIANGLE OF THE
!    REAL SYMMETRIC MATRIX, STORED ROW-WISE IN THE VECTOR,
!    IN THE ORDER A(1,1), / A(2,1), A(2,2), / A(3,1), A(3,2), A(3,3)/
!    AND SO ON.
!
!    OUTPUT, REAL ( KIND = 8 ) W(M), THE EIGENVALUES REQUESTED.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS SET TO 0 IF ONLY EIGENVALUES ARE
!    DESIRED.  OTHERWISE IT IS SET TO ANY NON-ZERO INTEGER FOR BOTH EIGENVALUES
!    AND EIGENVECTORS.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,M), THE EIGENVECTORS.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG FROM RATQR.  IERR=0 ON
!    NORMAL RETURN.  IERR NONZERO, IN THIS CASE, MEANS THAT THE ALGORITHM BROKE
!    DOWN WHILE COMPUTING AN EIGENVALUE.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVALUES TO BE FOUND.
!
!    INPUT, LOGICAL TYPE, SET TO .TRUE. IF THE SMALLEST EIGENVALUES
!    ARE TO BE FOUND, OR .FALSE. IF THE LARGEST ONES ARE SOUGHT.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N
  INTEGER ( KIND = 4 ) NV

  REAL    ( KIND = 8 ) A(NV)
  REAL    ( KIND = 8 ) BD(N)
  REAL    ( KIND = 8 ) EPS1
  INTEGER ( KIND = 4 ) IDEF
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) IWORK(N)
  INTEGER ( KIND = 4 ) MATZ
  LOGICAL              TYPE
  REAL    ( KIND = 8 ) W(M)
  REAL    ( KIND = 8 ) WORK1(N)
  REAL    ( KIND = 8 ) WORK2(N)
  REAL    ( KIND = 8 ) WORK3(N)
  REAL    ( KIND = 8 ) Z(N,M)
!
!  IDEF =
!    -1 IF THE MATRIX IS KNOWN TO BE NEGATIVE DEFINITE,
!    +1 IF THE MATRIX IS KNOWN TO BE POSITIVE DEFINITE, OR
!    0 OTHERWISE.
!
  IDEF = 0
!
!  REDUCE TO SYMMETRIC TRIDIAGONAL FORM.
!
  CALL TRED3 ( N, NV, A, WORK1, WORK2, WORK3 )
!
!  FIND THE EIGENVALUES.
!
  EPS1 = 0.0D+00

  CALL RATQR ( N, EPS1, WORK1, WORK2, WORK3, M, W, IWORK, &
    BD, TYPE, IDEF, IERR )

  IF ( IERR /= 0 ) THEN
    WRITE ( *, '(A)' ) ' '
    WRITE ( *, '(A)' ) 'RSPP - FATAL ERROR!'
    WRITE ( *, '(A)' ) '  ERROR RETURN FROM RATQR.'
    RETURN
  END IF
!
!  FIND EIGENVECTORS FOR THE FIRST M EIGENVALUES.
!
  IF ( MATZ /= 0 ) THEN

    CALL TINVIT ( N, WORK1, WORK2, WORK3, M, W, IWORK, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSPP - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TINVIT.'
      RETURN
    END IF
!
!  REVERSE THE TRANSFORMATION.
!
    CALL TRBAK3 ( N, NV, A, M, Z )

  END IF

  RETURN
END
SUBROUTINE RST ( N, W, E, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RST COMPUTES EIGENVALUES/VECTORS, REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF SUBROUTINES
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) W(N).  ON INPUT, THE DIAGONAL ELEMENTS
!    OF THE REAL SYMMETRIC TRIDIAGONAL MATRIX.  ON OUTPUT, THE EIGENVALUES IN
!    ASCENDING ORDER.
!
!    INPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE MATRIX IN
!    E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED,
!    AND NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR IMTQL1 AND IMTQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) E(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  IF ( MATZ == 0 ) THEN

    CALL IMTQL1 ( N, W, E, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RST - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM IMTQL1.'
      RETURN
    END IF

  ELSE

    Z(1:N,1:N) = 0.0D+00

    DO I = 1, N
      Z(I,I) = 1.0D+00
    END DO

    CALL IMTQL2 ( N, W, E, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RST - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM IMTQL2.'
      RETURN
    END IF

  END IF

  RETURN
END
SUBROUTINE RT ( N, A, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RT COMPUTES EIGENVALUES/VECTORS, REAL SIGN-SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF SUBROUTINES
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    OF A SPECIAL REAL TRIDIAGONAL MATRIX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS THE SPECIAL REAL TRIDIAGONAL
!    MATRIX IN ITS FIRST THREE COLUMNS.  THE SUBDIAGONAL ELEMENTS ARE STORED
!    IN THE LAST N-1 POSITIONS OF THE FIRST COLUMN, THE DIAGONAL ELEMENTS
!    IN THE SECOND COLUMN, AND THE SUPERDIAGONAL ELEMENTS IN THE FIRST N-1
!    POSITIONS OF THE THIRD COLUMN.  ELEMENTS A(1,1) AND A(N,3) ARE ARBITRARY.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS 0 IF ONLY EIGENVALUES ARE DESIRED,
!    AND NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR IMTQL1 AND IMTQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) FV1(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) A(N,3)
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  IF ( MATZ == 0 ) THEN

    CALL FIGI ( N, A, W, FV1, FV1, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RT - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM FIGI.'
      RETURN
    END IF

    CALL IMTQL1 ( N, W, FV1, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RT - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM IMTQL1.'
      RETURN
    END IF

  ELSE

    CALL FIGI2 ( N, A, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RT - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM FIGI2.'
      RETURN
    END IF

    CALL IMTQL2 ( N, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RT - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM IMTQL2.'
      RETURN
    END IF

  END IF

  RETURN
END
SUBROUTINE SVD ( M, N, A, W, MATU, U, MATV, V, IERR )

!*****************************************************************************80
!
!! SVD COMPUTES THE SINGULAR VALUE DECOMPOSITION FOR A REAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE DETERMINES THE SINGULAR VALUE DECOMPOSITION
!
!      A = U * S * V'
!
!    OF A REAL M BY N RECTANGULAR MATRIX.  HOUSEHOLDER BIDIAGONALIZATION
!    AND A VARIANT OF THE QR ALGORITHM ARE USED.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    GOLUB AND REINSCH,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 14, 1970, PAGES 403-420.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF ROWS OF A AND U.
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE NUMBER OF COLUMNS OF A AND U, AND
!    THE ORDER OF V.
!
!    INPUT, REAL ( KIND = 8 ) A(M,N), THE M BY N MATRIX TO BE DECOMPOSED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE SINGULAR VALUES OF A.  THESE ARE THE
!    DIAGONAL ELEMENTS OF S.  THEY ARE UNORDERED.  IF AN ERROR EXIT IS
!    MADE, THE SINGULAR VALUES SHOULD BE CORRECT FOR INDICES
!    IERR+1, IERR+2,..., N.
!
!    INPUT, LOGICAL MATU, SHOULD BE SET TO TRUE IF THE U MATRIX IN THE
!    DECOMPOSITION IS DESIRED, AND TO FALSE OTHERWISE.
!
!    OUTPUT, REAL ( KIND = 8 ) U(M,N), CONTAINS THE MATRIX U, WITH ORTHOGONAL
!    COLUMNS, OF THE DECOMPOSITION, IF MATU HAS BEEN SET TO TRUE.  OTHERWISE
!    U IS USED AS A TEMPORARY ARRAY.  U MAY COINCIDE WITH A.
!    IF AN ERROR EXIT IS MADE, THE COLUMNS OF U CORRESPONDING
!    TO INDICES OF CORRECT SINGULAR VALUES SHOULD BE CORRECT.
!
!    INPUT, LOGICAL MATV, SHOULD BE SET TO TRUE IF THE V MATRIX IN THE
!    DECOMPOSITION IS DESIRED, AND TO FALSE OTHERWISE.
!
!    OUTPUT, REAL ( KIND = 8 ) V(N,N), THE ORTHOGONAL MATRIX V OF THE
!    DECOMPOSITION IF MATV HAS BEEN SET TO TRUE.  OTHERWISE V IS NOT REFERENCED.
!    V MAY ALSO COINCIDE WITH A IF U IS NOT NEEDED.  IF AN ERROR
!    EXIT IS MADE, THE COLUMNS OF V CORRESPONDING TO INDICES OF
!    CORRECT SINGULAR VALUES SHOULD BE CORRECT.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    K, IF THE K-TH SINGULAR VALUE HAS NOT BEEN DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(M,N)
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) I1
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) KK
  INTEGER ( KIND = 4 ) K1
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) LL
  INTEGER ( KIND = 4 ) L1
  LOGICAL              MATU
  LOGICAL              MATV
  INTEGER ( KIND = 4 ) MN
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) U(M,N)
  REAL    ( KIND = 8 ) V(N,N)
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z

  IERR = 0
  U(1:M,1:N) = A(1:M,1:N)
!
!  HOUSEHOLDER REDUCTION TO BIDIAGONAL FORM.
!
  G = 0.0D+00
  SCALE = 0.0D+00
  X = 0.0D+00

  DO I = 1, N

    L = I + 1
    RV1(I) = SCALE * G
    G = 0.0D+00
    S = 0.0D+00
    SCALE = 0.0D+00

    IF ( I <= M ) THEN

      SCALE = SUM ( ABS ( U(I:M,I) ) )

      IF ( SCALE /= 0.0D+00 ) THEN

        U(I:M,I) = U(I:M,I) / SCALE

        S = SUM ( U(I:M,I)**2 )

        F = U(I,I)
        G = - SIGN ( SQRT ( S ), F )
        H = F * G - S
        U(I,I) = F - G

        IF ( I /= N ) THEN

          DO J = L, N
            S = DOT_PRODUCT ( U(I:M,I), U(I:M,J) )
            U(I:M,J) = U(I:M,J) + S * U(I:M,I) / H
          END DO

        END IF

        U(I:M,I) = SCALE * U(I:M,I)

      END IF

    END IF

    W(I) = SCALE * G
    G = 0.0D+00
    S = 0.0D+00
    SCALE = 0.0D+00

    IF ( I <= M .AND. I /= N ) THEN

      SCALE = SUM ( ABS ( U(I,L:N) ) )

      IF ( SCALE /= 0.0D+00 ) THEN

        U(I,L:N) = U(I,L:N) / SCALE
        S = SUM ( U(I,L:N)**2 )
        F = U(I,L)
        G = - SIGN ( SQRT ( S ), F )
        H = F * G - S
        U(I,L) = F - G
        RV1(L:N) = U(I,L:N) / H

        IF ( I /= M ) THEN

          DO J = L, M

            S = DOT_PRODUCT ( U(J,L:N), U(I,L:N) )

            U(J,L:N) = U(J,L:N) + S * RV1(L:N)

          END DO

        END IF

        U(I,L:N) = SCALE * U(I,L:N)

      END IF

    END IF

    X = MAX ( X, ABS ( W(I) ) + ABS ( RV1(I) ) )

  END DO
!
!  ACCUMULATION OF RIGHT-HAND TRANSFORMATIONS.
!
  IF ( MATV ) THEN

    DO I = N, 1, -1

      IF ( I /= N ) THEN

         IF ( G /= 0.0D+00 ) THEN

          V(L:N,I) = ( U(I,L:N) / U(I,L) ) / G

          DO J = L, N

            S = DOT_PRODUCT ( U(I,L:N), V(L:N,J) )

            V(L:N,J) = V(L:N,J) + S * V(L:N,I)

          END DO

        END IF

        V(I,L:N) = 0.0D+00
        V(L:N,I) = 0.0D+00

      END IF

      V(I,I) = 1.0D+00
      G = RV1(I)
      L = I

    END DO

  END IF
!
!  ACCUMULATION OF LEFT-HAND TRANSFORMATIONS.
!
  IF ( MATU ) THEN

    MN = MIN ( M, N )

    DO I = MIN ( M, N ), 1, -1

      L = I + 1
      G = W(I)

      IF ( I /= N ) THEN
        U(I,L:N) = 0.0D+00
      END IF

      IF ( G /= 0.0D+00 ) THEN

        IF ( I /= MN ) THEN

          DO J = L, N
            S = DOT_PRODUCT ( U(L:M,I), U(L:M,J) )
            F = ( S / U(I,I) ) / G
            U(I:M,J) = U(I:M,J) + F * U(I:M,I)
          END DO

        END IF

        U(I:M,I) = U(I:M,I) / G

      ELSE

        U(I:M,I) = 0.0D+00

      END IF

      U(I,I) = U(I,I) + 1.0D+00

    END DO

  END IF
!
!  DIAGONALIZATION OF THE BIDIAGONAL FORM.
!
  TST1 = X

  DO KK = 1, N

     K1 = N - KK
     K = K1 + 1
     ITS = 0
!
!  TEST FOR SPLITTING.
!
520  CONTINUE

     DO LL = 1, K

       L1 = K - LL
       L = L1 + 1
       TST2 = TST1 + ABS ( RV1(L) )

       IF ( TST2 == TST1 ) THEN
         GO TO 565
       END IF

       TST2 = TST1 + ABS ( W(L1) )

       IF ( TST2 == TST1 ) THEN
         EXIT
       END IF

     END DO
!
!  CANCELLATION OF RV1(L) IF L GREATER THAN 1.
!
     C = 0.0D+00
     S = 1.0D+00

     DO I = L, K

       F = S * RV1(I)
       RV1(I) = C * RV1(I)
       TST2 = TST1 + ABS ( F )

       IF ( TST2 == TST1 ) THEN
         GO TO 565
       END IF

       G = W(I)
       H = PYTHAG ( F, G )
       W(I) = H
       C = G / H
       S = -F / H

       IF ( MATU ) THEN

         DO J = 1, M
           Y = U(J,L1)
           Z = U(J,I)
           U(J,L1) = Y * C + Z * S
           U(J,I) = -Y * S + Z * C
         END DO

       END IF

    END DO
!
!  TEST FOR CONVERGENCE.
!
565 CONTINUE

    Z = W(K)

    IF ( L == K ) GO TO 650
!
!  SHIFT FROM BOTTOM 2 BY 2 MINOR.
!
    IF ( ITS >= 30 ) THEN
      IERR = K
      RETURN
    END IF

    ITS = ITS + 1
    X = W(L)
    Y = W(K1)
    G = RV1(K1)
    H = RV1(K)
    F = 0.5D+00 * ( ( ( G + Z ) / H ) * ( ( G - Z ) / Y ) + Y / H - H / Y )
    G = PYTHAG ( F, 1.0D+00 )
    F = X - ( Z / X ) * Z + ( H / X ) * ( Y / ( F + SIGN ( G, F ) ) - H)
!
!  NEXT QR TRANSFORMATION.
!
    C = 1.0D+00
    S = 1.0D+00

    DO I1 = L, K1

      I = I1 + 1
      G = RV1(I)
      Y = W(I)
      H = S * G
      G = C * G
      Z = PYTHAG ( F, H )
      RV1(I1) = Z
      C = F / Z
      S = H / Z
      F = X * C + G * S
      G = -X * S + G * C
      H = Y * S
      Y = Y * C

      IF ( MATV ) THEN

        DO J = 1, N
          X = V(J,I1)
          Z = V(J,I)
          V(J,I1) = X * C + Z * S
          V(J,I) = -X * S + Z * C
        END DO

      END IF

      Z = PYTHAG ( F, H )
      W(I1) = Z
!
!  ROTATION CAN BE ARBITRARY IF Z IS ZERO.
!
      IF ( Z /= 0.0D+00 ) THEN
        C = F / Z
        S = H / Z
      END IF

      F = C * G + S * Y
      X = -S * G + C * Y

      IF ( MATU ) THEN

        DO J = 1, M
          Y = U(J,I1)
          Z = U(J,I)
          U(J,I1) = Y * C + Z * S
          U(J,I) = -Y * S + Z * C
        END DO

      END IF

    END DO

    RV1(L) = 0.0D+00
    RV1(K) = F
    W(K) = X
    GO TO 520
!
!  CONVERGENCE.
!
650 CONTINUE

    IF ( Z <= 0.0D+00 ) THEN

      W(K) = - Z

      IF ( MATV ) THEN
        V(1:N,K) = - V(1:N,K)
      END IF

    END IF

  END DO

  RETURN
END
SUBROUTINE TIMESTAMP ( )

!*****************************************************************************80
!
!! TIMESTAMP PRINTS THE CURRENT YMDHMS DATE AS A TIME STAMP.
!
!  EXAMPLE:
!
!    MAY 31 2001   9:45:54.872 AM
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    04 FEBRUARY 2003
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    NONE
!
  IMPLICIT NONE

  CHARACTER ( LEN = 8 )  AMPM
  INTEGER   ( KIND = 4 ) D
  CHARACTER ( LEN = 8 )  DATE
  INTEGER   ( KIND = 4 ) H
  INTEGER   ( KIND = 4 ) M
  INTEGER   ( KIND = 4 ) MM
  CHARACTER ( LEN = 9 ), PARAMETER, DIMENSION(12) :: MONTH = (/ &
    'JANUARY  ', 'FEBRUARY ', 'MARCH    ', 'APRIL    ', &
    'MAY      ', 'JUNE     ', 'JULY     ', 'AUGUST   ', &
    'SEPTEMBER', 'OCTOBER  ', 'NOVEMBER ', 'DECEMBER ' /)
  INTEGER   ( KIND = 4 ) N
  INTEGER   ( KIND = 4 ) S
  CHARACTER ( LEN = 10 ) TIME
  INTEGER   ( KIND = 4 ) VALUES(8)
  INTEGER   ( KIND = 4 ) Y
  CHARACTER ( LEN = 5 )  ZONE

  CALL DATE_AND_TIME ( DATE, TIME, ZONE, VALUES )

  Y = VALUES(1)
  M = VALUES(2)
  D = VALUES(3)
  H = VALUES(5)
  N = VALUES(6)
  S = VALUES(7)
  MM = VALUES(8)

  IF ( H < 12 ) THEN
    AMPM = 'AM'
  ELSE IF ( H == 12 ) THEN
    IF ( N == 0 .AND. S == 0 ) THEN
      AMPM = 'NOON'
    ELSE
      AMPM = 'PM'
    END IF
  ELSE
    H = H - 12
    IF ( H < 12 ) THEN
      AMPM = 'PM'
    ELSE IF ( H == 12 ) THEN
      IF ( N == 0 .AND. S == 0 ) THEN
        AMPM = 'MIDNIGHT'
      ELSE
        AMPM = 'AM'
      END IF
    END IF
  END IF

  WRITE ( *, '(A,1X,I2,1X,I4,2X,I2,A1,I2.2,A1,I2.2,A1,I3.3,1X,A)' ) &
    TRIM ( MONTH(M) ), D, Y, H, ':', N, ':', S, '.', MM, TRIM ( AMPM )

  RETURN
END
SUBROUTINE TINVIT ( N, D, E, E2, M, W, IND, Z, IERR )

!*****************************************************************************80
!
!! TINVIT COMPUTES EIGENVECTORS FROM EIGENVALUES, REAL TRIDIAGONAL SYMMETRIC.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVECTORS OF A TRIDIAGONAL
!    SYMMETRIC MATRIX CORRESPONDING TO SPECIFIED EIGENVALUES,
!    USING INVERSE ITERATION.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!    B SMITH, J BOYLE, J DONGARRA, B GARBOW, Y IKEBE, V KLEMA, C MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF
!    THE INPUT MATRIX IN E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT, REAL ( KIND = 8 ) E2(N), CONTAINS THE SQUARES OF THE CORRESPONDING
!    ELEMENTS OF E, WITH ZEROS CORRESPONDING TO NEGLIGIBLE ELEMENTS OF E.
!    E(I) IS CONSIDERED NEGLIGIBLE IF IT IS NOT LARGER THAN THE PRODUCT OF
!    THE RELATIVE MACHINE PRECISION AND THE SUM OF THE MAGNITUDES OF D(I)
!    AND D(I-1).  E2(1) MUST CONTAIN 0.0D+00 IF THE EIGENVALUES ARE IN
!    ASCENDING ORDER, OR 2.0D+00 IF THE EIGENVALUES ARE IN DESCENDING ORDER.
!    IF BISECT, TRIDIB, OR IMTQLV HAS BEEN USED TO FIND THE EIGENVALUES,
!    THEIR OUTPUT E2 ARRAY IS EXACTLY WHAT IS EXPECTED HERE.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF SPECIFIED EIGENVALUES.
!
!    INPUT, REAL ( KIND = 8 ) W(M), THE EIGENVALUES.
!
!    INPUT, INTEGER ( KIND = 4 ) IND(M), THE SUBMATRIX INDICES ASSOCIATED WITH THE
!    CORRESPONDING EIGENVALUES IN W: 1 FOR EIGENVALUES BELONGING TO THE
!    FIRST SUBMATRIX FROM THE TOP, 2 FOR THOSE BELONGING TO THE SECOND
!    SUBMATRIX, AND SO ON.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,M), THE ASSOCIATED SET OF ORTHONORMAL
!    EIGENVECTORS.  ANY VECTOR WHICH FAILS TO CONVERGE IS SET TO ZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    -R, IF THE EIGENVECTOR CORRESPONDING TO THE R-TH EIGENVALUE FAILS TO
!      CONVERGE IN 5 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) EPS2
  REAL    ( KIND = 8 ) EPS3
  REAL    ( KIND = 8 ) EPS4
  INTEGER ( KIND = 4 ) GROUP
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IND(M)
  INTEGER ( KIND = 4 ) IP
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  REAL    ( KIND = 8 ) NORM
  REAL    ( KIND = 8 ) ORDER
  INTEGER ( KIND = 4 ) P
  REAL    ( KIND = 8 ) PYTHAG
  INTEGER ( KIND = 4 ) Q
  INTEGER ( KIND = 4 ) R
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) RV2(N)
  REAL    ( KIND = 8 ) RV3(N)
  REAL    ( KIND = 8 ) RV4(N)
  REAL    ( KIND = 8 ) RV6(N)
  INTEGER ( KIND = 4 ) S
  INTEGER ( KIND = 4 ) TAG
  REAL    ( KIND = 8 ) U
  REAL    ( KIND = 8 ) UK
  REAL    ( KIND = 8 ) V
  REAL    ( KIND = 8 ) W(M)
  REAL    ( KIND = 8 ) X0
  REAL    ( KIND = 8 ) X1
  REAL    ( KIND = 8 ) XU
  REAL    ( KIND = 8 ) Z(N,M)

  IERR = 0

  IF ( M == 0 ) THEN
    RETURN
  END IF

  U = 0.0D+00
  X0 = 0.0D+00

  TAG = 0
  ORDER = 1.0D+00 - E2(1)
  Q = 0
!
!  ESTABLISH AND PROCESS NEXT SUBMATRIX.
!
100 CONTINUE

  P = Q + 1

  DO Q = P, N
    IF ( Q == N ) THEN
      EXIT
    END IF
    IF ( E2(Q+1) == 0.0D+00 ) THEN
      EXIT
    END IF
  END DO
!
!  FIND VECTORS BY INVERSE ITERATION.
!
140 CONTINUE

  TAG = TAG + 1
  S = 0

  DO R = 1, M

     IF ( IND(R) /= TAG ) GO TO 920

     ITS = 1
     X1 = W(R)

     IF ( S /= 0 ) GO TO 510
!
!  CHECK FOR ISOLATED ROOT.
!
     XU = 1.0D+00

     IF ( P == Q ) THEN
       RV6(P) = 1.0D+00
       GO TO 870
     END IF

     NORM = ABS ( D(P) )
     IP = P + 1

     DO I = P+1, Q
       NORM = MAX ( NORM, ABS ( D(I) ) + ABS ( E(I) ) )
     END DO
!
!  EPS2 IS THE CRITERION FOR GROUPING,
!  EPS3 REPLACES ZERO PIVOTS AND EQUAL ROOTS ARE MODIFIED BY EPS3,
!  EPS4 IS TAKEN VERY SMALL TO AVOID OVERFLOW.
!
     EPS2 = 0.001D+00 * NORM
     EPS3 = ABS ( NORM ) * EPSILON ( EPS3 )
     UK = Q - P + 1
     EPS4 = UK * EPS3
     UK = EPS4 / SQRT ( UK )
     S = P

505 CONTINUE

     GROUP = 0
     GO TO 520
!
!  LOOK FOR CLOSE OR COINCIDENT ROOTS.
!
510  CONTINUE

     IF ( ABS ( X1 - X0 ) >= EPS2 ) GO TO 505

     GROUP = GROUP + 1

     IF ( ORDER * (X1 - X0) <= 0.0D+00 ) THEN
       X1 = X0 + ORDER * EPS3
     END IF
!
!  ELIMINATION WITH INTERCHANGES AND INITIALIZATION OF VECTOR.
!
520  CONTINUE

     V = 0.0D+00

     DO I = P, Q

        RV6(I) = UK

        IF ( I == P ) GO TO 560

        IF ( ABS ( E(I) ) < ABS ( U ) ) GO TO 540

        XU = U / E(I)
        RV4(I) = XU
        RV1(I-1) = E(I)
        RV2(I-1) = D(I) - X1
        RV3(I-1) = 0.0D+00
        IF ( I /= Q ) RV3(I-1) = E(I+1)
        U = V - XU * RV2(I-1)
        V = - XU * RV3(I-1)
        GO TO 580

540     CONTINUE

        XU = E(I) / U
        RV4(I) = XU
        RV1(I-1) = U
        RV2(I-1) = V
        RV3(I-1) = 0.0D+00

560     CONTINUE

        U = D(I) - X1 - XU * V
        IF ( I /= Q ) V = E(I+1)

580     CONTINUE

     END DO

     IF ( U == 0.0D+00 ) THEN
       U = EPS3
     END IF

     RV1(Q) = U
     RV2(Q) = 0.0D+00
     RV3(Q) = 0.0D+00
!
!  BACK SUBSTITUTION.
!
600   CONTINUE

  DO II = P, Q
    I = P + Q - II
    RV6(I) = ( RV6(I) - U * RV2(I) - V * RV3(I) ) / RV1(I)
    V = U
    U = RV6(I)
  END DO
!
!  ORTHOGONALIZE WITH RESPECT TO PREVIOUS MEMBERS OF GROUP.
!
     J = R

     DO JJ = 1, GROUP

       DO

         J = J - 1

         IF ( IND(J) == TAG ) THEN
           EXIT
         END IF

       END DO

       XU = DOT_PRODUCT ( RV6(P:Q), Z(P:Q,J) )

       RV6(P:Q) = RV6(P:Q) - XU * Z(P:Q,J)

     END DO

     NORM = SUM ( ABS ( RV6(P:Q) ) )

     IF ( NORM >= 1.0D+00 ) GO TO 840
!
!  FORWARD SUBSTITUTION.
!
     IF ( ITS == 5 ) GO TO 830

     IF ( NORM == 0.0D+00 ) THEN
       RV6(S) = EPS4
       S = S + 1
       IF ( S > Q ) S = P
       GO TO 780
     END IF

740  CONTINUE

     XU = EPS4 / NORM
     RV6(P:Q) = RV6(P:Q) * XU
!
!  ELIMINATION OPERATIONS ON NEXT VECTOR ITERATE.
!
780  CONTINUE
!
!  IF RV1(I-1) == E(I), A ROW INTERCHANGE WAS PERFORMED EARLIER IN THE
!  TRIANGULARIZATION PROCESS.
!
     DO I = IP, Q

       U = RV6(I)

       IF ( RV1(I-1) == E(I) ) THEN
         U = RV6(I-1)
         RV6(I-1) = RV6(I)
       END IF

       RV6(I) = U - RV4(I) * RV6(I-1)

     END DO

     ITS = ITS + 1
     GO TO 600
!
!  SET ERROR: NON-CONVERGED EIGENVECTOR.
!
830  CONTINUE

     IERR = -R
     XU = 0.0D+00
     GO TO 870
!
!  NORMALIZE SO THAT SUM OF SQUARES IS 1 AND EXPAND TO FULL ORDER.
!
840  CONTINUE

     U = 0.0D+00
     DO I = P, Q
       U = PYTHAG ( U, RV6(I) )
     END DO

     XU = 1.0D+00 / U

870  CONTINUE

     Z(1:N,R) = 0.0D+00
     Z(P:Q,R) = RV6(P:Q) * XU

     X0 = X1

920  CONTINUE

  END DO

  IF ( Q < N ) GO TO 100

  RETURN
END
SUBROUTINE TQL1 ( N, D, E, IERR )

!*****************************************************************************80
!
!! TQL1 COMPUTES ALL EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC TRIDIAGONAL
!    MATRIX BY THE QL METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCES:
!
!    BOWDLER, MARTIN, REINSCH, WILKINSON,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, 1968, PAGES 293-306.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, IS THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).
!    ON INPUT, THE DIAGONAL ELEMENTS OF THE MATRIX.
!    ON OUTPUT, THE EIGENVALUES IN ASCENDING ORDER.
!    IF AN ERROR EXIT IS MADE, THE EIGENVALUES ARE CORRECT AND
!    ORDERED FOR INDICES 1, 2,... IERR-1, BUT MAY NOT BE
!    THE SMALLEST EIGENVALUES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E(N).  ON INPUT, E(2:N) CONTAINS THE
!    SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX, AND E(1) IS ARBITRARY.
!    ON OUTPUT, E HAS BEEN DESTROYED.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NORMAL RETURN,
!    J, IF THE J-TH EIGENVALUE HAS NOT BEEN DETERMINED AFTER
!    30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) C2
  REAL    ( KIND = 8 ) C3
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) DL1
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) EL1
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) L2
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) S2
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2

  IERR = 0
  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E(I-1) = E(I)
  END DO

  F = 0.0D+00
  TST1 = 0.0D+00
  E(N) = 0.0D+00

  DO L = 1, N

    J = 0
    H = ABS ( D(L) ) + ABS ( E(L) )
    TST1 = MAX ( TST1, H )
!
!  LOOK FOR A SMALL SUB-DIAGONAL ELEMENT.
!
    DO M = L, N

      TST2 = TST1 + ABS ( E(M) )

      IF ( TST2 == TST1 ) THEN
        EXIT
      END IF

    END DO

    IF ( M == L ) GO TO 210

130 CONTINUE

    IF ( J >= 30 ) THEN
      IERR = L
      RETURN
    END IF

    J = J + 1
!
!  FORM THE SHIFT.
!
    L1 = L + 1
    L2 = L1 + 1
    G = D(L)
    P = ( D(L1) - G ) / ( 2.0D+00 * E(L) )
    R = PYTHAG ( P, 1.0D+00 )
    D(L) = E(L) / ( P + SIGN ( R, P ) )
    D(L1) = E(L) * ( P + SIGN ( R, P ) )
    DL1 = D(L1)
    H = G - D(L)

    D(L2:N) = D(L2:N) - H

    F = F + H
!
!  QL TRANSFORMATION.
!
    P = D(M)
    C = 1.0D+00
    C2 = C
    EL1 = E(L1)
    S = 0.0D+00
    MML = M - L

    DO II = 1, MML
      C3 = C2
      C2 = C
      S2 = S
      I = M - II
      G = C * E(I)
      H = C * P
      R = PYTHAG ( P, E(I) )
      E(I+1) = S * R
      S = E(I) / R
      C = P / R
      P = C * D(I) - S * G
      D(I+1) = H + S * ( C * G + S * D(I) )
    END DO

    P = - S * S2 * C3 * EL1 * E(L) / DL1
    E(L) = S * P
    D(L) = C * P
    TST2 = TST1 + ABS ( E(L) )
    IF ( TST2 > TST1 ) GO TO 130

210 CONTINUE

    P = D(L) + F
!
!  ORDER THE EIGENVALUES.
!
    DO II = 2, L
      I = L + 2 - II
      IF ( P >= D(I-1) ) THEN
        GO TO 270
      END IF
      D(I) = D(I-1)
    END DO

    I = 1

270 CONTINUE

    D(I) = P

  END DO

  RETURN
END
SUBROUTINE TQL2 ( N, D, E, Z, IERR )

!*****************************************************************************80
!
!! TQL2 COMPUTES ALL EIGENVALUES/VECTORS, REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS OF A SYMMETRIC
!    TRIDIAGONAL MATRIX BY THE QL METHOD.  THE EIGENVECTORS OF A FULL
!    SYMMETRIC MATRIX CAN ALSO BE FOUND IF TRED2 HAS BEEN USED TO REDUCE THIS
!    FULL MATRIX TO TRIDIAGONAL FORM.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    BOWDLER, MARTIN, REINSCH, WILKINSON,
!    TQL2,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 293-306, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).  ON INPUT, THE DIAGONAL ELEMENTS OF
!    THE MATRIX.  ON OUTPUT, THE EIGENVALUES IN ASCENDING ORDER.  IF AN ERROR
!    EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT UNORDERED FOR INDICES
!    1,2,...,IERR-1.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E(N).  ON INPUT, E(2:N) CONTAINS THE
!    SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX, AND E(1) IS ARBITRARY.
!    ON OUTPUT, E HAS BEEN DESTROYED.
!
!    INPUT, REAL ( KIND = 8 ) Z(N,N).  ON INPUT, THE TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION BY TRED2, IF PERFORMED.  IF THE EIGENVECTORS OF
!    THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN THE IDENTITY MATRIX.
!    ON OUTPUT, Z CONTAINS THE ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
!    TRIDIAGONAL (OR FULL) MATRIX.  IF AN ERROR EXIT IS MADE, Z CONTAINS
!    THE EIGENVECTORS ASSOCIATED WITH THE STORED EIGENVALUES.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NORMAL RETURN,
!    J, IF THE J-TH EIGENVALUE HAS NOT BEEN DETERMINED AFTER
!    30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) C2
  REAL    ( KIND = 8 ) C3
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) DL1
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) EL1
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) L2
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) S2
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) Z(N,N)

  IERR = 0

  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E(I-1) = E(I)
  END DO

  F = 0.0D+00
  TST1 = 0.0D+00
  E(N) = 0.0D+00

  DO L = 1, N

     J = 0
     H = ABS ( D(L) ) + ABS ( E(L) )
     TST1 = MAX ( TST1, H )
!
!  LOOK FOR A SMALL SUB-DIAGONAL ELEMENT.
!
     DO M = L, N
       TST2 = TST1 + ABS ( E(M) )
       IF ( TST2 == TST1 ) THEN
         EXIT
       END IF
     END DO

     IF ( M == L ) THEN
       GO TO 220
     END IF

 130 CONTINUE

     IF ( 30 <= J ) THEN
       IERR = L
       RETURN
     END IF

     J = J + 1
!
!  FORM SHIFT.
!
     L1 = L + 1
     L2 = L1 + 1
     G = D(L)
     P = ( D(L1) - G ) / ( 2.0D+00 * E(L) )
     R = PYTHAG ( P, 1.0D+00 )
     D(L) = E(L) / ( P + SIGN ( R, P ) )
     D(L1) = E(L) * ( P + SIGN ( R, P ) )
     DL1 = D(L1)
     H = G - D(L)
     D(L2:N) = D(L2:N) - H
     F = F + H
!
!  QL TRANSFORMATION.
!
     P = D(M)
     C = 1.0D+00
     C2 = C
     EL1 = E(L1)
     S = 0.0D+00
     MML = M - L

     DO II = 1, MML

        C3 = C2
        C2 = C
        S2 = S
        I = M - II
        G = C * E(I)
        H = C * P
        R = PYTHAG ( P, E(I) )
        E(I+1) = S * R
        S = E(I) / R
        C = P / R
        P = C * D(I) - S * G
        D(I+1) = H + S * ( C * G + S * D(I) )
!
!  FORM VECTOR.
!
        DO K = 1, N
          H = Z(K,I+1)
          Z(K,I+1) = S * Z(K,I) + C * H
          Z(K,I) = C * Z(K,I) - S * H
        END DO

     END DO

     P = - S * S2 * C3 * EL1 * E(L) / DL1
     E(L) = S * P
     D(L) = C * P
     TST2 = TST1 + ABS ( E(L) )

     IF ( TST2 > TST1 ) THEN
       GO TO 130
     END IF

220  CONTINUE

     D(L) = D(L) + F

  END DO
!
!  ORDER EIGENVALUES AND EIGENVECTORS.
!
  DO II = 2, N

    I = II - 1
    K = I
    P = D(I)

    DO J = II, N

      IF ( D(J) < P ) THEN
        K = J
        P = D(J)
      END IF

    END DO

    IF ( K /= I ) THEN

      D(K) = D(I)
      D(I) = P

      DO J = 1, N
        CALL R8_SWAP ( Z(J,I), Z(J,K) )
      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE TQLRAT ( N, D, E2, IERR )

!*****************************************************************************80
!
!! TQLRAT COMPUTES ALL EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC
!    TRIDIAGONAL MATRIX BY THE RATIONAL QL METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    C REINSCH,
!    ALGORITHM 464, TQLRAT,
!    COMMUNICATIONS OF THE ACM,
!    VOLUME 16, PAGE 689, 1973.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).  ON INPUT, D CONTAINS THE DIAGONAL
!    ELEMENTS OF THE MATRIX.  ON OUTPUT, D CONTAINS THE EIGENVALUES IN ASCENDING
!    ORDER.  IF AN ERROR EXIT WAS MADE, THEN THE EIGENVALUES ARE CORRECT
!    IN POSITIONS 1 THROUGH IERR-1, BUT MAY NOT BE THE SMALLEST EIGENVALUES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N), CONTAINS IN POSITIONS 2 THROUGH N THE
!    SQUARES OF THE SUBDIAGONAL ELEMENTS OF THE MATRIX.  E2(1) IS
!    ARBITRARY.  ON OUTPUT, E2 HAS BEEN OVERWRITTEN BY WORKSPACE
!    INFORMATION.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NO ERROR,
!    J, IF THE J-TH EIGENVALUE COULD NOT BE DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) PYTHAG
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T

  IERR = 0

  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E2(I-1) = E2(I)
  END DO

  F = 0.0D+00
  T = 0.0D+00
  E2(N) = 0.0D+00

  DO L = 1, N

     J = 0
     H = ABS ( D(L) ) + SQRT ( E2(L) )

     IF ( T <= H ) THEN

       T = H
       B = ABS ( T ) * EPSILON ( B )
       C = B * B

     END IF
!
!  LOOK FOR SMALL SQUARED SUB-DIAGONAL ELEMENT.
!
     DO M = L, N
       IF ( E2(M) <= C ) THEN
         EXIT
       END IF
     END DO

     IF ( M == L ) GO TO 210

130  CONTINUE

     IF ( J >= 30 ) THEN
       IERR = L
       RETURN
     END IF

     J = J + 1
!
!  FORM SHIFT.
!
     L1 = L + 1
     S = SQRT ( E2(L) )
     G = D(L)
     P = ( D(L1) - G ) / ( 2.0D+00 * S )
     R = PYTHAG ( P, 1.0D+00 )
     D(L) = S / ( P + SIGN ( R, P ) )
     H = G - D(L)
     D(L1:N) = D(L1:N) - H
     F = F + H
!
!  RATIONAL QL TRANSFORMATION.
!
     G = D(M)
     IF ( G == 0.0D+00 ) G = B
     H = G
     S = 0.0D+00
     MML = M - L

     DO II = 1, MML
       I = M - II
       P = G * H
       R = P + E2(I)
       E2(I+1) = S * R
       S = E2(I) / R
       D(I+1) = H + S * ( H + D(I) )
       G = D(I) - E2(I) / G
       IF ( G == 0.0D+00 ) G = B
       H = G * P / R
     END DO

     E2(L) = S * G
     D(L) = H
!
!  GUARD AGAINST UNDERFLOW IN CONVERGENCE TEST.
!
     IF ( H == 0.0D+00 ) GO TO 210
     IF ( ABS ( E2(L) ) <= ABS ( C / H ) ) GO TO 210
     E2(L) = H * E2(L)
     IF ( E2(L) /= 0.0D+00 ) GO TO 130

210  CONTINUE

     P = D(L) + F
!
!  ORDER THE EIGENVALUES.
!
     DO II = 2, L
       I = L + 2 - II
       IF ( P >= D(I-1) ) GO TO 270
       D(I) = D(I-1)
     END DO

250  CONTINUE

     I = 1

270  CONTINUE

     D(I) = P

290  CONTINUE

  END DO

  RETURN
END
SUBROUTINE TRBAK1 ( N, A, E, M, Z )

!*****************************************************************************80
!
!! TRBAK1 DETERMINES EIGENVECTORS BY UNDOING THE TRED1 TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A REAL SYMMETRIC
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY TRED1.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS INFORMATION ABOUT THE ORTHOGONAL
!    TRANSFORMATIONS USED IN THE REDUCTION BY TRED1 IN ITS STRICT LOWER
!    TRIANGLE.
!
!    INPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX IN E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE EIGENVECTORS TO BE
!    BACK TRANSFORMED.  ON OUTPUT, THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) E(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) Z(N,M)

  IF ( M <= 0 ) THEN
    RETURN
  END IF

  IF ( N <= 1 ) THEN
    RETURN
  END IF

  DO I = 2, N

    L = I - 1

    IF ( E(I) /= 0.0D+00 ) THEN

      DO J = 1, M

        S = DOT_PRODUCT ( A(I,1:L), Z(1:L,J) )

        S = ( S / A(I,L) ) / E(I)

        Z(1:L,J) = Z(1:L,J) + S * A(I,1:L)

      END DO

    END IF

  END DO

  CONTINUE

  RETURN
END
SUBROUTINE TRBAK3 ( N, NV, A, M, Z )

!*****************************************************************************80
!
!! TRBAK3 DETERMINES EIGENVECTORS BY UNDOING THE TRED3 TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A REAL SYMMETRIC
!    MATRIX BY BACK TRANSFORMING THOSE OF THE CORRESPONDING
!    SYMMETRIC TRIDIAGONAL MATRIX DETERMINED BY TRED3.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) NV, THE DIMENSION OF THE ARRAY PARAMATER A,
!    WHICH MUST BE AT LEAST N*(N+1)/2.
!
!    INPUT, REAL ( KIND = 8 ) A(NV), INFORMATION ABOUT THE ORTHOGONAL
!    TRANSFORMATIONS USED IN THE REDUCTION BY TRED3.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE EIGENVECTORS TO BE BACK
!    TRANSFORMED.  ON OUTPUT, THE TRANSFORMED EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) NV

  REAL    ( KIND = 8 ) A(NV)
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IK
  INTEGER ( KIND = 4 ) IZ
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) N
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) Z(N,M)

  IF ( M == 0 ) THEN
    RETURN
  END IF

  DO I = 2, N

    L = I - 1
    IZ = ( I * L ) / 2
    IK = IZ + I
    H = A(IK)

    IF ( H /= 0.0D+00 ) THEN

      DO J = 1, M

        S = 0.0D+00
        IK = IZ

        DO K = 1, L
          IK = IK + 1
          S = S + A(IK) * Z(K,J)
        END DO

        S = ( S / H ) / H
        IK = IZ

        DO K = 1, L
          IK = IK + 1
          Z(K,J) = Z(K,J) - S * A(IK)
        END DO

      END DO

    END IF

  END DO

  RETURN
END
SUBROUTINE TRED1 ( N, A, D, E, E2 )

!*****************************************************************************80
!
!! TRED1 TRANSFORMS A REAL SYMMETRIC MATRIX TO SYMMETRIC TRIDIAGONAL FORM.
!
!  DISCUSSION:
!
!    THE ROUTINE REDUCES A REAL SYMMETRIC MATRIX TO A SYMMETRIC
!    TRIDIAGONAL MATRIX USING ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN, REINSCH, WILKINSON,
!    TRED1,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 181-195, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX A.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N), ON INPUT, CONTAINS THE REAL
!    SYMMETRIC MATRIX.  ONLY THE LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!    ON OUTPUT, A CONTAINS INFORMATION ABOUT THE ORTHOGONAL TRANSFORMATIONS
!    USED IN THE REDUCTION IN ITS STRICT LOWER TRIANGLE.
!    THE FULL UPPER TRIANGLE OF A IS UNALTERED.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), CONTAINS THE DIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N), CONTAINS THE SQUARES OF THE CORRESPONDING
!    ELEMENTS OF E.  E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) SCALE

  D(1:N) = A(N,1:N)

  DO I = 1, N
    A(N,I) = A(I,I)
  END DO

  DO II = 1, N

    I = N + 1 - II
    L = I - 1
    H = 0.0D+00
!
!  SCALE ROW.
!
    SCALE = SUM ( ABS ( D(1:L) ) )

    IF ( SCALE == 0.0D+00 ) THEN

      DO J = 1, L
        D(J) = A(L,J)
        A(L,J) = A(I,J)
        A(I,J) = 0.0D+00
      END DO

      E(I) = 0.0D+00
      E2(I) = 0.0D+00

      CYCLE

    END IF

    D(1:L) = D(1:L) / SCALE

    DO K = 1, L
      H = H + D(K)**2
    END DO

    E2(I) = H * SCALE**2
    F = D(L)
    G = - SIGN ( SQRT ( H ), F )
    E(I) = SCALE * G
    H = H - F * G
    D(L) = F - G

    IF ( L >= 1 ) THEN
!
!  FORM A * U.
!
      E(1:L) = 0.0D+00

      DO J = 1, L

        F = D(J)
        G = E(J) + A(J,J) * F

        DO K = J+1, L
          G = G + A(K,J) * D(K)
          E(K) = E(K) + A(K,J) * F
        END DO

        E(J) = G

      END DO
!
!  FORM P.
!
      F = 0.0D+00

      DO J = 1, L
        E(J) = E(J) / H
        F = F + E(J) * D(J)
      END DO

      H = F / ( H + H )
!
!  FORM Q.
!
      E(1:L) = E(1:L) - H * D(1:L)
!
!  FORM REDUCED A.
!
      DO J = 1, L

        F = D(J)
        G = E(J)

        A(J:L,J) = A(J:L,J) - F * E(J:L) - G * D(J:L)

      END DO

    END IF

    DO J = 1, L
      F = D(J)
      D(J) = A(L,J)
      A(L,J) = A(I,J)
      A(I,J) = F * SCALE
    END DO


  END DO

  RETURN
END
SUBROUTINE TRED2 ( N, A, D, E, Z )

!*****************************************************************************80
!
!! TRED2 TRANSFORMS A REAL SYMMETRIC MATRIX TO SYMMETRIC TRIDIAGONAL FORM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES A REAL SYMMETRIC MATRIX TO A
!    SYMMETRIC TRIDIAGONAL MATRIX USING AND ACCUMULATING
!    ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!    A AND Z MAY COINCIDE, IN WHICH CASE A SINGLE STORAGE AREA IS USED
!    FOR THE INPUT OF A AND THE OUTPUT OF Z.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN, REINSCH, WILKINSON,
!    TRED2,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 181-195, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), THE REAL SYMMETRIC INPUT MATRIX.  ONLY THE
!    LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX IN E(2:N).  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), THE ORTHOGONAL TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  REAL    ( KIND = 8 ) HH
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) Z(N,N)

  DO I = 1, N
    Z(I:N,I) = A(I:N,I)
  END DO

  D(1:N) = A(N,1:N)

  DO II = 2, N

    I = N + 2 - II
    L = I - 1
    H = 0.0D+00
    SCALE = 0.0D+00
!
!  SCALE ROW.
!
    DO K = 1, L
      SCALE = SCALE + ABS ( D(K) )
    END DO

    IF ( SCALE == 0.0D+00 ) THEN

      E(I) = D(L)

      DO J = 1, L
        D(J) = Z(L,J)
        Z(I,J) = 0.0D+00
        Z(J,I) = 0.0D+00
      END DO

      GO TO 290

    END IF

    D(1:L) = D(1:L) / SCALE

    H = H + DOT_PRODUCT ( D(1:L), D(1:L) )

    F = D(L)
    G = - SIGN ( SQRT ( H ), F )
    E(I) = SCALE * G
    H = H - F * G
    D(L) = F - G
!
!  FORM A*U.
!
    E(1:L) = 0.0D+00

    DO J = 1, L

      F = D(J)
      Z(J,I) = F
      G = E(J) + Z(J,J) * F

      DO K = J+1, L
        G = G + Z(K,J) * D(K)
        E(K) = E(K) + Z(K,J) * F
      END DO

      E(J) = G

    END DO
!
!  FORM P.
!
    E(1:L) = E(1:L) / H

    F = DOT_PRODUCT ( E(1:L), D(1:L) )

    HH = 0.5D+00 * F / H
!
!  FORM Q.
!
    E(1:L) = E(1:L) - HH * D(1:L)
!
!  FORM REDUCED A.
!
    DO J = 1, L

      F = D(J)
      G = E(J)

      Z(J:L,J) = Z(J:L,J) - F * E(J:L) - G * D(J:L)

      D(J) = Z(L,J)
      Z(I,J) = 0.0D+00

    END DO

290 CONTINUE

    D(I) = H


  END DO
!
!  ACCUMULATION OF TRANSFORMATION MATRICES.
!
  DO I = 2, N

    L = I - 1
    Z(N,L) = Z(L,L)
    Z(L,L) = 1.0D+00
    H = D(I)
    IF ( H /= 0.0D+00 ) THEN

      D(1:L) = Z(1:L,I) / H

      DO J = 1, L

        G = DOT_PRODUCT ( Z(1:L,I), Z(1:L,J) )

        DO K = 1, L
          Z(K,J) = Z(K,J) - G * D(K)
        END DO

      END DO

    END IF

    Z(1:L,I) = 0.0D+00

  END DO

  D(1:N) = Z(N,1:N)

  Z(N,1:N-1) = 0.0D+00
  Z(N,N) = 1.0D+00

  E(1) = 0.0D+00

  RETURN
END
SUBROUTINE TRED3 ( N, NV, A, D, E, E2 )

!*****************************************************************************80
!
!! TRED3 TRANSFORMS A REAL SYMMETRIC PACKED MATRIX TO SYMMETRIC TRIDIAGONAL FORM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES A REAL SYMMETRIC MATRIX, STORED AS
!    A ONE-DIMENSIONAL ARRAY, TO A SYMMETRIC TRIDIAGONAL MATRIX
!    USING ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN, REINSCH, WILKINSON,
!    TRED3,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 181-195, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) NV, THE DIMENSION OF A, WHICH MUST BE AT LEAST
!    (N*(N+1))/2.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(NV).  ON INPUT, THE LOWER TRIANGLE OF
!    THE REAL SYMMETRIC MATRIX, STORED ROW-WISE.  ON OUTPUT, INFORMATION ABOUT
!    THE ORTHOGONAL TRANSFORMATIONS USED IN THE REDUCTION.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX IN E(2:N).  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N),  THE SQUARES OF THE CORRESPONDING
!    ELEMENTS OF E.  E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N
  INTEGER ( KIND = 4 ) NV

  REAL    ( KIND = 8 ) A(NV)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  REAL    ( KIND = 8 ) HH
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IZ
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JK
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) SCALE

  DO II = 1, N

     I = N + 1 - II
     L = I - 1
     IZ = ( I * L ) / 2
     H = 0.0D+00
     SCALE = 0.0D+00
!
!  SCALE ROW.
!
     DO K = 1, L
       IZ = IZ + 1
       D(K) = A(IZ)
       SCALE = SCALE + ABS ( D(K) )
     END DO

     IF ( SCALE == 0.0D+00 ) THEN
       E(I) = 0.0D+00
       E2(I) = 0.0D+00
       GO TO 290
     END IF

     DO K = 1, L
       D(K) = D(K) / SCALE
       H = H + D(K)**2
     END DO

     E2(I) = SCALE * SCALE * H
     F = D(L)
     G = - SIGN ( SQRT ( H ), F )
     E(I) = SCALE * G
     H = H - F * G
     D(L) = F - G
     A(IZ) = SCALE * D(L)

     IF ( L == 1 ) GO TO 290

     JK = 1

     DO J = 1, L

        F = D(J)
        G = 0.0D+00

        DO K = 1, J-1
          G = G + A(JK) * D(K)
          E(K) = E(K) + A(JK) * F
          JK = JK + 1
        END DO

        E(J) = G + A(JK) * F
        JK = JK + 1

     END DO
!
!  FORM P.
!
     E(1:L) = E(1:L) / H
     F = DOT_PRODUCT ( E(1:L), D(1:L) )
     HH = F / ( H + H )
!
!  FORM Q.
!
     E(1:L) = E(1:L) - HH * D(1:L)
     JK = 1
!
!  FORM REDUCED A.
!
     DO J = 1, L
       F = D(J)
       G = E(J)
       DO K = 1, J
         A(JK) = A(JK) - F * E(K) - G * D(K)
         JK = JK + 1
       END DO
     END DO

290  CONTINUE

     D(I) = A(IZ+1)
     A(IZ+1) = SCALE * SQRT ( H )

300  CONTINUE

  END DO

  RETURN
END
SUBROUTINE TRIDIB ( N, EPS1, D, E, E2, LB, UB, M11, M, W, IND, IERR )

!*****************************************************************************80
!
!! TRIDIB COMPUTES SOME EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVALUES OF A TRIDIAGONAL
!    SYMMETRIC MATRIX BETWEEN SPECIFIED BOUNDARY INDICES,
!    USING BISECTION.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) EPS1.  ON INPUT, AN ABSOLUTE ERROR
!    TOLERANCE FOR THE COMPUTED EIGENVALUES.  IT SHOULD BE CHOSEN COMMENSURATE
!    WITH RELATIVE PERTURBATIONS IN THE MATRIX ELEMENTS OF THE ORDER OF THE
!    RELATIVE MACHINE PRECISION.  IF THE INPUT EPS1 IS NON-POSITIVE, IT
!    IS RESET FOR EACH SUBMATRIX TO A DEFAULT VALUE, NAMELY, MINUS THE
!    PRODUCT OF THE RELATIVE MACHINE PRECISION AND THE 1-NORM OF THE SUBMATRIX.
!
!    INPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
!    IN E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N).  ON INPUT, THE SQUARES OF THE
!    CORRESPONDING ELEMENTS OF E.  E2(1) IS ARBITRARY.  ON OUTPUT, ELEMENTS OF
!    E2 CORRESPONDING TO ELEMENTS OF E REGARDED AS NEGLIGIBLE, HAVE BEEN
!    REPLACED BY ZERO, CAUSING THE MATRIX TO SPLIT INTO A DIRECT SUM OF
!    SUBMATRICES.  E2(1) IS ALSO SET TO ZERO.
!
!    INPUT, INTEGER ( KIND = 4 ) M11, THE LOWER BOUNDARY INDEX FOR THE DESIRED
!    EIGENVALUES.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVALUES DESIRED.  THE
!    UPPER BOUNDARY INDEX M22 IS THEN OBTAINED AS M22 = M11 + M - 1.
!
!    OUTPUT, REAL ( KIND = 8 ) LB, UB, DEFINE AN INTERVAL CONTAINING EXACTLY
!    THE DESIRED EIGENVALUES.
!
!    OUTPUT, REAL ( KIND = 8 ) W(M), THE EIGENVALUES BETWEEN INDICES M11 AND M22
!    IN ASCENDING ORDER.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IND(M), THE SUBMATRIX INDICES ASSOCIATED WITH
!    THE CORRESPONDING EIGENVALUES IN W: 1 FOR EIGENVALUES BELONGING TO THE
!    FIRST SUBMATRIX FROM THE TOP, 2 FOR THOSE BELONGING TO THE SECOND
!    SUBMATRIX, AND SO ON.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    3*N+1, IF MULTIPLE EIGENVALUES AT INDEX M11 MAKE UNIQUE SELECTION
!      IMPOSSIBLE,
!    3*N+2, IF MULTIPLE EIGENVALUES AT INDEX M22 MAKE UNIQUE SELECTION
!      IMPOSSIBLE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) EPS1
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IND(M)
  INTEGER ( KIND = 4 ) ISTURM
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) LB
  INTEGER ( KIND = 4 ) M1
  INTEGER ( KIND = 4 ) M11
  INTEGER ( KIND = 4 ) M2
  INTEGER ( KIND = 4 ) M22
  INTEGER ( KIND = 4 ) P
  INTEGER ( KIND = 4 ) Q
  INTEGER ( KIND = 4 ) R
  REAL    ( KIND = 8 ) RV4(N)
  REAL    ( KIND = 8 ) RV5(N)
  INTEGER ( KIND = 4 ) S
  REAL    ( KIND = 8 ) T1
  REAL    ( KIND = 8 ) T2
  INTEGER ( KIND = 4 ) TAG
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) U
  REAL    ( KIND = 8 ) UB
  REAL    ( KIND = 8 ) V
  REAL    ( KIND = 8 ) W(M)
  REAL    ( KIND = 8 ) X0
  REAL    ( KIND = 8 ) X1
  REAL    ( KIND = 8 ) XU

  IERR = 0
  TAG = 0
  XU = D(1)
  X0 = D(1)
  S = 0
  U = 0.0D+00
!
!  LOOK FOR SMALL SUB-DIAGONAL ENTRIES AND DETERMINE AN
!  INTERVAL CONTAINING ALL THE EIGENVALUES.
!
  DO I = 1, N

     X1 = U

     IF ( I == N ) THEN
       U = 0.0D+00
     ELSE
       U = ABS ( E(I+1) )
     END IF

     XU = MIN ( XU, D(I)-(X1+U) )
     X0 = MAX ( X0, D(I)+(X1+U) )

     IF ( I >= 1 ) THEN
       TST1 = ABS ( D(I) ) + ABS ( D(I-1) )
       TST2 = TST1 + ABS ( E(I) )
       IF ( TST2 <= TST1 ) THEN
         E2(I) = 0.0D+00
       END IF
     ELSE
       E2(I) = 0.0D+00
     END IF

  END DO

  X1 = N
  X1 = X1 * MAX ( ABS ( XU ), ABS ( X0 ) ) * EPSILON ( X1 )
  XU = XU - X1
  T1 = XU
  X0 = X0 + X1
  T2 = X0
!
!  DETERMINE AN INTERVAL CONTAINING EXACTLY THE DESIRED EIGENVALUES.
!
  P = 1
  Q = N
  M1 = M11 - 1
  IF ( M1 == 0 ) GO TO 75
  ISTURM = 1

50 CONTINUE

  V = X1
  X1 = XU + (X0 - XU) * 0.5D+00
  IF ( X1 == V ) GO TO 980
  GO TO 320

60 CONTINUE

  IF ( S - M1 ) 65, 73, 70

65 CONTINUE

  XU = X1
  GO TO 50

70 CONTINUE

  X0 = X1
  GO TO 50

73 CONTINUE

  XU = X1
  T1 = X1

75 CONTINUE

  M22 = M1 + M
  IF ( M22 == N ) GO TO 90
  X0 = T2
  ISTURM = 2
  GO TO 50

80 CONTINUE

   IF ( S - M22 ) 65, 85, 70

85 CONTINUE

   T2 = X1

90 CONTINUE

  Q = 0
  R = 0
!
!  ESTABLISH AND PROCESS NEXT SUBMATRIX, REFINING INTERVAL BY THE
!  GERSCHGORIN BOUNDS.
!
100 CONTINUE

  IF ( R == M ) THEN
    GO TO 1001
  END IF

  TAG = TAG + 1
  P = Q + 1
  XU = D(P)
  X0 = D(P)
  U = 0.0D+00

  DO Q = P, N

    X1 = U
    U = 0.0D+00
    V = 0.0D+00

    IF ( Q < N ) THEN
      U = ABS ( E(Q+1) )
      V = E2(Q+1)
    END IF

    XU = MIN ( D(Q)-(X1+U), XU )
    X0 = MAX ( D(Q)+(X1+U), X0 )

    IF ( V == 0.0D+00 ) THEN
      EXIT
    END IF

  END DO

  X1 = MAX ( ABS ( XU ), ABS ( X0 ) ) * EPSILON ( X1 )
  IF ( EPS1 <= 0.0D+00 ) EPS1 = -X1
  IF ( P /= Q ) GO TO 180
!
!  CHECK FOR ISOLATED ROOT WITHIN INTERVAL.
!
  IF ( T1 > D(P) .OR. D(P) >= T2 ) GO TO 940
  M1 = P
  M2 = P
  RV5(P) = D(P)
  GO TO 900

180 CONTINUE

  X1 = X1 * (Q - P + 1)
  LB = MAX ( T1, XU-X1 )
  UB = MIN ( T2, X0+X1 )
  X1 = LB
  ISTURM = 3
  GO TO 320

200 CONTINUE

  M1 = S + 1
  X1 = UB
  ISTURM = 4
  GO TO 320

220 CONTINUE

  M2 = S
  IF ( M1 > M2 ) GO TO 940
!
!  FIND ROOTS BY BISECTION.
!
  X0 = UB
  ISTURM = 5

  RV5(M1:M2) = UB
  RV4(M1:M2) = LB
!
!  LOOP FOR THE K-TH EIGENVALUE.
!
  K = M2

250 CONTINUE

  XU = LB

  DO II = M1, K

    I = M1 + K - II
    IF ( XU < RV4(I) ) THEN
      XU = RV4(I)
      EXIT
    END IF

  END DO

  IF ( X0 > RV5(K) ) X0 = RV5(K)
!
!  NEXT BISECTION STEP.
!
300  CONTINUE

     X1 = ( XU + X0 ) * 0.5D+00
     IF ( ( X0 - XU ) <= ABS ( EPS1) ) GO TO 420
     TST1 = 2.0D+00 * ( ABS ( XU ) + ABS ( X0 ) )
     TST2 = TST1 + (X0 - XU)
     IF ( TST2 == TST1 ) GO TO 420
!
!  STURM SEQUENCE.
!
320  CONTINUE

     S = P - 1
     U = 1.0D+00

     DO I = P, Q

       IF ( U == 0.0D+00 ) THEN
         V = ABS ( E(I) ) / EPSILON ( V )
         IF ( E2(I) == 0.0D+00 ) V = 0.0D+00
       ELSE
         V = E2(I) / U
       END IF

       U = D(I) - X1 - V

       IF ( U < 0.0D+00 ) THEN
         S = S + 1
       END IF

     END DO

     GO TO (60,80,200,220,360), ISTURM
!
!  REFINE INTERVALS.
!
360  CONTINUE

     IF ( S >= K) GO TO 400
     XU = X1
     IF ( S >= M1) GO TO 380
     RV4(M1) = X1
     GO TO 300

380  CONTINUE

     RV4(S+1) = X1
     IF ( RV5(S) > X1) RV5(S) = X1
     GO TO 300

400  CONTINUE

     X0 = X1
     GO TO 300
!
!  K-TH EIGENVALUE FOUND.
!
420  CONTINUE

  RV5(K) = X1
  K = K - 1
  IF ( K >= M1 ) GO TO 250
!
!  ORDER EIGENVALUES TAGGED WITH THEIR SUBMATRIX ASSOCIATIONS.
!
900 CONTINUE

  S = R
  R = R + M2 - M1 + 1
  J = 1
  K = M1

  DO L = 1, R

     IF ( J > S ) GO TO 910
     IF ( K > M2 ) GO TO 940
     IF ( RV5(K) >= W(L) ) GO TO 915

     DO II = J, S
       I = L + S - II
       W(I+1) = W(I)
       IND(I+1) = IND(I)
     END DO

910  CONTINUE

     W(L) = RV5(K)
     IND(L) = TAG
     K = K + 1
     GO TO 920

915  CONTINUE

     J = J + 1

920  CONTINUE

  END DO

940 CONTINUE

  IF ( Q < N ) THEN
    GO TO 100
  END IF

  GO TO 1001
!
!  SET ERROR: INTERVAL CANNOT BE FOUND CONTAINING EXACTLY THE
!  DESIRED EIGENVALUES.
!
980 CONTINUE

  IERR = 3 * N + ISTURM

1001 CONTINUE

  LB = T1
  UB = T2
  RETURN
END
SUBROUTINE TSTURM ( N, EPS1, D, E, E2, LB, UB, MM, M, W, Z, IERR )

!*****************************************************************************80
!
!! TSTURM COMPUTES SOME EIGENVALUES/VECTORS, REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THOSE EIGENVALUES OF A TRIDIAGONAL
!    SYMMETRIC MATRIX WHICH LIE IN A SPECIFIED INTERVAL AND THEIR
!    ASSOCIATED EIGENVECTORS, USING BISECTION AND INVERSE ITERATION.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) EPS1.  ON INPUT, AN ABSOLUTE ERROR
!    TOLERANCE FOR THE COMPUTED EIGENVALUES.  IT SHOULD BE CHOSEN COMMENSURATE
!    WITH RELATIVE PERTURBATIONS IN THE MATRIX ELEMENTS OF THE ORDER OF THE
!    RELATIVE MACHINE PRECISION.  IF THE INPUT EPS1 IS NON-POSITIVE, IT
!    IS RESET FOR EACH SUBMATRIX TO A DEFAULT VALUE, NAMELY, MINUS THE
!    PRODUCT OF THE RELATIVE MACHINE PRECISION AND THE 1-NORM OF THE SUBMATRIX.
!
!    INPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE INPUT MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) E(N), THE SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX
!    IN E(2:N).  E(1) IS ARBITRARY.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N).  ON INPUT, THE SQUARES OF THE
!    CORRESPONDING ELEMENTS OF E.  E2(1) IS ARBITRARY.  ON OUTPUT, ELEMENTS OF
!    E2 CORRESPONDING TO ELEMENTS OF E REGARDED AS NEGLIGIBLE HAVE BEEN
!    REPLACED BY ZERO, CAUSING THE MATRIX TO SPLIT INTO A DIRECT SUM OF
!    SUBMATRICES.  E2(1) IS ALSO SET TO ZERO.
!
!    INPUT, REAL ( KIND = 8 ) LB, UB, DEFINE THE INTERVAL TO BE SEARCHED FOR
!    EIGENVALUES.  IF LB IS NOT LESS THAN UB, NO EIGENVALUES WILL BE FOUND.
!
!    INPUT, INTEGER ( KIND = 4 ) MM, AN UPPER BOUND FOR THE NUMBER OF
!    EIGENVALUES IN THE INTERVAL.  IF MORE THAN MM EIGENVALUES ARE DETERMINED
!    TO LIE IN THE INTERVAL, AN ERROR RETURN IS MADE WITH NO VALUES OR VECTORS
!    FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVALUES DETERMINED TO LIE
!    IN (LB, UB).
!
!    OUTPUT, REAL ( KIND = 8 ) W(M), THE EIGENVALUES IN ASCENDING ORDER IF THE
!    MATRIX DOES NOT SPLIT.  IF THE MATRIX SPLITS, THE EIGENVALUES ARE IN
!    ASCENDING ORDER FOR EACH SUBMATRIX.  IF A VECTOR ERROR EXIT IS MADE, W
!    CONTAINS THOSE VALUES ALREADY FOUND.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,MM), THE ASSOCIATED SET OF ORTHONORMAL
!    EIGENVECTORS.  IF AN ERROR EXIT IS MADE, Z CONTAINS THOSE VECTORS ALREADY
!    FOUND.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NORMAL RETURN.
!    3*N+1, IF M EXCEEDS MM.
!    4*N+R, IF THE EIGENVECTOR CORRESPONDING TO THE R-TH
!      EIGENVALUE FAILS TO CONVERGE IN 5 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) MM
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) EPS1
  REAL    ( KIND = 8 ) EPS2
  REAL    ( KIND = 8 ) EPS3
  REAL    ( KIND = 8 ) EPS4
  INTEGER ( KIND = 4 ) GROUP
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) IP
  INTEGER ( KIND = 4 ) ISTURM
  INTEGER ( KIND = 4 ) ITS
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) JJ
  INTEGER ( KIND = 4 ) K
  REAL    ( KIND = 8 ) LB
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) M1
  INTEGER ( KIND = 4 ) M2
  REAL    ( KIND = 8 ) NORM
  INTEGER ( KIND = 4 ) P
  REAL    ( KIND = 8 ) PYTHAG
  INTEGER ( KIND = 4 ) Q
  INTEGER ( KIND = 4 ) R
  REAL    ( KIND = 8 ) RV1(N)
  REAL    ( KIND = 8 ) RV2(N)
  REAL    ( KIND = 8 ) RV3(N)
  REAL    ( KIND = 8 ) RV4(N)
  REAL    ( KIND = 8 ) RV5(N)
  REAL    ( KIND = 8 ) RV6(N)
  INTEGER ( KIND = 4 ) S
  REAL    ( KIND = 8 ) T1
  REAL    ( KIND = 8 ) T2
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) U
  REAL    ( KIND = 8 ) UB
  REAL    ( KIND = 8 ) UK
  REAL    ( KIND = 8 ) V
  REAL    ( KIND = 8 ) W(MM)
  REAL    ( KIND = 8 ) X0
  REAL    ( KIND = 8 ) X1
  REAL    ( KIND = 8 ) XU
  REAL    ( KIND = 8 ) Z(N,MM)

  IERR = 0
  S = 0
  T1 = LB
  T2 = UB
!
!  LOOK FOR SMALL SUB-DIAGONAL ENTRIES.
!
  E2(1) = 0.0D+00

  DO I = 2, N

    TST1 = ABS ( D(I) ) + ABS ( D(I-1) )
    TST2 = TST1 + ABS ( E(I) )

    IF ( TST2 <= TST1 ) THEN
      E2(I) = 0.0D+00
    END IF

  END DO
!
!  DETERMINE THE NUMBER OF EIGENVALUES IN THE INTERVAL.
!
  P = 1
  Q = N
  X1 = UB
  ISTURM = 1
  GO TO 320

60 CONTINUE

  M = S
  X1 = LB
  ISTURM = 2
  GO TO 320

80 CONTINUE

  M = M - S

  IF ( M > MM ) GO TO 980

  Q = 0
  R = 0
!
!  ESTABLISH AND PROCESS NEXT SUBMATRIX, REFINING INTERVAL BY THE
!  GERSCHGORIN BOUNDS.
!
100 CONTINUE

  IF ( R == M ) GO TO 1001

  P = Q + 1
  XU = D(P)
  X0 = D(P)
  U = 0.0D+00

  DO Q = P, N

     X1 = U
     U = 0.0D+00
     V = 0.0D+00

     IF ( Q /= N ) THEN
       U = ABS ( E(Q+1) )
       V = E2(Q+1)
     END IF

     XU = MIN ( D(Q)-(X1+U), XU )
     X0 = MAX ( D(Q)+(X1+U), X0 )

     IF ( V == 0.0D+00 ) THEN
       EXIT
     END IF

  END DO

  X1 = MAX ( ABS ( XU ), ABS ( X0 ) ) * EPSILON ( X1 )

  IF ( EPS1 <= 0.0D+00 ) THEN
    EPS1 = -X1
  END IF

  IF ( P /= Q ) GO TO 180
!
!  CHECK FOR ISOLATED ROOT WITHIN INTERVAL.
!
  IF ( T1 > D(P) .OR. D(P) >= T2 ) GO TO 940

  R = R + 1

  Z(1:N,R) = 0.0D+00

  W(R) = D(P)
  Z(P,R) = 1.0D+00
  GO TO 940

180 CONTINUE

  U = Q - P + 1
  X1 = U * X1
  LB = MAX ( T1, XU-X1 )
  UB = MIN ( T2, X0+X1 )
  X1 = LB
  ISTURM = 3
  GO TO 320

200 CONTINUE

  M1 = S + 1
  X1 = UB
  ISTURM = 4
  GO TO 320

220 CONTINUE

  M2 = S
  IF ( M1 > M2 ) GO TO 940
!
!  FIND ROOTS BY BISECTION.
!
  X0 = UB
  ISTURM = 5

  RV5(M1:M2) = UB
  RV4(M1:M2) = LB
!
!  LOOP FOR K-TH EIGENVALUE.
!
  K = M2

250 CONTINUE

  XU = LB

  DO II = M1, K

    I = M1 + K - II

    IF ( XU < RV4(I) ) THEN
      XU = RV4(I)
      EXIT
    END IF

  END DO

280 CONTINUE

  IF ( X0 > RV5(K) ) X0 = RV5(K)
!
!  NEXT BISECTION STEP.
!
300 CONTINUE

     X1 = ( XU + X0 ) * 0.5D+00
     IF ( ( X0 - XU ) <= ABS ( EPS1 ) ) GO TO 420
     TST1 = 2.0D+00 * ( ABS ( XU ) + ABS ( X0 ) )
     TST2 = TST1 + (X0 - XU)
     IF ( TST2 == TST1 ) GO TO 420
!
!  STURM SEQUENCE.
!
320  CONTINUE

     S = P - 1
     U = 1.0D+00

     DO I = P, Q

        IF ( U /= 0.0D+00 ) GO TO 325
        V = ABS ( E(I) ) / EPSILON ( V )
        IF ( E2(I) == 0.0D+00 ) V = 0.0D+00
        GO TO 330

325     CONTINUE

        V = E2(I) / U
330     CONTINUE

        U = D(I) - X1 - V
        IF ( U < 0.0D+00 ) S = S + 1

     END DO

     GO TO ( 60,80,200,220,360 ), ISTURM
!
!  REFINE INTERVALS.
!
360  CONTINUE

     IF ( S >= K ) GO TO 400
     XU = X1
     IF ( S >= M1 ) GO TO 380
     RV4(M1) = X1
     GO TO 300

380  CONTINUE

     RV4(S+1) = X1
     IF ( RV5(S) > X1 ) THEN
       RV5(S) = X1
     END IF
     GO TO 300

400  CONTINUE

     X0 = X1
     GO TO 300
!
!  K-TH EIGENVALUE FOUND.
!
420  CONTINUE

  RV5(K) = X1
  K = K - 1
  IF ( K >= M1 ) GO TO 250
!
!  FIND VECTORS BY INVERSE ITERATION.
!
  NORM = ABS ( D(P) )
  IP = P + 1

  DO I = IP, Q
    NORM = MAX ( NORM, ABS ( D(I) ) + ABS ( E(I) ) )
  END DO
!
!  EPS2 IS THE CRITERION FOR GROUPING,
!  EPS3 REPLACES ZERO PIVOTS AND EQUAL ROOTS ARE MODIFIED BY EPS3,
!  EPS4 IS TAKEN VERY SMALL TO AVOID OVERFLOW.
!
  EPS2 = 0.001D+00 * NORM
  EPS3 = ABS ( NORM ) * EPSILON ( EPS3 )
  UK = Q - P + 1
  EPS4 = UK * EPS3
  UK = EPS4 / SQRT ( UK )
  GROUP = 0
  S = P

  DO K = M1, M2

     R = R + 1
     ITS = 1
     W(R) = RV5(K)
     X1 = RV5(K)
!
!  LOOK FOR CLOSE OR COINCIDENT ROOTS.
!
     IF ( K /= M1 ) THEN
       IF ( X1 - X0 >= EPS2 ) GROUP = -1
       GROUP = GROUP + 1
       IF ( X1 <= X0 ) THEN
         X1 = X0 + EPS3
       END IF
     END IF
!
!  ELIMINATION WITH INTERCHANGES AND INITIALIZATION OF VECTOR.
!
520  CONTINUE

     V = 0.0D+00

     DO I = P, Q

        RV6(I) = UK

        IF ( I == P ) GO TO 560

        IF ( ABS ( E(I) ) >= ABS ( U ) ) THEN
          XU = U / E(I)
          RV4(I) = XU
          RV1(I-1) = E(I)
          RV2(I-1) = D(I) - X1
          RV3(I-1) = 0.0D+00
          IF ( I /= Q ) RV3(I-1) = E(I+1)
          U = V - XU * RV2(I-1)
          V = -XU * RV3(I-1)
          CYCLE
        END IF

540     CONTINUE

        XU = E(I) / U
        RV4(I) = XU
        RV1(I-1) = U
        RV2(I-1) = V
        RV3(I-1) = 0.0D+00

560     CONTINUE

        U = D(I) - X1 - XU * V

        IF ( I /= Q ) THEN
          V = E(I+1)
        END IF

     END DO

     IF ( U == 0.0D+00 ) U = EPS3
     RV1(Q) = U
     RV2(Q) = 0.0D+00
     RV3(Q) = 0.0D+00
!
!  BACK SUBSTITUTION.
!
600  CONTINUE

     DO II = P, Q
        I = P + Q - II
        RV6(I) = ( RV6(I) - U * RV2(I) - V * RV3(I) ) / RV1(I)
        V = U
        U = RV6(I)
     END DO
!
!  ORTHOGONALIZE WITH RESPECT TO PREVIOUS MEMBERS OF GROUP.
!
     DO JJ = 1, GROUP
        J = R - GROUP - 1 + JJ
        XU = DOT_PRODUCT ( RV6(P:Q), Z(P:Q,J) )
        RV6(P:Q) = RV6(P:Q) - XU * Z(P:Q,J)
     END DO

700  CONTINUE

     NORM = SUM ( ABS ( RV6(P:Q) ) )

     IF ( NORM >= 1.0D+00 ) THEN
       GO TO 840
     END IF
!
!  FORWARD SUBSTITUTION.
!
     IF ( ITS == 5 ) THEN
       IERR = 4 * N + R
       GO TO 1001
     END IF

     IF ( NORM == 0.0D+00 ) THEN
       RV6(S) = EPS4
       S = S + 1
       IF ( S > Q ) THEN
         S = P
       END IF
       GO TO 780
     END IF

740  CONTINUE

    XU = EPS4 / NORM

     RV6(P:Q) = RV6(P:Q) * XU
!
!  ELIMINATION OPERATIONS ON NEXT VECTOR ITERATE.
!
780    CONTINUE
!
!  IF RV1(I-1) == E(I), A ROW INTERCHANGE WAS PERFORMED EARLIER IN THE
!  TRIANGULARIZATION PROCESS.
!
     DO I = P, Q

       U = RV6(I)

       IF ( RV1(I-1) == E(I) ) THEN
         U = RV6(I-1)
         RV6(I-1) = RV6(I)
       END IF

       RV6(I) = U - RV4(I) * RV6(I-1)

     END DO

     ITS = ITS + 1
     GO TO 600
!
!  NORMALIZE SO THAT SUM OF SQUARES IS 1 AND EXPAND TO FULL ORDER.
!
840  CONTINUE

     U = 0.0D+00

     DO I = P, Q
       U = PYTHAG ( U, RV6(I) )
     END DO

     XU = 1.0D+00 / U

     Z(1:N,R) = 0.0D+00
     Z(P:Q,R) = RV6(P:Q) * XU

     X0 = X1

  END DO

940 CONTINUE

  IF ( Q < N ) THEN
    GO TO 100
  END IF

  GO TO 1001
!
!  SET ERROR: UNDERESTIMATE OF NUMBER OF EIGENVALUES IN INTERVAL.
!
980 CONTINUE

  IERR = 3 * N + 1

1001 CONTINUE

  LB = T1
  UB = T2

  RETURN
END

END MODULE EISPACK