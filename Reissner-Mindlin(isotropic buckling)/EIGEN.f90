MODULE EIGEN

	IMPLICIT NONE
	
CONTAINS

SUBROUTINE RSG ( N, A, B, W, MATZ, Z, IERR )

!*****************************************************************************80
!
!! RSG COMPUTES EIGENVALUES/VECTORS, A*X=LAMBDA*B*X, A SYMMETRIC, B POS-DEF.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE CALLS THE RECOMMENDED SEQUENCE OF
!    SUBROUTINES FROM THE EIGENSYSTEM SUBROUTINE PACKAGE (EISPACK)
!    TO FIND THE EIGENVALUES AND EIGENVECTORS (IF DESIRED)
!    FOR THE REAL SYMMETRIC GENERALIZED EIGENPROBLEM  AX = (LAMBDA)BX.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  MODIFIED:
!
!    04 FEBRUARY 2003
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), CONTAINS A REAL SYMMETRIC MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), CONTAINS A POSITIVE DEFINITE REAL
!    SYMMETRIC MATRIX.
!
!    INPUT, INTEGER ( KIND = 4 ) MATZ, IS ZERO IF ONLY EIGENVALUES ARE DESIRED, AND
!    NONZERO IF BOTH EIGENVALUES AND EIGENVECTORS ARE DESIRED.
!
!    OUTPUT, REAL ( KIND = 8 ) W(N), THE EIGENVALUES IN ASCENDING ORDER.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), CONTAINS THE EIGENVECTORS, IF MATZ
!    IS NONZERO.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, IS SET TO AN ERROR
!    COMPLETION CODE DESCRIBED IN THE DOCUMENTATION FOR TQLRAT AND TQL2.
!    THE NORMAL COMPLETION CODE IS ZERO.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) FV1(N)
  REAL    ( KIND = 8 ) FV2(N)
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) MATZ
  REAL    ( KIND = 8 ) W(N)
  REAL    ( KIND = 8 ) Z(N,N)

  CALL REDUC ( N, A, B, FV2, IERR )

  IF ( IERR /= 0 ) THEN
    WRITE ( *, '(A)' ) ' '
    WRITE ( *, '(A)' ) 'RSG - FATAL ERROR!'
    WRITE ( *, '(A)' ) '  ERROR RETURN FROM REDUC.'
    RETURN
  END IF

  IF ( MATZ == 0 ) THEN

    CALL TRED1 ( N, A, W, FV1, FV2 )

    CALL TQLRAT ( N, W, FV2, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSG - WARNING!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TQLRAT!'
      RETURN
    END IF

  ELSE

    CALL TRED2 ( N, A, W, FV1, Z )

    CALL TQL2 ( N, W, FV1, Z, IERR )

    IF ( IERR /= 0 ) THEN
      WRITE ( *, '(A)' ) ' '
      WRITE ( *, '(A)' ) 'RSG - FATAL ERROR!'
      WRITE ( *, '(A)' ) '  ERROR RETURN FROM TQL2!'
      RETURN
    END IF

    CALL REBAK ( N, B, FV2, N, Z )

  END IF

  RETURN
END SUBROUTINE RSG

SUBROUTINE REDUC ( N, A, B, DL, IERR )

!*****************************************************************************80
!
!! REDUC REDUCES THE EIGENVALUE PROBLEM A*X=LAMBDA*B*X TO A*X=LAMBDA*X.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES THE GENERALIZED SYMMETRIC EIGENPROBLEM
!    AX=(LAMBDA)BX, WHERE B IS POSITIVE DEFINITE, TO THE STANDARD
!    SYMMETRIC EIGENPROBLEM USING THE CHOLESKY FACTORIZATION OF B.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRICES A AND B.  IF THE
!    CHOLESKY FACTOR L OF B IS ALREADY AVAILABLE, N SHOULD BE PREFIXED WITH A
!    MINUS SIGN.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N).  ON INPUT, A CONTAINS A REAL
!    SYMMETRIC MATRIX.  ONLY THE FULL UPPER TRIANGLE OF THE MATRIX NEED BE
!    SUPPLIED.  ON OUTPUT, A CONTAINS IN ITS FULL LOWER TRIANGLE THE FULL LOWER
!    TRIANGLE OF THE SYMMETRIC MATRIX DERIVED FROM THE REDUCTION TO THE
!    STANDARD FORM.  THE STRICT UPPER TRIANGLE OF A IS UNALTERED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) B(N,N).  ON INPUT, THE REAL SYMMETRIC
!    INPUT MATRIX.  ONLY THE FULL UPPER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!    IF N IS NEGATIVE, THE STRICT LOWER TRIANGLE OF B CONTAINS, INSTEAD, THE
!    STRICT LOWER TRIANGLE OF ITS CHOLESKY FACTOR L.  IN ANY CASE, ON OUTPUT,
!    B CONTAINS IN ITS STRICT LOWER TRIANGLE THE STRICT LOWER TRIANGLE OF
!    ITS CHOLESKY FACTOR L.  THE FULL UPPER TRIANGLE OF B IS UNALTERED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) DL(N).  IF N IS NEGATIVE, THEN THE DL
!    CONTAINS THE DIAGONAL ELEMENTS OF L ON INPUT.  IN ANY CASE, DL WILL CONTAIN
!    THE DIAGONAL ELEMENTS OF L ON OUTPUT,
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NORMAL RETURN,
!    7*N+1, IF B IS NOT POSITIVE DEFINITE.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) DL(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) NN
  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y

  IERR = 0
  NN = N
!
!  FORM L IN THE ARRAYS B AND DL.
!
  DO I = 1, N

     DO J = I, N

        X = B(I,J)

        DO K = 1, I - 1
          X = X - B(I,K) * B(J,K)
        END DO

        IF ( J == I ) THEN

          IF ( X <= 0.0D+00 ) THEN
            WRITE ( *, '(A)' ) ' '
            WRITE ( *, '(A)' ) 'REDUC - FATAL ERROR!'
            WRITE ( *, '(A)' ) '  THE MATRIX IS NOT POSITIVE DEFINITE.'
            IERR = 7 * N + 1
            RETURN
          END IF

          Y = DSQRT ( X )
          DL(I) = Y
        ELSE
          B(J,I) = X / Y
        END IF

    END DO

  END DO
!
!  FORM THE TRANSPOSE OF THE UPPER TRIANGLE OF INV(L)*A
!  IN THE LOWER TRIANGLE OF THE ARRAY A.
!
  DO I = 1, NN

     Y = DL(I)

     DO J = I, NN

        X = A(I,J)

        DO K = 1, I - 1
          X = X - B(I,K) * A(J,K)
        END DO

        A(J,I) = X / Y

      END DO

  END DO
!
!  PRE-MULTIPLY BY INV(L) AND OVERWRITE.
!
  DO J = 1, NN

     DO I = J, NN

        X = A(I,J)

        DO K = J, I-1
          X = X - A(K,J) * B(I,K)
        END DO

        DO K = 1, J-1
          X = X - A(J,K) * B(I,K)
        END DO

        A(I,J) = X / DL(I)

    END DO

  END DO

  RETURN
END SUBROUTINE REDUC

SUBROUTINE TRED1 ( N, A, D, E, E2 )

!*****************************************************************************80
!
!! TRED1 TRANSFORMS A REAL SYMMETRIC MATRIX TO SYMMETRIC TRIDIAGONAL FORM.
!
!  DISCUSSION:
!
!    THE ROUTINE REDUCES A REAL SYMMETRIC MATRIX TO A SYMMETRIC
!    TRIDIAGONAL MATRIX USING ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN, REINSCH, WILKINSON,
!    TRED1,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 181-195, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX A.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) A(N,N), ON INPUT, CONTAINS THE REAL
!    SYMMETRIC MATRIX.  ONLY THE LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!    ON OUTPUT, A CONTAINS INFORMATION ABOUT THE ORTHOGONAL TRANSFORMATIONS
!    USED IN THE REDUCTION IN ITS STRICT LOWER TRIANGLE.
!    THE FULL UPPER TRIANGLE OF A IS UNALTERED.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), CONTAINS THE DIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX IN ITS LAST N-1 POSITIONS.  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) E2(N), CONTAINS THE SQUARES OF THE CORRESPONDING
!    ELEMENTS OF E.  E2 MAY COINCIDE WITH E IF THE SQUARES ARE NOT NEEDED.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) SCALE

  D(1:N) = A(N,1:N)

  DO I = 1, N
    A(N,I) = A(I,I)
  END DO

  DO II = 1, N

    I = N + 1 - II
    L = I - 1
    H = 0.0D+00
!
!  SCALE ROW.
!
    SCALE = SUM ( DABS ( D(1:L) ) )

    IF ( SCALE == 0.0D+00 ) THEN

      DO J = 1, L
        D(J) = A(L,J)
        A(L,J) = A(I,J)
        A(I,J) = 0.0D+00
      END DO

      E(I) = 0.0D+00
      E2(I) = 0.0D+00

      CYCLE

    END IF

    D(1:L) = D(1:L) / SCALE

    DO K = 1, L
      H = H + D(K)**2
    END DO

    E2(I) = H * SCALE**2
    F = D(L)
    G = - SIGN ( DSQRT ( H ), F )
    E(I) = SCALE * G
    H = H - F * G
    D(L) = F - G

    IF ( L >= 1 ) THEN
!
!  FORM A * U.
!
      E(1:L) = 0.0D+00

      DO J = 1, L

        F = D(J)
        G = E(J) + A(J,J) * F

        DO K = J+1, L
          G = G + A(K,J) * D(K)
          E(K) = E(K) + A(K,J) * F
        END DO

        E(J) = G

      END DO
!
!  FORM P.
!
      F = 0.0D+00

      DO J = 1, L
        E(J) = E(J) / H
        F = F + E(J) * D(J)
      END DO

      H = F / ( H + H )
!
!  FORM Q.
!
      E(1:L) = E(1:L) - H * D(1:L)
!
!  FORM REDUCED A.
!
      DO J = 1, L

        F = D(J)
        G = E(J)

        A(J:L,J) = A(J:L,J) - F * E(J:L) - G * D(J:L)

      END DO

    END IF

    DO J = 1, L
      F = D(J)
      D(J) = A(L,J)
      A(L,J) = A(I,J)
      A(I,J) = F * SCALE
    END DO


  END DO

  RETURN
END SUBROUTINE TRED1 

SUBROUTINE TRED2 ( N, A, D, E, Z )

!*****************************************************************************80
!
!! TRED2 TRANSFORMS A REAL SYMMETRIC MATRIX TO SYMMETRIC TRIDIAGONAL FORM.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE REDUCES A REAL SYMMETRIC MATRIX TO A
!    SYMMETRIC TRIDIAGONAL MATRIX USING AND ACCUMULATING
!    ORTHOGONAL SIMILARITY TRANSFORMATIONS.
!
!    A AND Z MAY COINCIDE, IN WHICH CASE A SINGLE STORAGE AREA IS USED
!    FOR THE INPUT OF A AND THE OUTPUT OF Z.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    MARTIN, REINSCH, WILKINSON,
!    TRED2,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 181-195, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) A(N,N), THE REAL SYMMETRIC INPUT MATRIX.  ONLY THE
!    LOWER TRIANGLE OF THE MATRIX NEED BE SUPPLIED.
!
!    OUTPUT, REAL ( KIND = 8 ) D(N), THE DIAGONAL ELEMENTS OF THE TRIDIAGONAL
!    MATRIX.
!
!    OUTPUT, REAL ( KIND = 8 ) E(N), CONTAINS THE SUBDIAGONAL ELEMENTS OF THE
!    TRIDIAGONAL MATRIX IN E(2:N).  E(1) IS SET TO ZERO.
!
!    OUTPUT, REAL ( KIND = 8 ) Z(N,N), THE ORTHOGONAL TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) A(N,N)
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  REAL    ( KIND = 8 ) HH
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  REAL    ( KIND = 8 ) SCALE
  REAL    ( KIND = 8 ) Z(N,N)

  DO I = 1, N
    Z(I:N,I) = A(I:N,I)
  END DO

  D(1:N) = A(N,1:N)

  DO II = 2, N

    I = N + 2 - II
    L = I - 1
    H = 0.0D+00
    SCALE = 0.0D+00
!
!  SCALE ROW.
!
    DO K = 1, L
      SCALE = SCALE + DABS ( D(K) )
    END DO

    IF ( SCALE == 0.0D+00 ) THEN

      E(I) = D(L)

      DO J = 1, L
        D(J) = Z(L,J)
        Z(I,J) = 0.0D+00
        Z(J,I) = 0.0D+00
      END DO

      GO TO 290

    END IF

    D(1:L) = D(1:L) / SCALE

    H = H + DOT_PRODUCT ( D(1:L), D(1:L) )

    F = D(L)
    G = - SIGN ( DSQRT ( H ), F )
    E(I) = SCALE * G
    H = H - F * G
    D(L) = F - G
!
!  FORM A*U.
!
    E(1:L) = 0.0D+00

    DO J = 1, L

      F = D(J)
      Z(J,I) = F
      G = E(J) + Z(J,J) * F

      DO K = J+1, L
        G = G + Z(K,J) * D(K)
        E(K) = E(K) + Z(K,J) * F
      END DO

      E(J) = G

    END DO
!
!  FORM P.
!
    E(1:L) = E(1:L) / H

    F = DOT_PRODUCT ( E(1:L), D(1:L) )

    HH = 0.5D+00 * F / H
!
!  FORM Q.
!
    E(1:L) = E(1:L) - HH * D(1:L)
!
!  FORM REDUCED A.
!
    DO J = 1, L

      F = D(J)
      G = E(J)

      Z(J:L,J) = Z(J:L,J) - F * E(J:L) - G * D(J:L)

      D(J) = Z(L,J)
      Z(I,J) = 0.0D+00

    END DO

290 CONTINUE

    D(I) = H


  END DO
!
!  ACCUMULATION OF TRANSFORMATION MATRICES.
!
  DO I = 2, N

    L = I - 1
    Z(N,L) = Z(L,L)
    Z(L,L) = 1.0D+00
    H = D(I)
    IF ( H /= 0.0D+00 ) THEN

      D(1:L) = Z(1:L,I) / H

      DO J = 1, L

        G = DOT_PRODUCT ( Z(1:L,I), Z(1:L,J) )

        DO K = 1, L
          Z(K,J) = Z(K,J) - G * D(K)
        END DO

      END DO

    END IF

    Z(1:L,I) = 0.0D+00

  END DO

  D(1:N) = Z(N,1:N)

  Z(N,1:N-1) = 0.0D+00
  Z(N,N) = 1.0D+00

  E(1) = 0.0D+00

  RETURN
END SUBROUTINE TRED2

SUBROUTINE TQL2 ( N, D, E, Z, IERR )

!*****************************************************************************80
!
!! TQL2 COMPUTES ALL EIGENVALUES/VECTORS, REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES AND EIGENVECTORS OF A SYMMETRIC
!    TRIDIAGONAL MATRIX BY THE QL METHOD.  THE EIGENVECTORS OF A FULL
!    SYMMETRIC MATRIX CAN ALSO BE FOUND IF TRED2 HAS BEEN USED TO REDUCE THIS
!    FULL MATRIX TO TRIDIAGONAL FORM.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    BOWDLER, MARTIN, REINSCH, WILKINSON,
!    TQL2,
!    NUMERISCHE MATHEMATIK,
!    VOLUME 11, PAGES 293-306, 1968.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).  ON INPUT, THE DIAGONAL ELEMENTS OF
!    THE MATRIX.  ON OUTPUT, THE EIGENVALUES IN ASCENDING ORDER.  IF AN ERROR
!    EXIT IS MADE, THE EIGENVALUES ARE CORRECT BUT UNORDERED FOR INDICES
!    1,2,...,IERR-1.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E(N).  ON INPUT, E(2:N) CONTAINS THE
!    SUBDIAGONAL ELEMENTS OF THE INPUT MATRIX, AND E(1) IS ARBITRARY.
!    ON OUTPUT, E HAS BEEN DESTROYED.
!
!    INPUT, REAL ( KIND = 8 ) Z(N,N).  ON INPUT, THE TRANSFORMATION MATRIX
!    PRODUCED IN THE REDUCTION BY TRED2, IF PERFORMED.  IF THE EIGENVECTORS OF
!    THE TRIDIAGONAL MATRIX ARE DESIRED, Z MUST CONTAIN THE IDENTITY MATRIX.
!    ON OUTPUT, Z CONTAINS THE ORTHONORMAL EIGENVECTORS OF THE SYMMETRIC
!    TRIDIAGONAL (OR FULL) MATRIX.  IF AN ERROR EXIT IS MADE, Z CONTAINS
!    THE EIGENVECTORS ASSOCIATED WITH THE STORED EIGENVALUES.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, NORMAL RETURN,
!    J, IF THE J-TH EIGENVALUE HAS NOT BEEN DETERMINED AFTER
!    30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) C2
  REAL    ( KIND = 8 ) C3
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) DL1
  REAL    ( KIND = 8 ) E(N)
  REAL    ( KIND = 8 ) EL1
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) K
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) L2
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) S2
  REAL    ( KIND = 8 ) TST1
  REAL    ( KIND = 8 ) TST2
  REAL    ( KIND = 8 ) Z(N,N)

  IERR = 0

  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E(I-1) = E(I)
  END DO

  F = 0.0D+00
  TST1 = 0.0D+00
  E(N) = 0.0D+00

  DO L = 1, N

     J = 0
     H = DABS ( D(L) ) + DABS ( E(L) )
     TST1 = MAX ( TST1, H )
!
!  LOOK FOR A SMALL SUB-DIAGONAL ELEMENT.
!
     DO M = L, N
       TST2 = TST1 + DABS ( E(M) )
       IF ( TST2 == TST1 ) THEN
         EXIT
       END IF
     END DO

     IF ( M == L ) THEN
       GO TO 220
     END IF

 130 CONTINUE

     IF ( 30 <= J ) THEN
       IERR = L
       RETURN
     END IF

     J = J + 1
!
!  FORM SHIFT.
!
     L1 = L + 1
     L2 = L1 + 1
     G = D(L)
     P = ( D(L1) - G ) / ( 2.0D+00 * E(L) )
     R = PYTHAG( P, 1.0D+00 )
     D(L) = E(L) / ( P + SIGN ( R, P ) )
     D(L1) = E(L) * ( P + SIGN ( R, P ) )
     DL1 = D(L1)
     H = G - D(L)
     D(L2:N) = D(L2:N) - H
     F = F + H
!
!  QL TRANSFORMATION.
!
     P = D(M)
     C = 1.0D+00
     C2 = C
     EL1 = E(L1)
     S = 0.0D+00
     MML = M - L

     DO II = 1, MML

        C3 = C2
        C2 = C
        S2 = S
        I = M - II
        G = C * E(I)
        H = C * P
        R = PYTHAG( P, E(I) )
        E(I+1) = S * R
        S = E(I) / R
        C = P / R
        P = C * D(I) - S * G
        D(I+1) = H + S * ( C * G + S * D(I) )
!
!  FORM VECTOR.
!
        DO K = 1, N
          H = Z(K,I+1)
          Z(K,I+1) = S * Z(K,I) + C * H
          Z(K,I) = C * Z(K,I) - S * H
        END DO

     END DO

     P = - S * S2 * C3 * EL1 * E(L) / DL1
     E(L) = S * P
     D(L) = C * P
     TST2 = TST1 + DABS ( E(L) )

     IF ( TST2 > TST1 ) THEN
       GO TO 130
     END IF

220  CONTINUE

     D(L) = D(L) + F

  END DO
!
!  ORDER EIGENVALUES AND EIGENVECTORS.
!
  DO II = 2, N

    I = II - 1
    K = I
    P = D(I)

    DO J = II, N

      IF ( D(J) < P ) THEN
        K = J
        P = D(J)
      END IF

    END DO

    IF ( K /= I ) THEN

      D(K) = D(I)
      D(I) = P

      DO J = 1, N
        CALL R8_SWAP ( Z(J,I), Z(J,K) )
      END DO

    END IF

  END DO

  RETURN
END SUBROUTINE TQL2

SUBROUTINE TQLRAT ( N, D, E2, IERR )

!*****************************************************************************80
!
!! TQLRAT COMPUTES ALL EIGENVALUES OF A REAL SYMMETRIC TRIDIAGONAL MATRIX.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FINDS THE EIGENVALUES OF A SYMMETRIC
!    TRIDIAGONAL MATRIX BY THE RATIONAL QL METHOD.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    C REINSCH,
!    ALGORITHM 464, TQLRAT,
!    COMMUNICATIONS OF THE ACM,
!    VOLUME 16, PAGE 689, 1973.
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) D(N).  ON INPUT, D CONTAINS THE DIAGONAL
!    ELEMENTS OF THE MATRIX.  ON OUTPUT, D CONTAINS THE EIGENVALUES IN ASCENDING
!    ORDER.  IF AN ERROR EXIT WAS MADE, THEN THE EIGENVALUES ARE CORRECT
!    IN POSITIONS 1 THROUGH IERR-1, BUT MAY NOT BE THE SMALLEST EIGENVALUES.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) E2(N), CONTAINS IN POSITIONS 2 THROUGH N THE
!    SQUARES OF THE SUBDIAGONAL ELEMENTS OF THE MATRIX.  E2(1) IS
!    ARBITRARY.  ON OUTPUT, E2 HAS BEEN OVERWRITTEN BY WORKSPACE
!    INFORMATION.
!
!    OUTPUT, INTEGER ( KIND = 4 ) IERR, ERROR FLAG.
!    0, FOR NO ERROR,
!    J, IF THE J-TH EIGENVALUE COULD NOT BE DETERMINED AFTER 30 ITERATIONS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) C
  REAL    ( KIND = 8 ) D(N)
  REAL    ( KIND = 8 ) E2(N)
  REAL    ( KIND = 8 ) F
  REAL    ( KIND = 8 ) G
  REAL    ( KIND = 8 ) H
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) IERR
  INTEGER ( KIND = 4 ) II
  INTEGER ( KIND = 4 ) J
  INTEGER ( KIND = 4 ) L
  INTEGER ( KIND = 4 ) L1
  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) MML
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T

  IERR = 0

  IF ( N == 1 ) THEN
    RETURN
  END IF

  DO I = 2, N
    E2(I-1) = E2(I)
  END DO

  F = 0.0D+00
  T = 0.0D+00
  E2(N) = 0.0D+00

  DO L = 1, N

     J = 0
     H = DABS ( D(L) ) + DSQRT ( E2(L) )

     IF ( T <= H ) THEN

       T = H
       B = DABS ( T ) * EPSILON ( B )
       C = B * B

     END IF
!
!  LOOK FOR SMALL SQUARED SUB-DIAGONAL ELEMENT.
!
     DO M = L, N
       IF ( E2(M) <= C ) THEN
         EXIT
       END IF
     END DO

     IF ( M == L ) GO TO 210

130  CONTINUE

     IF ( J >= 30 ) THEN
       IERR = L
       RETURN
     END IF

     J = J + 1
!
!  FORM SHIFT.
!
     L1 = L + 1
     S = DSQRT ( E2(L) )
     G = D(L)
     P = ( D(L1) - G ) / ( 2.0D+00 * S )
     R = PYTHAG( P, 1.0D+00 )
     D(L) = S / ( P + SIGN ( R, P ) )
     H = G - D(L)
     D(L1:N) = D(L1:N) - H
     F = F + H
!
!  RATIONAL QL TRANSFORMATION.
!
     G = D(M)
     IF ( G == 0.0D+00 ) G = B
     H = G
     S = 0.0D+00
     MML = M - L

     DO II = 1, MML
       I = M - II
       P = G * H
       R = P + E2(I)
       E2(I+1) = S * R
       S = E2(I) / R
       D(I+1) = H + S * ( H + D(I) )
       G = D(I) - E2(I) / G
       IF ( G == 0.0D+00 ) G = B
       H = G * P / R
     END DO

     E2(L) = S * G
     D(L) = H
!
!  GUARD AGAINST UNDERFLOW IN CONVERGENCE TEST.
!
     IF ( H == 0.0D+00 ) GO TO 210
     IF ( DABS ( E2(L) ) <= DABS ( C / H ) ) GO TO 210
     E2(L) = H * E2(L)
     IF ( E2(L) /= 0.0D+00 ) GO TO 130

210  CONTINUE

     P = D(L) + F
!
!  ORDER THE EIGENVALUES.
!
     DO II = 2, L
       I = L + 2 - II
       IF ( P >= D(I-1) ) GO TO 270
       D(I) = D(I-1)
     END DO

250  CONTINUE

     I = 1

270  CONTINUE

     D(I) = P

290  CONTINUE

  END DO

  RETURN
END SUBROUTINE TQLRAT

SUBROUTINE REBAK ( N, B, DL, M, Z )

!*****************************************************************************80
!
!! REBAK DETERMINES EIGENVECTORS BY UNDOING THE REDUC TRANSFORMATION.
!
!  DISCUSSION:
!
!    THIS SUBROUTINE FORMS THE EIGENVECTORS OF A GENERALIZED
!    SYMMETRIC EIGENSYSTEM BY BACK TRANSFORMING THOSE OF THE
!    DERIVED SYMMETRIC MATRIX DETERMINED BY REDUC.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  PARAMETERS:
!
!    INPUT, INTEGER ( KIND = 4 ) N, THE ORDER OF THE MATRIX.
!
!    INPUT, REAL ( KIND = 8 ) B(N,N), CONTAINS INFORMATION ABOUT THE SIMILARITY
!    TRANSFORMATION (CHOLESKY DECOMPOSITION) USED IN THE REDUCTION BY REDUC
!    IN ITS STRICT LOWER TRIANGLE.
!
!    INPUT, REAL ( KIND = 8 ) DL(N), FURTHER INFORMATION ABOUT THE TRANSFORMATION.
!
!    INPUT, INTEGER ( KIND = 4 ) M, THE NUMBER OF EIGENVECTORS TO BE BACK
!    TRANSFORMED.
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) Z(N,M).  ON INPUT, THE EIGENVECTORS TO BE BACK
!    TRANSFORMED IN ITS FIRST M COLUMNS.  ON OUTPUT, THE TRANSFORMED
!    EIGENVECTORS.
!
  IMPLICIT NONE

  INTEGER ( KIND = 4 ) M
  INTEGER ( KIND = 4 ) N

  REAL    ( KIND = 8 ) B(N,N)
  REAL    ( KIND = 8 ) DL(N)
  INTEGER ( KIND = 4 ) I
  INTEGER ( KIND = 4 ) J
  REAL    ( KIND = 8 ) Z(N,M)

  DO J = 1, M
    DO I = N, 1, -1
      Z(I,J) = ( Z(I,J) - DOT_PRODUCT ( B(I+1:N,I), Z(I+1:N,J) ) ) / DL(I)
    END DO
  END DO

  RETURN
END SUBROUTINE REBAK

SUBROUTINE R8_SWAP ( X, Y )

!*****************************************************************************80
!
!! R8_SWAP SWAPS TWO R8'S.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    22 DECEMBER 2000
!
!  AUTHOR:
!
!    JOHN BURKARDT
!
!  PARAMETERS:
!
!    INPUT/OUTPUT, REAL ( KIND = 8 ) X, Y.  ON OUTPUT, THE VALUES OF X AND
!    Y HAVE BEEN INTERCHANGED.
!
  IMPLICIT NONE

  REAL    ( KIND = 8 ) X
  REAL    ( KIND = 8 ) Y
  REAL    ( KIND = 8 ) Z

  Z = X
  X = Y
  Y = Z

  RETURN
END SUBROUTINE R8_SWAP

REAL*8 FUNCTION PYTHAG( A, B )

!*****************************************************************************80
!
!! PYTHAG COMPUTES DSQRT ( A * A + B * B ) CAREFULLY.
!
!  DISCUSSION:
!
!    THE FORMULA
!
!      PYTHAG = DSQRT ( A * A + B * B )
!
!    IS REASONABLY ACCURATE, BUT CAN FAIL IF, FOR EXAMPLE, A**2 IS LARGER
!    THAN THE MACHINE OVERFLOW.  THE FORMULA CAN LOSE MOST OF ITS ACCURACY
!    IF THE SUM OF THE SQUARES IS VERY LARGE OR VERY SMALL.
!
!  LICENSING:
!
!    THIS CODE IS DISTRIBUTED UNDER THE GNU LGPL LICENSE.
!
!  MODIFIED:
!
!    18 OCTOBER 2009
!
!  AUTHOR:
!
!    ORIGINAL FORTRAN77 VERSION BY SMITH, BOYLE, DONGARRA, GARBOW, IKEBE,
!    KLEMA, MOLER.
!    FORTRAN90 VERSION BY JOHN BURKARDT.
!
!  REFERENCE:
!
!    JAMES WILKINSON, CHRISTIAN REINSCH,
!    HANDBOOK FOR AUTOMATIC COMPUTATION,
!    VOLUME II, LINEAR ALGEBRA, PART 2,
!    SPRINGER, 1971,
!    ISBN: 0387054146,
!    LC: QA251.W67.
!
!    BRIAN SMITH, JAMES BOYLE, JACK DONGARRA, BURTON GARBOW,
!    YASUHIKO IKEBE, VIRGINIA KLEMA, CLEVE MOLER,
!    MATRIX EIGENSYSTEM ROUTINES, EISPACK GUIDE,
!    LECTURE NOTES IN COMPUTER SCIENCE, VOLUME 6,
!    SPRINGER VERLAG, 1976,
!    ISBN13: 978-3540075462,
!    LC: QA193.M37.
!
!  MODIFIED:
!
!    04 FEBRUARY 2003
!
!  PARAMETERS:
!
!    INPUT, REAL ( KIND = 8 ) A, B, THE TWO LEGS OF A RIGHT TRIANGLE.
!
!    OUTPUT, REAL ( KIND = 8 ) PYTHAG, THE LENGTH OF THE HYPOTENUSE.
!
  IMPLICIT NONE

  REAL    ( KIND = 8 ) A
  REAL    ( KIND = 8 ) B
  REAL    ( KIND = 8 ) P
  REAL    ( KIND = 8 ) R
  REAL    ( KIND = 8 ) S
  REAL    ( KIND = 8 ) T
  REAL    ( KIND = 8 ) U

  P = MAX ( DABS ( A ), DABS ( B ) )

  IF ( P /= 0.0D+00 ) THEN

    R = ( MIN ( DABS ( A ), DABS ( B ) ) / P )**2

    DO

      T = 4.0D+00 + R

      IF ( T == 4.0D+00 ) THEN
        EXIT
      END IF

      S = R / T
      U = 1.0D+00 + 2.0D+00 * S
      P = U * P
      R = ( S / U )**2 * R

    END DO

  END IF

  PYTHAG = P
  
END FUNCTION PYTHAG

SUBROUTINE JACOBI(A,D,JV,NROT)

!COMPUTES ALL EIGENVALUES AND EIGENVECTORS OF A REAL SYMMETRIC MATRIX A, WHICH IS OF SIZE N
!BY N, STORED IN A PHYSICAL NP BY NP ARRAY. ON OUTPUT, ELEMENTS OF A ABOVE THE DIAGONAL ARE
!DESTROYED. D RETURNS THE EIGENVALUES OF A IN ITS FIRST N ELEMENTS. V IS A MATRIX WITH THE SAME
!LOGICAL AND PHYSICAL DIMENSIONS AS A, WHOSE COLUMNS CONTAIN, ON OUTPUT, THE NORMALIZED
!EIGENVECTORS OF A. NROT RETURNS THE NUMBER OF JACOBI ROTATIONS THAT WERE REQUIRED.

	REAL*8, INTENT(INOUT) :: A(:,:)
	REAL*8, INTENT(OUT) :: D(:), JV(:,:)
	INTEGER, INTENT(OUT) :: NROT
	INTEGER, PARAMETER :: NMAX=5000
	INTEGER :: I,IP,IQ,J,N
	REAL*8 :: JC,JG,JH,S,SM,JT,TAU,THETA,TRESH
	REAL*8, ALLOCATABLE :: JB(:),Z(:)

	N=UBOUND(A,1)
	ALLOCATE(JB(N),Z(N))
	
	DO IP=1,N
		DO IQ=1,N
			JV(IP,IQ)=0.D0
		ENDDO
		JV(IP,IP)=1.0D0
	ENDDO
	
	DO IP=1,N
		JB(IP)=A(IP,IP)
		D(IP)=JB(IP)
		Z(IP)=0.D0
	ENDDO
	
	NROT=0
	
	DO I=1,NMAX
		SM=0.D0
		DO IP=1,N-1
			DO IQ=IP+1,N
				SM=SM+DABS(A(IP,IQ))
			ENDDO
		ENDDO
		IF(DABS(SM-0.D0).LE.5.0D-15) THEN
			GOTO 10
		ENDIF
		IF(I.LT.4)THEN
			TRESH=0.2D0*SM/N**2
		ELSE
			TRESH=0.D0
		ENDIF
		DO IP=1,N-1
			DO IQ=IP+1,N
				JG=100.D0*DABS(A(IP,IQ))
				IF((I.GT.4).AND.(DABS(D(IP))+JG.EQ.DABS(D(IP))).AND.(DABS(D(IQ))+JG.EQ.DABS(D(IQ))))THEN
					A(IP,IQ)=0.D0
				ELSEIF(DABS(A(IP,IQ)).GT.TRESH)THEN
					JH=D(IQ)-D(IP)
					IF(DABS(JH)+JG.EQ.DABS(JH))THEN
						JT=A(IP,IQ)/JH
					ELSE
						THETA=0.5D0*JH/A(IP,IQ)
						JT=1.D0/(DABS(THETA)+DSQRT(1.D0+THETA**2))
						IF(THETA.LT.0.D0) THEN
							JT=-JT
						ENDIF
					ENDIF
					JC=1.D0/DSQRT(1.D0+JT**2)
					S=JT*JC
					TAU=S/(1.D0+JC)
					JH=JT*A(IP,IQ)
					Z(IP)=Z(IP)-JH
					Z(IQ)=Z(IQ)+JH
					D(IP)=D(IP)-JH
					D(IQ)=D(IQ)+JH
					A(IP,IQ)=0.D0
					DO J=1,IP-1
						JG=A(J,IP)
						JH=A(J,IQ)
						A(J,IP)=JG-S*(JH+JG*TAU)
						A(J,IQ)=JH+S*(JG-JH*TAU)
					ENDDO
					DO J=IP+1,IQ-1
						JG=A(IP,J)
						JH=A(J,IQ)
						A(IP,J)=JG-S*(JH+JG*TAU)
						A(J,IQ)=JH+S*(JG-JH*TAU)
					ENDDO
					DO J=IQ+1,N
						JG=A(IP,J)
						JH=A(IQ,J)
						A(IP,J)=JG-S*(JH+JG*TAU)
						A(IQ,J)=JH+S*(JG-JH*TAU)
					ENDDO
					DO J=1,N
						JG=JV(J,IP)
						JH=JV(J,IQ)
						JV(J,IP)=JG-S*(JH+JG*TAU)
						JV(J,IQ)=JH+S*(JG-JH*TAU)
					ENDDO
					NROT=NROT+1
				ENDIF
			ENDDO
		ENDDO
		DO IP=1,N
			JB(IP)=JB(IP)+Z(IP)
			D(IP)=JB(IP)
			Z(IP)=0.D0
		ENDDO
	ENDDO
	PRINT*, 'TOO MANY ITERATIONS IN JACOBI'
10  PRINT*, 'COMPLETE FINDING EIGENVALUES'	
END SUBROUTINE JACOBI

! POWER METHOD FOR FINDING MIN. EIGENVALUE OF ([K] - w^2[M])
SUBROUTINE PWMTD(A, M, W)
	REAL*8, INTENT(IN) :: M(:,:)
	REAL*8, INTENT(INOUT) :: A(:,:)
	REAL*8, INTENT(OUT) :: W
	
	REAL*8, ALLOCATABLE :: OLDX(:), NEWX(:), ERROR(:)
	REAL*8 :: TOL, LAMDA
	INTEGER :: I, J, K, N, NITER, MX(2), ME(2)
	
	PRINT*, ""
	PRINT*, "FIND EIGENVALUE"
	PRINT*, ""
	
	TOL = 5.0D-15
	NITER = 10000
	N = UBOUND(A,1)

	ALLOCATE(OLDX(N), NEWX(N), ERROR(N))

	OLDX(:) = 1.0D0
	MX = (/1, 0/)
	
	CALL CHOLDC(A) ! CHOLESKY DECOMPOSITION, ASSUMED TO BE POSITIVE DEFINITE

	DO I=1, NITER
		CALL SOLVE(A,M,OLDX,NEWX)
		LAMDA = NEWX(MX(1))
		MX = (/MAXLOC(NEWX), 0/)
		NEWX = (1.0D0 / NEWX(MX(1)))*NEWX
!		PRINT*, I
!		PRINT*, NEWX
!		PRINT*, ""
		IF (DABS(NEWX(MX(1))) .LE. TOL) THEN
			PRINT*, "YOU GOT EIGENVALUE 0, SELECT A NEW INITIAL APPROXIMATION"
			STOP
		ELSE
			ERROR = DABS(OLDX - NEWX)
			ME = (/MAXLOC(ERROR), 0/)
			IF (ERROR(ME(1)).LE.TOL) THEN
				GOTO 10
			ENDIF
		ENDIF
		OLDX = NEWX
	ENDDO
10 W = 1.0D0 / LAMDA
	PRINT*, ""
	PRINT*, "FINAL ITERATION NUMBER : ", I
	PRINT*, ""
	DEALLOCATE(OLDX, NEWX, ERROR)

END SUBROUTINE PWMTD

! SOLVE THE SYSTEM Y = L^(-1)*M*(L^(T))^(-1)*X, WHERE L = LOWER TRIANGULAR MATRIX OF A, M = MASS MATRIX
SUBROUTINE SOLVE(L,M,OLDX, NEWX)
	REAL*8, INTENT(IN) :: L(:,:), M(:,:), OLDX(:)
	REAL*8, INTENT(INOUT) :: NEWX(:)
	
	REAL*8, ALLOCATABLE :: Y(:), Z(:), U(:,:)
	REAL*8 :: SM
	INTEGER :: N, I, J
	
	N = UBOUND(L,1)
	ALLOCATE(Y(N), Z(N), U(N,N))
	
	U = TRANSPOSE(L)
	
!	DO I=1, N
!		PRINT*, (U(I,J), J=1, N)
!	ENDDO
	
	! BACK SUBSTITUTION
	Y(N) = (OLDX(N) / U(N,N))
	DO I=N-1, 1, -1
		SM = 0.0D0
		DO J=N, I+1, -1
			SM = SM + U(I,J)*Y(J)
		ENDDO
		Y(I) = (OLDX(I) - SM) / U(I,I)
	ENDDO
	
	NEWX(:) = 0.0D0
	
!	PRINT*, "Y"
!	PRINT*, Y
	
	Z = MATMUL(M, Y)
	
!	PRINT*, "Z"
!	PRINT*, Z
	
	! FORWARD SUBSTITUTION
	NEWX(1) = (Z(1) / L(1,1))
	DO I=2, N
		SM = 0.0D0
		DO J=1, I-1
			SM = SM + L(I,J)*NEWX(J)
		ENDDO
		NEWX(I) = (Z(I) - SM) / L(I,I)
	ENDDO
	
!	PRINT*, "X"
!	PRINT*, X

	DEALLOCATE(Y,Z,U)
	
END SUBROUTINE SOLVE

SUBROUTINE CHOLDC(A)

!GIVEN A POSITIVE-DEFINITE SYMMETRIC MATRIX A(1:N,1:N), WITH PHYSICAL DIMENSION NP, THIS
!ROUTINE CONSTRUCTS ITS CHOLESKY DECOMPOSITION, A = L*LT . ON INPUT, ONLY THE UPPER TRIANGLE
!OF A NEED BE GIVEN; IT IS NOT MODIFIED. THE CHOLESKY FACTOR L IS RETURNED IN THE LOWER TRIANGLE
!OF A, EXCEPT FOR ITS DIAGONAL ELEMENTS WHICH ARE RETURNED IN P(1:N).

	REAL*8, INTENT(INOUT) :: A(:,:)	! RETURN LOWER TRIANGULAR MATRIX OF A
!	REAL*8, INTENT(OUT) :: L(:,:)

	INTEGER :: I,J,K,N
	REAL*8, ALLOCATABLE :: P(:)
	REAL*8 :: SUM
	
	N = UBOUND(A,1)
	ALLOCATE(P(N))
	
	DO I=1,N
		DO J=I,N
			SUM=A(I,J)
			DO K=I-1,1,-1
				SUM=SUM-A(I,K)*A(J,K)
			ENDDO
			IF(I.EQ.J)THEN
				IF(DABS(SUM) .LE. 1.0D-15) THEN 
					PRINT*, 'CHOLDC FAILED' ! A, WITH ROUNDING ERRORS, IS NOT POSITIVE DEFINITE.
					STOP
				ELSE
					P(I)=DSQRT(SUM)
				ENDIF
			ELSE
				A(J,I)=SUM/P(I)
			ENDIF
		ENDDO
	ENDDO
	
	DO I=1, N-1
		DO J=I+1, N
			A(I,J) = 0.0D0
		ENDDO
		A(I,I) = P(I)
	ENDDO
	A(N,N) = P(N)

	DEALLOCATE(P)
	
END SUBROUTINE CHOLDC

SUBROUTINE QUICKSORT(N,X,IND)
 
IMPLICIT NONE

REAL*8, INTENT(IN)  :: X(N)
INTEGER, INTENT(INOUT)   :: IND(N)
INTEGER, INTENT(IN)    :: N

!***************************************************************************

!                                                         ROBERT RENKA
!                                                 OAK RIDGE NATL. LAB.

!   THIS SUBROUTINE USES AN ORDER N*LOG(N) QUICK SORT TO SORT A REAL 
! ARRAY X INTO INCREASING ORDER.  THE ALGORITHM IS AS FOLLOWS.  IND IS
! INITIALIZED TO THE ORDERED SEQUENCE OF INDICES 1,...,N, AND ALL INTERCHANGES
! ARE APPLIED TO IND.  X IS DIVIDED INTO TWO PORTIONS BY PICKING A CENTRAL
! ELEMENT T.  THE FIRST AND LAST ELEMENTS ARE COMPARED WITH T, AND
! INTERCHANGES ARE APPLIED AS NECESSARY SO THAT THE THREE VALUES ARE IN
! ASCENDING ORDER.  INTERCHANGES ARE THEN APPLIED SO THAT ALL ELEMENTS
! GREATER THAN T ARE IN THE UPPER PORTION OF THE ARRAY AND ALL ELEMENTS
! LESS THAN T ARE IN THE LOWER PORTION.  THE UPPER AND LOWER INDICES OF ONE
! OF THE PORTIONS ARE SAVED IN LOCAL ARRAYS, AND THE PROCESS IS REPEATED
! ITERATIVELY ON THE OTHER PORTION.  WHEN A PORTION IS COMPLETELY SORTED,
! THE PROCESS BEGINS AGAIN BY RETRIEVING THE INDICES BOUNDING ANOTHER
! UNSORTED PORTION.

! INPUT PARAMETERS -   N - LENGTH OF THE ARRAY X.

!                      X - VECTOR OF LENGTH N TO BE SORTED.

!                    IND - VECTOR OF LENGTH >= N.

! N AND X ARE NOT ALTERED BY THIS ROUTINE.

! OUTPUT PARAMETER - IND - SEQUENCE OF INDICES 1,...,N PERMUTED IN THE SAME
!                          FASHION AS X WOULD BE.  THUS, THE ORDERING ON
!                          X IS DEFINED BY Y(I) = X(IND(I)).

!*********************************************************************

! NOTE -- IU AND IL MUST BE DIMENSIONED >= LOG(N) WHERE LOG HAS BASE 2.
! (OK FOR N UP TO ABOUT A BILLON)

!*********************************************************************

INTEGER   :: IU(21), IL(21)
INTEGER   :: M, I, J, K, L, IJ, IT, ITT, INDX
REAL*8      :: R
REAL*8      :: T

! LOCAL PARAMETERS -

! IU,IL =  TEMPORARY STORAGE FOR THE UPPER AND LOWER
!            INDICES OF PORTIONS OF THE ARRAY X
! M =      INDEX FOR IU AND IL
! I,J =    LOWER AND UPPER INDICES OF A PORTION OF X
! K,L =    INDICES IN THE RANGE I,...,J
! IJ =     RANDOMLY CHOSEN INDEX BETWEEN I AND J
! IT,ITT = TEMPORARY STORAGE FOR INTERCHANGES IN IND
! INDX =   TEMPORARY INDEX FOR X
! R =      PSEUDO RANDOM NUMBER FOR GENERATING IJ
! T =      CENTRAL ELEMENT OF X

IF (N <= 0) RETURN

! INITIALIZE IND, M, I, J, AND R

DO  I = 1, N
  IND(I) = I
END DO
M = 1
I = 1
J = N
R = 0.3750D0

! TOP OF LOOP

20 IF (I >= J) GO TO 70
IF (R <= 0.58984370D0) THEN
  R = R + 0.03906250D0
ELSE
  R = R - 0.218750D0
END IF

! INITIALIZE K

30 K = I

! SELECT A CENTRAL ELEMENT OF X AND SAVE IT IN T

IJ = I + R*(J-I)
IT = IND(IJ)
T = X(IT)

! IF THE FIRST ELEMENT OF THE ARRAY IS GREATER THAN T,
!   INTERCHANGE IT WITH T

INDX = IND(I)
IF (X(INDX) > T) THEN
  IND(IJ) = INDX
  IND(I) = IT
  IT = INDX
  T = X(IT)
END IF

! INITIALIZE L

L = J

! IF THE LAST ELEMENT OF THE ARRAY IS LESS THAN T,
!   INTERCHANGE IT WITH T

INDX = IND(J)
IF (X(INDX) >= T) GO TO 50
IND(IJ) = INDX
IND(J) = IT
IT = INDX
T = X(IT)

! IF THE FIRST ELEMENT OF THE ARRAY IS GREATER THAN T,
!   INTERCHANGE IT WITH T

INDX = IND(I)
IF (X(INDX) <= T) GO TO 50
IND(IJ) = INDX
IND(I) = IT
IT = INDX
T = X(IT)
GO TO 50

! INTERCHANGE ELEMENTS K AND L

40 ITT = IND(L)
IND(L) = IND(K)
IND(K) = ITT

! FIND AN ELEMENT IN THE UPPER PART OF THE ARRAY WHICH IS
!   NOT LARGER THAN T

50 L = L - 1
INDX = IND(L)
IF (X(INDX) > T) GO TO 50

! FIND AN ELEMENT IN THE LOWER PART OF THE ARRAY WHCIH IS NOT SMALLER THAN T

60 K = K + 1
INDX = IND(K)
IF (X(INDX) < T) GO TO 60

! IF K <= L, INTERCHANGE ELEMENTS K AND L

IF (K <= L) GO TO 40

! SAVE THE UPPER AND LOWER SUBSCRIPTS OF THE PORTION OF THE
!   ARRAY YET TO BE SORTED

IF (L-I > J-K) THEN
  IL(M) = I
  IU(M) = L
  I = K
  M = M + 1
  GO TO 80
END IF

IL(M) = K
IU(M) = J
J = L
M = M + 1
GO TO 80

! BEGIN AGAIN ON ANOTHER UNSORTED PORTION OF THE ARRAY

70 M = M - 1
IF (M == 0) RETURN
I = IL(M)
J = IU(M)

80 IF (J-I >= 11) GO TO 30
IF (I == 1) GO TO 20
I = I - 1

! SORT ELEMENTS I+1,...,J.  NOTE THAT 1 <= I < J AND J-I < 11.

90 I = I + 1
IF (I == J) GO TO 70
INDX = IND(I+1)
T = X(INDX)
IT = INDX
INDX = IND(I)
IF (X(INDX) <= T) GO TO 90
K = I

100 IND(K+1) = IND(K)
K = K - 1
INDX = IND(K)
IF (T < X(INDX)) GO TO 100

IND(K+1) = IT
GO TO 90
END SUBROUTINE QUICKSORT

END MODULE EIGEN
