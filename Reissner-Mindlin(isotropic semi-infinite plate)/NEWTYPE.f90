 MODULE NEWTYPE

    IMPLICIT NONE
    
        TYPE FVALUE
        	REAL*8 :: D00,D10,D01
        END TYPE FVALUE

        ! 2D POINT
        TYPE POINT2D
        	REAL(8) :: X,Y
        END TYPE POINT2D

        ! 2D VECTOR
        TYPE VEC2D
        	TYPE(POINT2D) :: U,V
        END TYPE VEC2D

        ! 2D INTEGER VECTOR
        TYPE INT2D
        	INTEGER :: A, B
        END TYPE INT2D

        ! 3D INTEGER VECTOR
        TYPE INT3D
        	INTEGER :: A,B,C
        END TYPE INT3D

        ! RECTANGULAR PATCH 2D
        TYPE RECPATCH
        	TYPE(POINT2D) :: PT1,PT2,PT3,PT4
        END TYPE RECPATCH

        ! TRIANGULAR PATCH 2D
        TYPE TRIPATCH
            TYPE(POINT2D) :: PT1, PT2, PT3
        END TYPE TRIPATCH
        
        TYPE TRANSFORM2D
        	TYPE(POINT2D) :: PT
        	REAL(8) :: JACOBIAN
        END TYPE TRANSFORM2D
        
        TYPE DISPLACEMENT
        	REAL*8 :: W0, PIX, PIY
        END TYPE DISPLACEMENT

		TYPE MOMENT
			REAL*8 :: MXX, MYY, MXY
		END TYPE MOMENT
		
        ! NEW OPERATION ON THE NEW TYPE
        INTERFACE OPERATOR(+)
        MODULE PROCEDURE EXT_PATCH
        MODULE PROCEDURE ADD_POINT2D
        MODULE PROCEDURE EXT_VEC2D
        END INTERFACE
				
		INTERFACE OPERATOR(.AND.)
		MODULE PROCEDURE RECPATCH_INTERSECTION
		END INTERFACE

CONTAINS

!!!!! FUNCTIONS FOR THE NEW OPERATION + !!!!!
	TYPE(RECPATCH) FUNCTION EXT_PATCH(OLDPATCH,AMOUNT)
		TYPE(RECPATCH), INTENT(IN) :: OLDPATCH
		REAL*8, INTENT(IN) :: AMOUNT

		EXT_PATCH%PT1=POINT2D(OLDPATCH%PT1%X-AMOUNT,OLDPATCH%PT1%Y-AMOUNT)
		EXT_PATCH%PT2=POINT2D(OLDPATCH%PT2%X+AMOUNT,OLDPATCH%PT2%Y-AMOUNT)
		EXT_PATCH%PT3=POINT2D(OLDPATCH%PT3%X+AMOUNT,OLDPATCH%PT3%Y+AMOUNT)
		EXT_PATCH%PT4=POINT2D(OLDPATCH%PT4%X-AMOUNT,OLDPATCH%PT4%Y+AMOUNT)
		
	END FUNCTION EXT_PATCH

        TYPE(VEC2D) FUNCTION EXT_VEC2D(INVEC,AMOUNT)
            TYPE(VEC2D),INTENT(IN) :: INVEC
            REAL(8), INTENT(IN) :: AMOUNT
            EXT_VEC2D%U%X=INVEC%U%X-AMOUNT
            EXT_VEC2D%U%Y=INVEC%U%Y-AMOUNT
            EXT_VEC2D%V%X=INVEC%V%X+AMOUNT
            EXT_VEC2D%V%Y=INVEC%V%Y+AMOUNT
        END FUNCTION EXT_VEC2D

	TYPE(POINT2D) FUNCTION ADD_POINT2D(PT1,PT2)
	    TYPE(POINT2D),INTENT(IN) :: PT1,PT2
	    ADD_POINT2D%X=PT1%X+PT2%X
	    ADD_POINT2D%Y=PT1%Y+PT2%Y
	END FUNCTION ADD_POINT2D

!!!!! FUNCTIONS FOR THE NEW OPERATION .AND. !!!!!
	TYPE(RECPATCH) FUNCTION RECPATCH_INTERSECTION(PATCH1,PATCH2)
		TYPE(RECPATCH),INTENT(IN) :: PATCH1,PATCH2
		LOGICAL :: VALIDATION
		REAL(8) :: SX,BX,SY,BY
		
		VALIDATION=VALIDATE_INTERSECTION(PATCH1,PATCH2)
		
		IF (VALIDATION) THEN
			SX=MAX(PATCH1%PT1%X,PATCH2%PT1%X)
			BX=MIN(PATCH1%PT2%X,PATCH2%PT2%X)
			SY=MAX(PATCH1%PT1%Y,PATCH2%PT1%Y)
			BY=MIN(PATCH1%PT3%Y,PATCH2%PT3%Y)

			RECPATCH_INTERSECTION=RECPATCH(POINT2D(SX,SY),POINT2D(BX,SY),&
		                                POINT2D(BX,BY),POINT2D(SX,BY))
		ELSE
			RECPATCH_INTERSECTION=RECPATCH(POINT2D(0.0D0,0.0D0),POINT2D(0.0D0,0.0D0),&
										   POINT2D(0.0D0,0.0D0),POINT2D(0.0D0,0.0D0))
		ENDIF	

	END FUNCTION RECPATCH_INTERSECTION

	LOGICAL FUNCTION VALIDATE_INTERSECTION(PATCH1,PATCH2)
		TYPE(RECPATCH),INTENT(IN) :: PATCH1,PATCH2
		REAL(8) :: SX,BX,SY,BY

		SX=MAX(PATCH1%PT1%X,PATCH2%PT1%X)
		BX=MIN(PATCH1%PT2%X,PATCH2%PT2%X)
		SY=MAX(PATCH1%PT1%Y,PATCH2%PT1%Y)
		BY=MIN(PATCH1%PT3%Y,PATCH2%PT3%Y)

		IF (BX-SX.GT.5.0D-15 .AND. BY-SY.GT.5.0D-15) THEN
			VALIDATE_INTERSECTION=.TRUE.
		ELSE
			VALIDATE_INTERSECTION=.FALSE.
		END IF

	END FUNCTION VALIDATE_INTERSECTION

	LOGICAL FUNCTION IS_SAME(PATCH1,PATCH2)
		TYPE(RECPATCH),INTENT(IN) :: PATCH1,PATCH2
		REAL(8) :: DIFFX1,DIFFX2,DIFFY1,DIFFY2

		DIFFX1=(PATCH1%PT1%X-PATCH2%PT1%X)
		DIFFX2=(PATCH1%PT2%X-PATCH2%PT2%X)
		DIFFY1=(PATCH1%PT1%Y-PATCH2%PT1%Y)
		DIFFY2=(PATCH1%PT3%Y-PATCH2%PT3%Y)

		IS_SAME=.FALSE.

		IF ((DIFFX1).LT.5.0D-15.AND.(DIFFX2).LT.5.0D-15.AND.(DIFFY1).LT.5.0D-15.AND.&
		   &(DIFFY2).LT.5.0D-15) THEN
			IS_SAME=.TRUE.
		END IF
	END FUNCTION IS_SAME

	LOGICAL FUNCTION IS_BOUNDARY(PT2D,RECPATCH_TEST)
		TYPE(RECPATCH),INTENT(IN) :: RECPATCH_TEST
		TYPE(POINT2D),INTENT(IN):: PT2D
		REAL(8) :: SX,BX,SY,BY
		REAL(8) :: X,Y

		SX=RECPATCH_TEST%PT1%X
		BX=RECPATCH_TEST%PT2%X
		SY=RECPATCH_TEST%PT1%Y
		BY=RECPATCH_TEST%PT3%Y

		X=PT2D%X
		Y=PT2D%Y

		IS_BOUNDARY=.FALSE.

		IF (((BX-X).LT.5.0D-15 .OR. (X-SX).LT.5.0D-15).AND. &
               (Y.GE.SY.AND.Y.LE.BY)) THEN
			IS_BOUNDARY=.TRUE.
		END IF

		IF (((BY-Y).LT.5.0D-15 .OR. (Y-SY).LT.5.0D-15).AND. &
               (X.GE.SX.AND.X.LE.BX)) THEN
			IS_BOUNDARY=.TRUE.
		END IF

	END FUNCTION IS_BOUNDARY

	CHARACTER (LEN=2) FUNCTION WHICH_BOUNDARY(PT2D,RECPATCH_TEST)
		TYPE(RECPATCH),INTENT(IN) :: RECPATCH_TEST
		TYPE(POINT2D),INTENT(IN):: PT2D
		REAL(8) :: SX,BX,SY,BY
		REAL(8) :: X,Y

		SX=RECPATCH_TEST%PT1%X
		BX=RECPATCH_TEST%PT2%X
		SY=RECPATCH_TEST%PT1%Y
		BY=RECPATCH_TEST%PT3%Y
		
		X=PT2D%X
		Y=PT2D%Y

        ! 'NN' = NONE  'RR' = RIGHT 'LL' = LEFT  'FF' = FORWARD  'KK' = BACKWARD
        ! 'LF' = LEFT/RIGHT  'RF' = RIGHT/FORWARD  'LK' = LEFT/BACKWARD  'RK' = RIGHT/BACKWARD

		WHICH_BOUNDARY='NN'

		IF (((BX-X).LT.5.0D-15).AND. &
               (Y.GE.SY.AND.Y.LE.BY).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='RR'
        ENDIF
        IF (((X-SX).LT.5.0D-15).AND. &
               (Y.GE.SY.AND.Y.LE.BY).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='LL'
		END IF

		IF (((BY-Y).LT.5.0D-15).AND. &
               (X.GE.SX.AND.X.LE.BX).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='KK'
		END IF
		IF (((Y-SY).LT.5.0D-15).AND. &
               (X.GE.SX.AND.X.LE.BX).AND.WHICH_BOUNDARY.EQ.'NN') THEN
			WHICH_BOUNDARY='FF'
		END IF
		IF (((X-SX).LT.5.0D-15).AND.((Y-SY).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='LF'
		END IF
		IF (((BX-X).LT.5.0D-15).AND.((Y-SY).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='RF'
		END IF
		IF (((X-SX).LT.5.0D-15).AND.((BY-Y).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='LK'
		END IF
		IF (((BX-X).LT.5.0D-15).AND.((BY-Y).LT.5.0D-15).AND.WHICH_BOUNDARY.NE.'NN') THEN
			WHICH_BOUNDARY='RK'
		END IF
	END FUNCTION WHICH_BOUNDARY

SUBROUTINE SPLITRECPATCH(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

    TYPE(RECPATCH), INTENT(OUT) :: SPLITTEDRECPATCHES(9)
    TYPE(RECPATCH), INTENT(IN) :: PATCHRECTANGLE, CENTERRECTANGLE
    INTEGER :: I

    DO I=1,9
        CALL INITIALIZE(SPLITTEDRECPATCHES(I))
    ENDDO

    CALL SPLITRECPATCHX(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)
    CALL SPLITRECPATCHY(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

END SUBROUTINE SPLITRECPATCH

SUBROUTINE SPLITRECPATCHX(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

    TYPE(RECPATCH), INTENT(INOUT) :: SPLITTEDRECPATCHES(9)
    TYPE(RECPATCH), INTENT(IN) :: PATCHRECTANGLE, CENTERRECTANGLE
    REAL*8 :: X(4)
    INTEGER :: I, J

    X(1)=PATCHRECTANGLE%PT1%X
    X(2)=CENTERRECTANGLE%PT1%X
    X(3)=CENTERRECTANGLE%PT2%X
    X(4)=PATCHRECTANGLE%PT2%X

    DO I=1,9
        J=MOD(I,3)
        IF (J.EQ.0) THEN
            J=3
        ENDIF
        SPLITTEDRECPATCHES(I)%PT1%X=X(J)
        SPLITTEDRECPATCHES(I)%PT2%X=X(J+1)
        SPLITTEDRECPATCHES(I)%PT3%X=X(J+1)
        SPLITTEDRECPATCHES(I)%PT4%X=X(J)
    ENDDO

END SUBROUTINE SPLITRECPATCHX

SUBROUTINE SPLITRECPATCHY(SPLITTEDRECPATCHES, PATCHRECTANGLE, CENTERRECTANGLE)

    TYPE(RECPATCH), INTENT(INOUT) :: SPLITTEDRECPATCHES(9)
    TYPE(RECPATCH), INTENT(IN) :: PATCHRECTANGLE, CENTERRECTANGLE
    REAL*8 :: Y(4)
    INTEGER :: I, J, K

    Y(1)=PATCHRECTANGLE%PT1%Y
    Y(2)=CENTERRECTANGLE%PT1%Y
    Y(3)=CENTERRECTANGLE%PT3%Y
    Y(4)=PATCHRECTANGLE%PT3%Y

    DO I=1,9
        J=1+INT(I/3)
        IF (MOD(I,3).EQ.0) THEN
            J=J-1
        ENDIF
        K=MOD(J,3)
        IF (MOD(J,3).EQ.0) THEN
            K=3
        ENDIF
        SPLITTEDRECPATCHES(I)%PT1%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT2%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT3%Y=Y(K+1)
        SPLITTEDRECPATCHES(I)%PT4%Y=Y(K+1)

        SPLITTEDRECPATCHES(I)%PT1%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT2%Y=Y(K)
        SPLITTEDRECPATCHES(I)%PT3%Y=Y(K+1)
        SPLITTEDRECPATCHES(I)%PT4%Y=Y(K+1)
    ENDDO

END SUBROUTINE SPLITRECPATCHY

SUBROUTINE CENTERPTS(PTS, SPLITTEDRECPATCHES)

    TYPE(POINT2D), INTENT(OUT) :: PTS(9)
    TYPE(RECPATCH), INTENT(IN) :: SPLITTEDRECPATCHES(9)
    INTEGER :: I

    DO I=1, 9
        PTS(I)%X=SPLITTEDRECPATCHES(I)%PT1%X + 0.5D0*(SPLITTEDRECPATCHES(I)%PT2%X-SPLITTEDRECPATCHES(I)%PT1%X)
        PTS(I)%Y=SPLITTEDRECPATCHES(I)%PT1%Y + 0.5D0*(SPLITTEDRECPATCHES(I)%PT4%Y-SPLITTEDRECPATCHES(I)%PT1%Y)
    ENDDO

END SUBROUTINE CENTERPTS

SUBROUTINE INITIALIZE(INITIALPATCH)

    TYPE(RECPATCH), INTENT(INOUT) :: INITIALPATCH

    INITIALPATCH%PT1=POINT2D(0.0D0, 0.0D0)
    INITIALPATCH%PT2=POINT2D(0.0D0, 0.0D0)
    INITIALPATCH%PT3=POINT2D(0.0D0, 0.0D0)
    INITIALPATCH%PT4=POINT2D(0.0D0, 0.0D0)


END SUBROUTINE INITIALIZE

END MODULE NEWTYPE

