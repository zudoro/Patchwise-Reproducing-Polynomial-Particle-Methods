MODULE PACKAGE

	USE NEWTYPE
	USE GLBVAR

	IMPLICIT NONE

	TYPE INTPATCH
		TYPE(RECPATCH) :: SUBPATCH
		INTEGER :: SUBINDEX, PATCHNUMBER
	END TYPE INTPATCH

	TYPE SUBMAT
	    INTEGER :: R11(INT(DOF*(DOF+1)*0.5)), R12(INT(DOF**2)), R13(INT(DOF**2))
	    INTEGER :: R22(INT(DOF*(DOF+1)*0.5)), R23(INT(DOF**2)), R33(INT(DOF*(DOF+1)*0.5))
		INTEGER :: C11(INT(DOF*(DOF+1)*1.5)), C12(INT(DOF**2)), C13(INT(DOF**2))
		INTEGER :: C22(INT(DOF*(DOF+1)*0.5)), C23(INT(DOF**2)), C33(INT(DOF*(DOF+1)*0.5))
		INTEGER :: NZ(6)
		REAL*8 :: K11(INT(DOF*(DOF+1)*0.5)), K12(INT(DOF**2)), K13(INT(DOF**2))
		REAL*8 :: K22(INT(DOF*(DOF+1)*0.5)), K23(INT(DOF**2)), K33(INT(DOF*(DOF+1)*0.5))
	END TYPE SUBMAT
	
CONTAINS

! Check PU and Interpolation functions
SUBROUTINE CHECKBASIS()

	USE PU
	USE INTERPOLATION
	
	TYPE(POINT2D), ALLOCATABLE :: NODE(:)
	TYPE(FVALUE), ALLOCATABLE :: PUVAL(:)
	TYPE(FVALUE) :: SFVAL
	TYPE(RECPATCH) :: PATCH1, EXTBGMESH1
	REAL*8, ALLOCATABLE :: PTEVAL(:)
	INTEGER :: NDX(3,DOF)
	INTEGER :: I, J, KK, COUNT

	ALLOCATE(PTEVAL(DOF), NODE(DOF), PUVAL(DOF))
	NODE=NODE_ALL(NUMPATCHES)
	CALL STIFINDEX(NDX)

!	OPEN(1, FILE='ndx.dat')
!	DO I=1, DOF
!		WRITE(1,*) NDX(1,I), NDX(2,I), NDX(3,I)
!	ENDDO
!	CLOSE(1)

	PTEVAL(:)=0.0D0
	
	DO I=1, NUMPATCHES
		CALL PHYPU(PUVAL(:), NODE(:), DOF, BGMESH(I)+DELTA)
!		PRINT*, (PUVAL(J)%D00, J=1, DOF)
		PTEVAL(:) = PTEVAL(:) + PUVAL(:)%D00
	ENDDO

	OPEN(1, FILE='checkpu.dat')
	DO I=1, DOF
		WRITE(1,*) NODE(I)%X, NODE(I)%Y, PTEVAL(I)
	ENDDO
	CLOSE(1)

	DO I=1, DOF
		PTEVAL(I)=0.0D0
	ENDDO
	
!	PATCH1=OMEGA.AND.(BGMESH(NDX(1,1))+DELTA)
!	OPEN(3, FILE='patch1.dat')
!	WRITE(3,*) PATCH1%PT1%X, PATCH1%PT1%Y
!	WRITE(3,*) PATCH1%PT2%X, PATCH1%PT2%Y
!	WRITE(3,*) PATCH1%PT3%X, PATCH1%PT3%Y
!	WRITE(3,*) PATCH1%PT4%X, PATCH1%PT4%Y
!	WRITE(3,*) PATCH1%PT1%X, PATCH1%PT1%Y
!	CLOSE(3)

!	EXTBGMESH1=BGMESH(NDX(1,1))+DELTA
!	OPEN(3, FILE='extbgmesh.dat')
!	WRITE(3,*) EXTBGMESH1%PT1%X, EXTBGMESH1%PT1%Y
!	WRITE(3,*) EXTBGMESH1%PT2%X, EXTBGMESH1%PT2%Y
!	WRITE(3,*) EXTBGMESH1%PT3%X, EXTBGMESH1%PT3%Y
!	WRITE(3,*) EXTBGMESH1%PT4%X, EXTBGMESH1%PT4%Y
!	WRITE(3,*) EXTBGMESH1%PT1%X, EXTBGMESH1%PT1%Y
!	CLOSE(3)
	
!	OPEN(2, FILE='checksf1.dat')
	COUNT=0
	DO I=1, NUMPATCHES
		DO J=1, (IORDER+1)**2
			COUNT=COUNT+1
			DO KK=1, (IORDER+1)**2
				SFVAL=PHYSF2D(NODE(COUNT),INT2D(NDX(2,(I-1)*(IORDER+1)**2+KK),NDX(3,(I-1)*(IORDER+1)**2+KK)),IORDER,OMEGA.AND.(BGMESH(I)+DELTA))
!				CALL PHYSF(SFVAL(:), NODE(:), DOF, INT2D(NDX(2,I),NDX(3,I)), IORDER, OMEGA.AND.(BGMESH(NDX(1,I))+DELTA))
!				CALL VECADD(PTEVAL(:), SFVAL(:)%D00, DOF)
				PTEVAL(COUNT)=PTEVAL(COUNT)+SFVAL%D00
			ENDDO
		ENDDO
	ENDDO
!	CLOSE(2)
	
	OPEN(1, FILE='checksf.dat')
	DO I=1, DOF
		WRITE(1,*) NODE(I)%X, NODE(I)%Y, PTEVAL(I)
	ENDDO
	CLOSE(1)

	DEALLOCATE(PTEVAL, NODE, PUVAL)
	
END SUBROUTINE CHECKBASIS
		
! WE CAN CHECK THE COORDINATES OF ALL NODAL POINTS USING THE TWO CODES BELOW
FUNCTION NODE_ALL(NPATCH)

    INTEGER, INTENT(IN) :: NPATCH
    TYPE(POINT2D) :: NODE_ALL(DOF)
    INTEGER :: I

    DO I=1, NUMPATCHES
        NODE_ALL((I-1)*((IORDER+1)**2)+1:I*(IORDER+1)**2)=NODE_PATCH(I)
    ENDDO

END FUNCTION NODE_ALL

FUNCTION NODE_PATCH(BGMESH_NUMBER)

    INTEGER, INTENT(IN) :: BGMESH_NUMBER
    TYPE(RECPATCH) :: INT_SUPP
    TYPE(POINT2D) :: NODE_PATCH((IORDER+1)**2)
    REAL*8 :: LENGTHX, LENGTHY
    INTEGER :: I

    INT_SUPP=OMEGA.AND.(BGMESH(BGMESH_NUMBER)+DELTA)
    LENGTHX=DABS(INT_SUPP%PT2%X-INT_SUPP%PT1%X)/IORDER
    LENGTHY=DABS(INT_SUPP%PT4%Y-INT_SUPP%PT1%Y)/IORDER

    DO I=1, (IORDER+1)**2
        NODE_PATCH(I)%X=INT_SUPP%PT1%X+LENGTHX*MOD(I+IORDER, IORDER+1)
        NODE_PATCH(I)%Y=INT_SUPP%PT1%Y+LENGTHY*MOD(INT((I-1)/(IORDER+1))+IORDER+1, IORDER+1)
    ENDDO

END FUNCTION NODE_PATCH

! INDEX OF ALL PU AND INTERPOLATION FUNCTIONS
SUBROUTINE STIFINDEX(NDX)

    INTEGER, INTENT(OUT) :: NDX(3, DOF)
    INTEGER :: I

    DO I=1, DOF
        NDX(1,I)=1+INT((I-1)/(IORDER+1)**2)
        NDX(2,I)=MOD(I+IORDER, IORDER+1)
        NDX(3,I)=MOD(INT((I-1)/(IORDER+1))+IORDER+1, IORDER+1)
    ENDDO

END SUBROUTINE STIFINDEX

! PUFEM APPROXIMATE SOLUTION
SUBROUTINE APPROXSOL(DISP, XCORDS, YCORDS, COEFF_SOL, NDX)

	USE PU
	USE INTERPOLATION

	REAL*8, INTENT(IN) :: COEFF_SOL(3*DOF), XCORDS(:), YCORDS(:)
	INTEGER, INTENT(IN) :: NDX(3,DOF)
	TYPE(DISPLACEMENT), INTENT(OUT) :: DISP(:)
!	TYPE(MOMENT), INTENT(OUT) :: MOMENTS(:)
	TYPE(FVALUE) :: PUF, SF
	INTEGER :: NUM_XCORDS, NUM_YCORDS, VEC_N, I, J, II, JJ, KK

	NUM_XCORDS = UBOUND(XCORDS,1)
	NUM_YCORDS = UBOUND(YCORDS,1)
	VEC_N = NUM_XCORDS*NUM_YCORDS
	
	DO I=1, VEC_N
		DISP(I) = DISPLACEMENT(0.0D0, 0.0D0, 0.0D0)
!		MOMENTS(I) = MOMENT(0.0D0, 0.0D0, 0.0D0)
	ENDDO

	KK = 0
	DO I=1, NUM_XCORDS
		DO J=1, NUM_YCORDS
			KK = KK+1
			DO II=1, DOF
				PUF = PHYPU2D(POINT2D(XCORDS(I), YCORDS(J)), BGMESH(NDX(1,II))+DELTA)
				SF = PHYSF2D(POINT2D(XCORDS(I), YCORDS(J)), INT2D(NDX(2,II),NDX(3,II)), & 
							 IORDER, OMEGA.AND.(BGMESH(NDX(1,II))+DELTA))
				DISP(KK)%W0 = DISP(KK)%W0 + COEFF_SOL(II)*PUF%D00*SF%D00
				DISP(KK)%PIX = DISP(KK)%PIX + COEFF_SOL(DOF+II)*PUF%D00*SF%D00
				DISP(KK)%PIY = DISP(KK)%PIY + COEFF_SOL(2*DOF+II)*PUF%D00*SF%D00
			ENDDO
		ENDDO
	ENDDO
	
END SUBROUTINE APPROXSOL

! STORE PU EVALUATIONS AT ALL GAUSS POINTS
SUBROUTINE PUDATUM(PUSTORAGE, PUDATA, NDX_I, INTPATCHGROUP, NINTPATCHGROUP, X, W, N)

	USE PU
	USE INTERPOLATION
	USE GSQUAD
	
    INTEGER, INTENT(IN) :: NDX_I
    TYPE(INTPATCH), INTENT(IN) :: INTPATCHGROUP(NUMPATCHES, NUMPATCHES, NUMINTSUBPATCH)
    INTEGER, INTENT(IN) :: NINTPATCHGROUP(NUMPATCHES, NUMPATCHES), N
    REAL*8, INTENT(IN) :: X(N), W(N)
    TYPE(FVALUE), INTENT(INOUT) :: PUSTORAGE(NUMPATCHES, NUMINTSUBPATCH, N**2) !<----------NOT GENERAL CASE !!!
    INTEGER, INTENT(INOUT) :: PUDATA(NUMPATCHES, NUMINTSUBPATCH)
    TYPE(TRANSFORM2D) :: GSPT(N**2)
    REAL*8 :: WEIGHT(N**2)
    INTEGER :: II, JJ, I, J, KK, COUNT

    !----------INITIALIZE---------
    FORALL (I=1:NUMPATCHES, J=1:NUMINTSUBPATCH, KK=1:N**2)
        PUSTORAGE(I,J,KK)=FVALUE(0.0D0, 0.0D0, 0.0D0)
    END FORALL

    FORALL (I=1:NUMPATCHES, J=1:NUMINTSUBPATCH) PUDATA(I,J)=0

    DO II=NDX_I, NUMPATCHES
    DO JJ=1, NINTPATCHGROUP(NDX_I, II)
        COUNT=0
        !------------------! VECTORIZE GAUSS POINTS AND WEIGHTS------------------------------
        DO I=1,N
            DO J=1,N
                COUNT=COUNT+1
                GSPT(COUNT)=REF2PHY(POINT2D(X(I),X(J)), INTPATCHGROUP(NDX_I, II, JJ)%SUBPATCH)
                WEIGHT(COUNT)=W(I)*W(J)
            ENDDO
        ENDDO
        !--------------------EVALUATE PU AND SF AT EACH GAUSS POINT----------------
        CALL PHYPU(PUSTORAGE(II,JJ,:), GSPT(:)%PT, N**2,  BGMESH(II)+DELTA)
    ENDDO
    ENDDO

    DO I=NDX_I, NUMPATCHES
        COUNT=0
        DO J=1, NINTPATCHGROUP(NDX_I, I)
            DO KK=1, NINTPATCHGROUP(NDX_I, NDX_I)
                IF (INTPATCHGROUP(NDX_I, I, J)%SUBINDEX.EQ.INTPATCHGROUP(NDX_I,NDX_I, KK)%SUBINDEX) THEN
                    COUNT=COUNT+1
                    PUDATA(I, COUNT)=KK
                ENDIF
            ENDDO
        ENDDO
    ENDDO
END SUBROUTINE PUDATUM

!----------------FINDING THE INTEGRAL SUBPATCHES(INTERSECTION AREA) FOR ALL PAIR OF PATCHES I, J---------
SUBROUTINE INTDOMAINTABLE(INTPATCHGROUP, NINTPATCHGROUP)

    TYPE(INTPATCH), INTENT(OUT) :: INTPATCHGROUP(NUMPATCHES,NUMPATCHES, NUMINTSUBPATCH)
    INTEGER, INTENT(OUT) :: NINTPATCHGROUP(NUMPATCHES, NUMPATCHES)
    TYPE(INTPATCH) :: INTPATCHES(NUMINTSUBPATCH)
    INTEGER :: I, J, KK, NINTPATCHES

!---------------------INITIALIZE---------------------
    DO I=1, NUMPATCHES
        DO J=1, NUMPATCHES
            DO KK=1, NUMINTSUBPATCH
                CALL INITIALIZE(INTPATCHGROUP(I,J,KK)%SUBPATCH)
                INTPATCHGROUP(I,J,KK)%SUBINDEX=0
                INTPATCHGROUP(I,J,KK)%PATCHNUMBER=0
            ENDDO
            NINTPATCHGROUP(I,J)=0
        ENDDO
    ENDDO

	DO I=1, NUMINTSUBPATCH
        CALL INITIALIZE(INTPATCHES(I)%SUBPATCH)
        INTPATCHES(I)%SUBINDEX=0
        INTPATCHES(I)%PATCHNUMBER=0
    ENDDO
!	PRINT*, 'HERE IS THE BUG 1'
!--------------------FIND THE INTERSECTION SUBPATCH AND SAVE IT---------------
    DO I=1, NUMPATCHES
        DO J=I, NUMPATCHES
            CALL INTDOMAIN(INTPATCHES, NINTPATCHES, BGMESH(I)+DELTA, I, BGMESH(J)+DELTA, J)
            DO KK=1, NINTPATCHES
                INTPATCHGROUP(I,J,KK)%SUBPATCH=INTPATCHES(KK)%SUBPATCH
                INTPATCHGROUP(I,J,KK)%SUBINDEX=INTPATCHES(KK)%SUBINDEX
                INTPATCHGROUP(I,J,KK)%PATCHNUMBER=INTPATCHES(KK)%PATCHNUMBER
                INTPATCHGROUP(J,I,KK)%SUBPATCH=INTPATCHES(KK)%SUBPATCH
                INTPATCHGROUP(J,I,KK)%SUBINDEX=INTPATCHES(KK)%SUBINDEX
                INTPATCHGROUP(J,I,KK)%PATCHNUMBER=INTPATCHES(KK)%PATCHNUMBER
            ENDDO
            NINTPATCHGROUP(I,J)=NINTPATCHES
            NINTPATCHGROUP(J,I)=NINTPATCHES
        ENDDO
!	PRINT*, 'HERE IS THE BUG 2', I
    ENDDO
!	PRINT*, 'HERE IS THE BUG 3'
END SUBROUTINE INTDOMAINTABLE

!----------------FIND THE INTEGRAL SUBCUBOIDS(INTERSECTION REGION) FOR SOME PAIR OF PATCHES I, J---------
SUBROUTINE INTDOMAIN(INTPATCHES, NINTPATCHES, RECPATCH1, PATCHNUMBER1, RECPATCH2, PATCHNUMBER2)

    TYPE(INTPATCH), INTENT(OUT) :: INTPATCHES(NUMINTSUBPATCH)
    INTEGER, INTENT(OUT) :: NINTPATCHES
    TYPE(RECPATCH), INTENT(IN) :: RECPATCH1, RECPATCH2
    INTEGER, INTENT(IN) :: PATCHNUMBER1, PATCHNUMBER2
    TYPE(RECPATCH) :: CENTERSUBPATCH1, CENTERSUBPATCH2, SPLITTEDPATCH1(NUMINTSUBPATCH), & 
    					  SPLITTEDPATCH2(NUMINTSUBPATCH), INTERSECTIONPATCH
    TYPE(POINT2D) :: PTS1(NUMINTSUBPATCH), PTS2(NUMINTSUBPATCH)
    REAL*8 :: PTX(2), PTY(2)
    INTEGER :: I, J, COUNT1, COUNT2, TMP_SUBINDEX1(NUMINTSUBPATCH), TMP_SUBINDEX2(NUMINTSUBPATCH)
    LOGICAL :: VALIDATION

!-----------------------INITIALIZE-----------------------
    DO I=1,NUMINTSUBPATCH
        CALL INITIALIZE(INTPATCHES(I)%SUBPATCH)
        CALL INITIALIZE(SPLITTEDPATCH1(I))
        CALL INITIALIZE(SPLITTEDPATCH2(I))
        INTPATCHES(I)%SUBINDEX=0
        INTPATCHES(I)%PATCHNUMBER=0
        TMP_SUBINDEX1(I)=0.0D0
        TMP_SUBINDEX2(I)=0.0D0
    ENDDO

    CALL INITIALIZE(CENTERSUBPATCH1)
    CALL INITIALIZE(CENTERSUBPATCH2)
    CALL INITIALIZE(INTERSECTIONPATCH)

    NINTPATCHES=0
    COUNT1=0
    COUNT2=0
!----------------------CHECK WHETHER OR NOT THERE IS INTERSECTION AREA-----------------
    VALIDATION=VALIDATE_INTERSECTION(RECPATCH1,RECPATCH2)
	
    IF (VALIDATION .EQV. .TRUE.) THEN

!----------------------FIND INTERSECTIN AREA--------------------------
        INTERSECTIONPATCH=RECPATCH1.AND.RECPATCH2

!-----------------------FIND CENTER RECTANGULAR SUB-PATCH FOR EACH PATCHES--------------
        CENTERSUBPATCH1=RECPATCH1+(-2*DELTA)
        CENTERSUBPATCH2=RECPATCH2+(-2*DELTA)

!-----------------------SPLIT RECTANGULAR PATCH INTO NUMINTSUBPATCH INTEGRRAL SUB-PATCHES------------------
        CALL SPLITRECPATCH(SPLITTEDPATCH1, RECPATCH1, CENTERSUBPATCH1)
        CALL SPLITRECPATCH(SPLITTEDPATCH2, RECPATCH2, CENTERSUBPATCH2)

!----------------------FIND CENTER POINTS OF EACH SUBCUBOIDS--------------
        CALL CENTERPTS(PTS1, SPLITTEDPATCH1)
        CALL CENTERPTS(PTS2, SPLITTEDPATCH2)

!-----------------------CHECK WHETHER OR NOT INTEGRAL SUB-PATCH IS INCLUDED IN INTERSECTION AREA----------

		PTX(1)=INTERSECTIONPATCH%PT1%X
		PTX(2)=INTERSECTIONPATCH%PT2%X
		PTY(1)=INTERSECTIONPATCH%PT1%Y
		PTY(2)=INTERSECTIONPATCH%PT4%Y
		
        DO I=1, NUMINTSUBPATCH
            IF ((PTS1(I)%X.GT.PTX(1).AND.PTS1(I)%X.LT.PTX(2)).AND. &
                  (PTS1(I)%Y.GT.PTY(1).AND.PTS1(I)%Y.LT.PTY(2)).AND. &
                  (PTS1(I)%X.GT.OMEGA%PT1%X.AND.PTS1(I)%X.LT.OMEGA%PT2%X).AND. &
                  (PTS1(I)%Y.GT.OMEGA%PT1%Y.AND.PTS1(I)%Y.LT.OMEGA%PT4%Y)) THEN
                  COUNT1=COUNT1+1
                  TMP_SUBINDEX1(COUNT1)=I
            ENDIF
            IF ((PTS2(I)%X.GT.INTERSECTIONPATCH%PT1%X.AND.PTS2(I)%X.LT.INTERSECTIONPATCH%PT2%X).AND. &
                  (PTS2(I)%Y.GT.INTERSECTIONPATCH%PT1%Y.AND.PTS2(I)%Y.LT.INTERSECTIONPATCH%PT4%Y).AND. &
                  (PTS2(I)%X.GT.OMEGA%PT1%X.AND.PTS2(I)%X.LT.OMEGA%PT2%X).AND. &
                  (PTS2(I)%Y.GT.OMEGA%PT1%Y.AND.PTS2(I)%Y.LT.OMEGA%PT4%Y)) THEN
                  COUNT2=COUNT2+1
                  TMP_SUBINDEX2(COUNT2)=I
            ENDIF
        ENDDO
!----------------------COMPARE TOTAL NUMER OF SUBPATCH THAT IS INCLUDED IN INTERSECTION AREA------
        IF (COUNT1.GE.COUNT2) THEN
            DO I=1,COUNT1
                INTPATCHES(I)%SUBPATCH=SPLITTEDPATCH1(TMP_SUBINDEX1(I))
                INTPATCHES(I)%SUBINDEX=TMP_SUBINDEX1(I)
                INTPATCHES(I)%PATCHNUMBER=PATCHNUMBER1
            ENDDO
            NINTPATCHES=COUNT1
        ELSEIF (COUNT1.LT.COUNT2) THEN
            DO I=1, COUNT2
                INTPATCHES(I)%SUBPATCH=SPLITTEDPATCH2(TMP_SUBINDEX2(I))
                INTPATCHES(I)%SUBINDEX=TMP_SUBINDEX2(I)
                INTPATCHES(I)%PATCHNUMBER=PATCHNUMBER2
            ENDDO
            NINTPATCHES=COUNT2
        ENDIF
    ENDIF

END SUBROUTINE INTDOMAIN

SUBROUTINE GET_COEFFOFEXACTSOL(C)
	REAL*8, INTENT(OUT) :: C(4)
	REAL*8 :: Q, D, F
	
	D = STRESS_D(1,1) ! PLATE CONSTANT
	Q = LOAD_Q ! LOAD CONSTANT
	
	C(:) = 0.0D0
	F	 = 0.0D0
		
	IF (BCTYPE.EQ.'CLAM') THEN
		F    = GAMMA*KS*G(1)*L**2 + (2.0D0*GAMMA*D / h) - (2.0D0*D / L)
		C(1) = -h**3 / (D*L**2)
		C(2) = ((-GAMMA*KS*G(1)*h**3 / D) - GAMMA*(h/L)**2 + (h/L)**3) / F
		C(3) = -GAMMA*KS*G(1)*L**2 / F
		C(4) = -KS*G(1)*h*L / F
	ELSEIF (BCTYPE.EQ.'HARD') THEN
		C(1) = -h**3 / (D*L**2)
		C(2) = -h**3 / (2.0D0*D*L**2)
		C(3) = 0.0D0
		C(4) = 0.0D0
	ELSEIF (BCTYPE.EQ.'SOFT') THEN
		F	 = -KS*G(1)*L**2*(GAMMA**2 + (h/L)**2) + (1.0D0 - V(1))*(h/L)*(GAMMA*KS*G(1)*L**2 - (D*L / h**2)* &
				(GAMMA - h/L)**2)
		C(1) = -h**3 / (D*L**2)
		C(2) = ((2.0D0*GAMMA*KS*G(1)*V(1)*h**4 / (D*L)) + (h/L - GAMMA)**2*((KS*G(1)*h**3 / D) + (1.0D0 - V(1))* &
				(h/L)**2)) / (2.0D0*F)
		C(3) = -GAMMA*KS*G(1)*L*h*(1-V(1)) / F
		C(4) = -KS*G(1)*h**3*(KS*G(1)*L**2 + D*(1-V(1)) / h) / (D*F)
	ELSEIF (BCTYPE.EQ.'FREE') THEN
		F	 = -2.0D0*KS*G(1)*L**2 + (1-V(1))*(KS*G(1)*L**2 - (D*L**2 / h**3)*(GAMMA - h / L)**2)
		C(1) = V(1)*(KS*G(1)*h**3 / D - (GAMMA**2 + (h/L)**2)) / F
		C(2) = KS*G(1)*V(1)*h**3 / (D*F)
		C(3) = 0.0D0
		C(4) = 2.0D0*KS*G(1)*V(1)*L**2 / F
	ENDIF

END MODULE GET_COEFFOFEXACTSOL

END MODULE PACKAGE
